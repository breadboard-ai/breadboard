{"edges":[{"from":"fetch-4","to":"output-5","out":"response","in":"api_json_response"},{"from":"fn-3","to":"fetch-4","out":"*","in":""},{"from":"input-1","to":"fn-3","out":"*","in":""}],"nodes":[{"id":"output-5","type":"output","configuration":{"schema":{"type":"object","properties":{"api_json_response":{"title":"response","description":"The response from the fetch request","type":["string","object"]}},"required":["api_json_response"]}}},{"id":"fetch-4","type":"fetch","configuration":{}},{"id":"fn-3","type":"invoke","configuration":{"path":"#fn-3"}},{"id":"input-1","type":"input","configuration":{}}],"kits":[],"graphs":{"fn-3":{"edges":[{"from":"fn-3-input","to":"fn-3-run","out":"*"},{"from":"fn-3-run","to":"fn-3-output","out":"*"}],"nodes":[{"id":"fn-3-input","type":"input","configuration":{}},{"id":"fn-3-run","type":"runJavascript","configuration":{"code":"function fn_3(itemToSplat) {\n            const { api_inputs } = itemToSplat;\n            const { method, parameters, secrets, requestBody } = itemToSplat.item;\n            let { url } = itemToSplat.item;\n            const queryStringParameters = {};\n            if (parameters != undefined &&\n                parameters.length > 0 &&\n                api_inputs == undefined) {\n                throw new Error(`Missing input for parameters ${JSON.stringify(parameters)}`);\n            }\n            for (const param of parameters) {\n                if (api_inputs &&\n                    param.name in api_inputs == false &&\n                    param.required) {\n                    throw new Error(`Missing required parameter ${param.name}`);\n                }\n                if (api_inputs && param.name in api_inputs == false) {\n                    // Parameter is not required and not in input, so we can skip it.\n                    continue;\n                }\n                if (param.in == \"path\") {\n                    // Replace the path parameter with the value from the input.\n                    url = url.replace(`{${param.name}}`, api_inputs[param.name]);\n                }\n                if (param.in == \"query\") {\n                    queryStringParameters[param.name] = api_inputs[param.name];\n                }\n            }\n            // // If the method is POST or PUT, then we need to add the requestBody to the body.\n            // We are going to want to add in the secret somehow\n            const headers = {};\n            // Create the query string\n            const queryString = Object.entries(queryStringParameters)\n                .map(([key, value]) => {\n                return `${key}=${value}`;\n            })\n                .join(\"&\");\n            if (queryString.length > 0) {\n                url = `${url}?${queryString}`;\n            }\n            if (secrets != undefined) {\n                // We know that we currently only support Bearer tokens.\n                if (\"bearer\" in api_inputs.authentication) {\n                    const envKey = api_inputs.authentication.bearer;\n                    const envValue = itemToSplat[envKey];\n                    headers[\"Authorization\"] = `Bearer ${envValue}`;\n                }\n            }\n            let body = undefined;\n            if (requestBody) {\n                // We know the method needs a request Body.\n                // Find the first input that matches the valid required schema of the API.\n                let requestContentType;\n                for (const requiredContentType of Object.keys(requestBody)) {\n                    if (requiredContentType in api_inputs) {\n                        body = api_inputs[requiredContentType];\n                        requestContentType = requiredContentType;\n                        break;\n                    }\n                }\n                if (body == undefined) {\n                    throw new Error(`Missing required request body for ${JSON.stringify(requestBody)}`);\n                }\n                headers[\"Content-Type\"] = requestContentType;\n            }\n            return { url, method, headers, body, queryString };\n        }","name":"fn_3","raw":true}},{"id":"fn-3-output","type":"output","configuration":{}}]}},"args":{"item":{"operationId":"generativelanguage.tunedModels.permissions.get","url":"https://generativelanguage.googleapis.com/v1beta3/tunedModels/{tunedModelsId}/permissions/{permissionsId}","method":"GET","description":"Gets information about a specific Permission.","parameters":[{"in":"path","name":"tunedModelsId","required":true,"schema":{"type":"string"}},{"in":"path","name":"permissionsId","required":true,"schema":{"type":"string"}},{"description":"OAuth 2.0 token for the current user.","in":"query","name":"oauth_token","schema":{"type":"string"}},{"description":"API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.","in":"query","name":"key","schema":{"type":"string"}},{"description":"Selector specifying which fields to include in a partial response.","in":"query","name":"fields","schema":{"type":"string"}},{"description":"V1 error format.","in":"query","name":"$.xgafv","schema":{"type":"string","enum":["1","2"]}},{"description":"Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.","in":"query","name":"quotaUser","schema":{"type":"string"}},{"description":"OAuth access token.","in":"query","name":"access_token","schema":{"type":"string"}},{"description":"Upload protocol for media (e.g. \"raw\", \"multipart\").","in":"query","name":"upload_protocol","schema":{"type":"string"}},{"description":"Returns response with indentations and line breaks.","in":"query","name":"prettyPrint","schema":{"type":"boolean"}},{"description":"Legacy upload protocol for media (e.g. \"media\", \"multipart\").","in":"query","name":"uploadType","schema":{"type":"string"}},{"description":"Data format for response.","in":"query","name":"alt","schema":{"type":"string","enum":["json","media","proto"]}},{"description":"JSONP","in":"query","name":"callback","schema":{"type":"string"}}]}}}