{"edges":[{"from":"fetch-4","to":"output-5","out":"response","in":"api_json_response"},{"from":"fn-3","to":"fetch-4","out":"*","in":""},{"from":"input-1","to":"fn-3","out":"*","in":""}],"nodes":[{"id":"output-5","type":"output","configuration":{"schema":{"type":"object","properties":{"api_json_response":{"title":"response","description":"The response from the fetch request","type":["string","object"]}},"required":["api_json_response"]}}},{"id":"fetch-4","type":"fetch","configuration":{}},{"id":"fn-3","type":"invoke","configuration":{"path":"#fn-3"}},{"id":"input-1","type":"input","configuration":{"schema":{"type":"object","properties":{"api_inputs":{"type":"object","title":"API Inputs","description":"The input to the API"}}}}}],"kits":[],"graphs":{"fn-3":{"edges":[{"from":"fn-3-input","to":"fn-3-run","out":"*"},{"from":"fn-3-run","to":"fn-3-output","out":"*"}],"nodes":[{"id":"fn-3-input","type":"input","configuration":{}},{"id":"fn-3-run","type":"runJavascript","configuration":{"code":"function fn_3(itemToSplat) {\n            const { input, api_inputs } = itemToSplat;\n            const { method, parameters, secrets, requestBody } =\n              itemToSplat.item;\n            let { url } = itemToSplat.item;\n            const queryStringParameters = {};\n            if (\n              parameters != undefined &&\n              parameters.length > 0 &&\n              input == undefined\n            ) {\n              throw new Error(\n                `Missing input for parameters ${JSON.stringify(parameters)}`\n              );\n            }\n            for (const param of parameters) {\n              if (input && param.name in input == false && param.required) {\n                throw new Error(`Missing required parameter ${param.name}`);\n              }\n              if (input && param.name in input == false) {\n                // Parameter is not required and not in input, so we can skip it.\n                continue;\n              }\n              if (param.in == \"path\") {\n                // Replace the path parameter with the value from the input.\n                url = url.replace(`{${param.name}}`, input[param.name]);\n              }\n              if (param.in == \"query\") {\n                queryStringParameters[param.name] = input[param.name];\n              }\n            }\n            // // If the method is POST or PUT, then we need to add the requestBody to the body.\n            // We are going to want to add in the secret somehow\n            const headers = {};\n            // Create the query string\n            const queryString = Object.entries(queryStringParameters)\n              .map((key, value) => {\n                return `${key}=${value}`;\n              })\n              .join(\"&\");\n            if (queryString.length > 0) {\n              url = `${url}?${queryString}`;\n            }\n            if (secrets != undefined) {\n              // We know that we currently only support Bearer tokens.\n              const envKey = api_inputs.bearer;\n              const envValue = itemToSplat[envKey];\n              headers[\"Authorization\"] = `Bearer ${envValue}`;\n            }\n            let body = undefined;\n            if (requestBody) {\n              // We know the method needs a request Body.\n              // Find the first input that matches the valid required schema of the API.\n              let requestContentType;\n              for (const requiredContentType of Object.keys(requestBody)) {\n                if (requiredContentType in api_inputs) {\n                  body = api_inputs[requiredContentType];\n                  requestContentType = requiredContentType;\n                  break;\n                }\n              }\n              if (body == undefined) {\n                throw new Error(\n                  `Missing required request body for ${JSON.stringify(\n                    requestBody\n                  )}`\n                );\n              }\n              headers[\"Content-Type\"] = requestContentType;\n            }\n            return { url, method, headers, body, queryString };\n          }","name":"fn_3","raw":true}},{"id":"fn-3-output","type":"output","configuration":{}}]}},"args":{"item":{"operationId":"listMessages","url":"https://api.openai.com/v1/threads/{thread_id}/messages","method":"GET","summary":"Returns a list of messages for a given thread.","parameters":[{"in":"path","name":"thread_id","required":true,"schema":{"type":"string"},"description":"The ID of the [thread](/docs/api-reference/threads) the messages belong to."},{"name":"limit","in":"query","description":"A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.\n","required":false,"schema":{"type":"integer","default":20}},{"name":"order","in":"query","description":"Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.\n","schema":{"type":"string","default":"desc","enum":["asc","desc"]}},{"name":"after","in":"query","description":"A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.\n","schema":{"type":"string"}},{"name":"before","in":"query","description":"A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list.\n","schema":{"type":"string"}}],"secrets":["ApiKeyAuth",{"type":"http","scheme":"bearer"}]}}}