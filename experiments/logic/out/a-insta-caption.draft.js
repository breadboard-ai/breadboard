export default async (inputs, capabilities) => {
  const {
    generate
  } = capabilities;
  const {
    console
  } = capabilities;

  const inputContent = inputs.input1;
  if (!inputContent || !inputContent.parts || inputContent.parts.length === 0) {
    console.log("No input parts provided.");
    return {
      parts: []
    };
  }

  // Filter out only the image parts from the input.
  const imageParts = inputContent.parts.filter(
    (part) => part.fileData && part.fileData.mimeType?.startsWith("image/")
  );

  if (imageParts.length === 0) {
    console.log("Input did not contain any image parts.");
    return {
      parts: []
    };
  }

  // Create a promise for each image to generate its caption.
  const captionPromises = imageParts.map(async (imagePart) => {
    try {
      const response = await generate.generateContent({
        model: "gemini-1.5-pro-latest",
        contents: [{
          parts: [{
            text: "Provide a catchy caption suitable for an Instagram post."
          }, imagePart],
        }, ],
      });

      const candidate = response.candidates?.[0];
      const captionText = candidate?.content?.parts?.[0]?.text;

      if (!captionText) {
        throw new Error("No caption generated by the model.");
      }

      // Return the original image part and a new text part for the caption.
      return [imagePart, {
        text: `\n\n${captionText.trim()}\n\n`
      }];
    } catch (e) {
      console.error(`Failed to generate caption for an image:`, e);
      // In case of an error, return the image with an error message as the caption.
      return [imagePart, {
        text: "\n\nError: Could not generate a caption for this image.\n\n"
      }];
    }
  });

  // Wait for all caption generation promises to resolve.
  const results = await Promise.all(captionPromises);

  // Flatten the array of [image, caption] pairs into a single array.
  const outputParts = results.flat();

  // Return the final collated content.
  return {
    parts: outputParts
  };
};