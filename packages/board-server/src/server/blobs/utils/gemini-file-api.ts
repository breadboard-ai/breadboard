/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import { err, type Outcome } from "@google-labs/breadboard";
import type { FileAPIMetadata } from "../../blob-store.js";
import type { Readable } from "stream";
import { hasExpired } from "../file-info.js";

export type FileApiState =
  // The default value. This value is used if the state is omitted.
  | "STATE_UNSPECIFIED"
  // File is being processed and cannot be used for inference yet.
  | "PROCESSING"
  // File is processed and available for inference.
  | "ACTIVE"
  // File failed processing.
  | "FAILED";

export type FileApiSource =
  // Used if source is not specified.
  | "SOURCE_UNSPECIFIED"
  // Indicates the file is uploaded by the user.
  | "UPLOADED"
  // Indicates the file is generated by Google.
  | "GENERATED";

export type FileApiError = {
  code: number;
  message: string;
  details: Record<string, string>;
};

export type FileApiFile = {
  name: string;
  displayName: string;
  mimeType: string;
  sizeBytes: string;
  createTime: string;
  updateTime: string;
  expirationTime: string;
  sha256hash: string;
  uri: string;
  downloadUri?: string;
  state: FileApiState;
  source: FileApiSource;
  error?: FileApiError;
};

export type FileApiResponse = {
  file: FileApiFile;
};

export { GeminiFileApi };

const CHUNK_GRANULARITY = 8 * 1024 * 1024;

const WAITING_TIME_MS = 5 * 1024;

const API_URL = "https://generativelanguage.googleapis.com";

type CavemanCacheEntry = {
  expirationTime: string;
  fileUri: string;
  mimeType: string;
};

/**
 * This is the most primivite cache that could be imagined, but it
 * gets the job done for now.
 */
class CavemanCache {
  #map: Map<string, CavemanCacheEntry> = new Map();

  #makeKey(driveId: string, mode: string) {
    return `${mode}:${driveId}`;
  }

  get(driveId: string, mode: string) {
    const key = this.#makeKey(driveId, mode);
    const entry = this.#map.get(key);
    if (!entry) return;

    if (hasExpired(entry.expirationTime)) {
      this.#map.delete(key);
      return;
    }

    return entry;
  }

  set(driveId: string, mode: string, entry: CavemanCacheEntry) {
    this.#map.set(this.#makeKey(driveId, mode), entry);
  }
}

class GeminiFileApi {
  #apiKey: string;

  static #cache: CavemanCache = new CavemanCache();
  static cache() {
    return GeminiFileApi.#cache;
  }

  constructor() {
    this.#apiKey = process.env.GEMINI_KEY ?? "";
  }

  #createInitialRequest(
    apiKey: string,
    length: string | number,
    mimeType: string,
    displayName: string
  ): Request {
    return new Request(`${API_URL}/upload/v1beta/files?key=${apiKey}`, {
      method: "POST",
      headers: {
        "X-Goog-Upload-Protocol": "resumable",
        "X-Goog-Upload-Command": "start",
        "X-Goog-Upload-Header-Content-Length": `${length}`,
        "X-Goog-Upload-Header-Content-Type": mimeType,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        file: {
          display_name: displayName,
        },
      }),
    });
  }

  #createUploadRequest(
    body: Buffer<ArrayBuffer>,
    uploadUrl: string,
    length: number,
    offset: number,
    finalize: boolean
  ): Request {
    const command: string[] = ["upload"];
    if (finalize) command.push("finalize");
    return new Request(uploadUrl, {
      method: "POST",
      headers: {
        "Content-Length": `${length}`,
        "X-Goog-Upload-Offset": `${offset}`,
        "X-Goog-Upload-Command": command.join(", "),
      },
      body,
    });
  }

  #createGetFileRequest(apiKey: string, fileUri: string): Request {
    return new Request(`${fileUri}?key=${apiKey}`);
  }

  async #waitTillProcessed(
    apiKey: string,
    response: FileApiResponse
  ): Promise<Outcome<FileAPIMetadata>> {
    const { uri } = response.file;
    for (;;) {
      await sleep(WAITING_TIME_MS);
      try {
        const checkingStatus = await fetch(
          this.#createGetFileRequest(apiKey, uri)
        );
        if (!checkingStatus.ok) {
          return err(await checkingStatus.text());
        }
        const result = (await checkingStatus.json()) as FileApiFile;
        const { state } = result;
        if (state === "ACTIVE") {
          const { uri: fileUri, expirationTime } = result;
          return { fileUri, expirationTime };
        } else if (state === "FAILED") {
          return err(`File API failed to process file "${uri}"`);
        }
      } catch (e) {
        return err((e as Error).message);
      }
    }
  }

  async upload(
    length: string | number,
    mimeType: string,
    displayName: string,
    body: Readable
  ): Promise<Outcome<FileAPIMetadata>> {
    if (!this.#apiKey) {
      return err("GEMINI_KEY environment variable is not defined");
    }
    try {
      const initializing = await fetch(
        this.#createInitialRequest(this.#apiKey, length, mimeType, displayName)
      );
      if (!initializing.ok) {
        return err(await initializing.text());
      }

      const uploadUrl = initializing.headers.get("x-goog-upload-url");

      if (!uploadUrl) {
        return err(`Unable to get upload URL for file "${displayName}"`);
      }

      let offset = 0;

      for await (const buffer of readInChunks(body)) {
        const finalize = buffer.length < CHUNK_GRANULARITY;
        const length = buffer.length;
        const uploading = await fetch(
          this.#createUploadRequest(buffer, uploadUrl, length, offset, finalize)
        );
        if (!uploading.ok) {
          return err(await uploading.text());
        }
        if (finalize) {
          const result = (await uploading.json()) as FileApiResponse;
          const { file } = result;
          if (file.state === "FAILED") {
            return err(file.error?.message || "File API upload failed");
          }
          if (file.state === "PROCESSING") {
            return this.#waitTillProcessed(this.#apiKey, result);
          }
          return {
            fileUri: file.uri,
            expirationTime: file.expirationTime,
          };
        }
        offset += length;
      }

      return {};
    } catch (e) {
      return err((e as Error).message);
    }
  }
}

async function* readInChunks(stream: Readable) {
  let buffer = Buffer.alloc(0);

  for await (const chunk of stream) {
    buffer = Buffer.concat([buffer, chunk]);

    while (buffer.length >= CHUNK_GRANULARITY) {
      yield buffer.subarray(0, CHUNK_GRANULARITY);
      buffer = buffer.subarray(CHUNK_GRANULARITY);
    }
  }

  if (buffer.length > 0) {
    yield buffer;
  }
}

async function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
