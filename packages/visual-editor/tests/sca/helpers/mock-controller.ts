/**
 * @license
 * Copyright 2026 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import { mock } from "node:test";
import type { EditableGraph } from "@breadboard-ai/types";
import { AppController } from "../../../src/sca/controller/controller.js";
import { RunController } from "../../../src/sca/controller/subcontrollers/run/run-controller.js";
import type { FlowgenInputStatus } from "../../../src/sca/controller/subcontrollers/global/flowgen-input-controller.js";
import { SnackType, SnackbarUUID } from "../../../src/ui/types/types.js";

/**
 * Shared controller mocks for SCA tests.
 */

const defaultGraph = {
  version: 0,
  graphIsMine: true,
};

/**
 * Creates a mock FlowgenInputController for testing.
 */
export function makeMockFlowgenInput() {
  return {
    inputValue: "",
    state: { status: "initial" } as FlowgenInputStatus,
    clear() {
      this.inputValue = "";
      this.state = { status: "initial" };
    },
  };
}

/**
 * Creates a mock snackbar controller for testing.
 * Tracks all snackbars and provides test helpers.
 */
export function makeMockSnackbarController() {
  const snackbars: Map<SnackbarUUID, { message: string; type: SnackType }> =
    new Map();
  let lastId: SnackbarUUID | null = null;

  return {
    snackbar: (
      message: string,
      type: SnackType,
      _actions?: unknown[],
      _persistent?: boolean,
      _id?: SnackbarUUID,
      _replaceAll?: boolean
    ): SnackbarUUID => {
      const id = _id ?? (globalThis.crypto.randomUUID() as SnackbarUUID);
      snackbars.set(id, { message, type });
      lastId = id;
      return id;
    },
    update: (id: SnackbarUUID, message: string, type: SnackType) => {
      snackbars.set(id, { message, type });
      return true;
    },
    unsnackbar: (id?: SnackbarUUID) => {
      if (id) {
        snackbars.delete(id);
      } else {
        snackbars.clear();
      }
    },
    // Test helpers
    get entries() {
      return snackbars;
    },
    get lastId() {
      return lastId;
    },
  };
}

export interface TestControllerOptions {
  /** Editor to use - if provided, creates controller with editor-backed graph */
  editor?: EditableGraph;
  /** Custom graph for non-editor tests */
  graph?: typeof defaultGraph;
}

/**
 * Creates a test controller with all mocks pre-configured.
 * Returns the controller and mocks for test access.
 */
export function makeTestController(options: TestControllerOptions = {}) {
  const { editor, graph = defaultGraph } = options;
  const flowgenInput = makeMockFlowgenInput();
  const snackbars = makeMockSnackbarController();
  const main = { blockingAction: false };
  const runStop = mock.fn();

  const controller = {
    global: {
      debug: { enabled: true },
      snackbars,
      main,
      toasts: {
        toast: mock.fn(),
        untoast: mock.fn(),
      },
      ...(flowgenInput && { flowgenInput }),
    },
    board: {
      main: { newerVersionAvailable: false },
    },
    run: {
      main: editor
        ? { stop: runStop }
        : new RunController("test-run-controller", "test"),
    },
    router: {
      updateFromCurrentUrl: () => { },
      init: () => { },
    },
    editor: {
      graph: editor ? { editor, lastNodeConfigChange: null } : graph,
      selection: {
        selectionId: 0,
      },
      sidebar: {
        section: null,
      },
      step: {
        pendingEdit: null,
        pendingAssetEdit: null,
        clearPendingEdit: mock.fn(),
        clearPendingAssetEdit: mock.fn(),
      },
      share: {
        state: { status: "closed"},
      },
    },
  } as unknown as AppController;

  return {
    controller,
    mocks: {
      flowgenInput,
      snackbars,
      main,
      runStop,
    },
  };
}

/**
 * Options for creating a mock EditableGraph.
 */
export interface MockEditorOptions {
  /** Node ID to return from nodeById - defaults to "test-node" */
  nodeId?: string;
  /** Callback when apply() is called */
  onApply?: (transform: unknown) => void;
  /** Callback when graphchange listener is registered */
  onGraphChange?: (callback: () => void) => void;
  /** Custom raw graph data */
  rawGraph?: Record<string, unknown>;
  /** Mock nodes for testing component update paths */
  mockNodes?: MockNode[];
}

/**
 * Mock node for testing component update paths.
 */
export interface MockNode {
  id: string;
  type: string;
  title?: string;
  description?: string;
  /** If true, ports are still updating (causes async path) */
  portsUpdating?: boolean;
  /** Tags in metadata (causes sync path when present with non-updating ports) */
  tags?: string[];
}

/**
 * Creates a mock EditableGraph that has the required methods for the
 * GraphController's setEditor to work.
 */
export function createMockEditor(options?: MockEditorOptions): EditableGraph {
  const nodeId = options?.nodeId ?? "test-node";
  const rawGraph = options?.rawGraph ?? {
    nodes: [{ id: nodeId, type: "promptTemplate" }],
  };
  const mockNodes = options?.mockNodes ?? [];

  // Create mock InspectableNode objects
  const inspectableNodes = mockNodes.map((node) => ({
    descriptor: { id: node.id, type: node.type },
    title: () => node.title ?? node.type,
    description: () => node.description ?? "",
    currentPorts: () => ({
      inputs: { ports: [] },
      outputs: { ports: [] },
      updating: node.portsUpdating ?? false,
    }),
    currentDescribe: () => ({
      metadata: node.tags ? { tags: node.tags } : {},
    }),
    ports: () =>
      Promise.resolve({
        inputs: { ports: [] },
        outputs: { ports: [] },
      }),
    describe: () => Promise.resolve({ metadata: {} }),
  }));

  const mockInspectable = {
    graphs: () => ({}),
    nodes: () => inspectableNodes,
    raw: () => rawGraph,
    nodeById: (id: string) =>
      id === nodeId ? { descriptor: { type: "promptTemplate" } } : undefined,
  };

  return {
    raw: () => rawGraph,
    inspect: () => mockInspectable,
    addEventListener: (_event: string, callback: () => void) => {
      if (options?.onGraphChange) {
        options.onGraphChange(callback);
      }
    },
    removeEventListener: () => {},
    apply: async (transform: unknown) => {
      options?.onApply?.(transform);
      return { success: true };
    },
  } as unknown as EditableGraph;
}

/**
 * Waits for microtask effects to run.
 */
export async function flushEffects() {
  await new Promise<void>((resolve) => queueMicrotask(resolve));
}
