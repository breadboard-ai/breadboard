/**
 * @fileoverview Renders multiple outputs into single display.
 */

import {
  Capabilities,
  GraphDescriptor,
  LLMContent,
  Outcome,
  Schema,
  TextCapabilityPart,
} from "@breadboard-ai/types";
import connectorSave from "../google-drive/connector-save.js";
import { callGenWebpage } from "./html-generator.js";
import { Template } from "./template.js";
import { err, llm, mergeContent, ok, toLLMContent, toText } from "./utils.js";
import { readFlags } from "./settings.js";
import { renderConsistentUI } from "./render-consistent-ui.js";
import { A2ModuleArgs } from "../runnable-module-factory.js";
import { Params } from "./common.js";
import { isLLMContent, isLLMContentArray } from "../../data/common.js";

export { invoke as default, describe };

const MANUAL_MODE = "Manual layout";
const FLASH_MODE = "Webpage with auto-layout by 2.5 Flash";
const PRO_MODE = "Webpage with auto-layout by 2.5 Pro";

const THROW_ERROR_MARKER = "throw_error ";

type RenderType =
  | "Manual"
  | "HTML"
  | "GoogleDoc"
  | "GoogleSlides"
  | "GoogleSheets"
  | "ConsistentUI";

type Mode = {
  id: string;
  renderType: RenderType;
  title: string;
  description: string;
  icon: string;
};

type Model = {
  id: string;
  title: string;
  description: string;
  modelName: string;
};

const MODELS: Model[] = [
  {
    id: "gemini-flash",
    title: "Gemini 2.5 Flash",
    description: "Best for coding simple, static displays",
    modelName: "gemini-2.5-flash",
  },
  {
    id: "gemini-flash-lite",
    title: "Gemini 2.5 Flash Lite",
    description: "Best for simple speedy displays",
    modelName: "gemini-2.5-flash-lite",
  },
  {
    id: "gemini-pro",
    title: "Gemini 2.5 Pro",
    description: "Best for coding complex or interactive displays",
    modelName: "gemini-2.5-pro",
  },
];

const MODES: Mode[] = [
  {
    id: MANUAL_MODE,
    renderType: "Manual",
    icon: "responsive_layout",
    title: "Manual layout",
    description: "Content is displayed exactly as typed",
  },
  {
    id: "consistent-ui",
    renderType: "ConsistentUI",
    title: "Smart Layout",
    icon: "web",
    description: "Consistent and automatic layout",
  },
  {
    id: "Auto",
    renderType: "HTML",
    icon: "web",
    title: "Webpage with auto-layout",
    description: "Layout automatically generated by Gemini",
  },
  {
    id: "google-doc",
    renderType: "GoogleDoc",
    title: "Save to Google Docs",
    icon: "docs",
    description: "Save content to a Google Document",
  },
  {
    id: "google-slides",
    renderType: "GoogleSlides",
    title: "Save to Google Slides",
    icon: "drive_presentation",
    description: "Save content as a Google Drive Presentation",
  },
  {
    id: "google-sheets",
    renderType: "GoogleSheets",
    title: "Save to Google Sheets",
    icon: "sheets",
    description: "Save content as a Google Drive Spreadsheet",
  },
] as const;

const renderModeMap = new Map(MODES.map((mode) => [mode.id, mode]));

function getMode(modeId: string | undefined): Mode {
  return renderModeMap.get(modeId || "Manual") || MODES[0];
}

const modelMap = new Map(MODELS.map((model) => [model.id, model]));

function getModel(modelType: string | undefined): Model {
  return modelMap.get(modelType || "gemini-flash") || MODELS[0];
}

function defaultSystemInstruction(): LLMContent {
  return llm`You are a skilled web developer specializing in creating intuitive and visually appealing HTML web pages based on user instructions and data. Your task is to generate a valid HTML webpage that will be rendered in an iframe. The generated code must be valid and functional HTML with JavaScript and CSS embedded inline within <script> and <style> tags respectively. Return only the code, and open the HTML codeblock with the literal string '\`\`\`html'. Render content as a clean, well-structured webpage, paying careful attention to user instructions. Use a responsive or mobile-friendly layout whenever possible and minimize unnecessary padding or margins.`.asContent();
}

type InvokeInputs = {
  text?: LLMContent;
  "p-render-mode": string;
  "b-system-instruction"?: LLMContent;
  "b-render-model-name": string;
  "b-google-doc-title"?: string;
  "b-slide-deck-mode"?: string;
  "b-slide-write-mode"?: string;
};

type InvokeOutputs = {
  context: LLMContent[];
};

type SaveOutput = {
  context: { parts: { json: { id: string } }[] }[];
};

type DescribeInputs = {
  inputs: {
    text?: LLMContent;
    "p-render-mode": string;
    "b-slide-deck-mode"?: string;
  };
};

type ThemeColors = {
  primaryColor?: string;
  secondaryColor?: string;
  backgroundColor?: string;
  textColor?: string;
  primaryTextColor?: string;
};

type Color = {
  25?: string;
  50?: string;
  80?: string;
  90?: string;
  95?: string;
  98?: string;
};

type PaletteColors = {
  error?: Color;
  neutral?: Color;
  neutralVariant?: Color;
  primary?: Color;
  secondary?: Color;
  tertiary?: Color;
};

function defaultThemeColors(): ThemeColors {
  return {
    primaryColor: "#246db5",
    secondaryColor: "#5cadff",
    backgroundColor: "#ffffff",
    textColor: "#1a1a1a",
    primaryTextColor: "#ffffff",
  };
}

function getThemeColors(graph: GraphDescriptor | undefined): ThemeColors {
  if (!graph) return defaultThemeColors();
  const currentThemeId = graph.metadata?.visual?.presentation?.theme;
  if (!currentThemeId) return defaultThemeColors();
  const themeColors =
    graph.metadata?.visual?.presentation?.themes?.[currentThemeId]?.themeColors;
  if (!themeColors) return defaultThemeColors();
  return { ...defaultThemeColors(), ...themeColors };
}

function getPaletteColors(
  graph: GraphDescriptor | undefined
): PaletteColors | undefined {
  if (!graph) return;
  const currentThemeId = graph.metadata?.visual?.presentation?.theme;
  if (!currentThemeId) return;
  const palette =
    graph.metadata?.visual?.presentation?.themes?.[currentThemeId]?.palette;
  if (!palette) return {};
  return { ...palette };
}

function themeColorsPrompt(colors: ThemeColors): string {
  return `Unless otherwise specified, use the following theme colors:

- primary color: ${colors.primaryColor}
- secondary color: ${colors.secondaryColor}
- background color: ${colors.backgroundColor}
- text color: ${colors.textColor}
- primary text color: ${colors.primaryTextColor}

`;
}

function getPalettePrompt(colors: PaletteColors): string {
  return `Unless otherwise specified, use the following theme colors:
  
  - primary color, dark: ${colors.primary?.[25]}
  - primary color, light: ${colors.primary?.[98]}
  - secondary color, dark: ${colors.secondary?.[25]}
  - secondary color, light: ${colors.secondary?.[95]}
  - tertiary color, dark: ${colors.tertiary?.[25]}
  - tertiary color, light: ${colors.tertiary?.[80]}
  - background color: ${colors.secondary?.[90]}
  - error color: ${colors.error?.[50]}
  - neutral, dark: ${colors.neutral?.[25]}
  - neutral, light: ${colors.neutral?.[98]}
  `;
}

async function saveToGoogleDrive(
  caps: Capabilities,
  moduleArgs: A2ModuleArgs,
  content: LLMContent,
  mimeType: string,
  title: string | undefined,
  slideDeckMode?: string,
  slideWriteMode?: string
): Promise<Outcome<SaveOutput>> {
  const graph = moduleArgs.context.currentGraph;
  let graphId = "";
  if (graph) {
    if (!title) {
      title = `${graph.title} (Opal App)`;
    }
    graphId = graph.url?.replace("drive:/", "") || "";
  }
  const id = moduleArgs.context.currentStep?.id || "render-outputs";
  return connectorSave(
    {
      method: "save",
      id,
      context: [content],
      title,
      graphId,
      info: {
        configuration: {
          file: { mimeType, preview: "", id: "" },
          slideDeckMode: slideDeckMode as "new" | "same" | undefined,
          slideWriteMode: slideWriteMode as
            | "prepend"
            | "append"
            | "overwrite"
            | undefined,
        },
      },
    },
    caps,
    moduleArgs
  ) as Promise<Outcome<SaveOutput>>;
}

function paramsToContent(params: Params): LLMContent {
  const parts = Object.values(params).flatMap((value) => {
    if (typeof value === "string") {
      return { text: value } as TextCapabilityPart;
    } else if (isLLMContent(value)) {
      return value.parts;
    } else if (isLLMContentArray(value)) {
      return value.at(-1)?.parts || [];
    }
    return { text: JSON.stringify(value) };
  });
  return { parts, role: "user" };
}

async function invoke(
  {
    text,
    "p-render-mode": renderMode,
    "b-system-instruction": systemInstruction,
    "b-render-model-name": modelType,
    "b-google-doc-title": googleDocTitle,
    "b-slide-deck-mode": slideDeckMode,
    "b-slide-write-mode": slideWriteMode,
    ...params
  }: InvokeInputs,
  caps: Capabilities,
  moduleArgs: A2ModuleArgs
): Promise<Outcome<InvokeOutputs>> {
  let { modelName } = getModel(modelType);
  const { renderType } = getMode(renderMode);

  if (!text) {
    text = toLLMContent("");
  }
  let systemText = toText(systemInstruction ?? defaultSystemInstruction());
  const template = new Template(text, moduleArgs.context.currentGraph);
  const substituting = await template.substitute(params, async () => "");
  if (!ok(substituting)) {
    return substituting;
  }

  const context = mergeContent([substituting], "user");
  // If the step uses one of the deprecated modes that encodes model, trust this.
  if (renderMode == FLASH_MODE) {
    modelName = "gemini-2.5-flash";
  } else if (renderMode == PRO_MODE) {
    modelName = "gemini-2.5-pro";
  }
  console.log("Rendering with mode: ", renderType);
  console.log("Rendering with model: ", modelName);
  let out = context;
  switch (renderType) {
    case "Manual": {
      const firstTextPart = (out.parts.at(0) as TextCapabilityPart)?.text;
      if (firstTextPart?.startsWith(THROW_ERROR_MARKER)) {
        return err(firstTextPart.slice(THROW_ERROR_MARKER.length));
      }
      return { context: [out] };
    }
    case "HTML": {
      const graph = moduleArgs.context.currentGraph;
      const palette = getPaletteColors(graph);
      if (palette?.primary) {
        systemText += getPalettePrompt(palette);
      } else {
        const themeColors = getThemeColors(graph);
        systemText += themeColorsPrompt(themeColors);
      }
      console.log("SI :", systemText);
      const webPage = await callGenWebpage(
        caps,
        moduleArgs,
        systemText,
        [context],
        renderType,
        modelName
      );
      if (!ok(webPage)) {
        console.warn(
          "Failed to generate html output, returning inputs as output",
          webPage.$error
        );
        return { context: [paramsToContent(params)] };
      } else {
        out = webPage;
        console.log(out);
      }
      if (!ok(out)) return err(out);
      return { context: [out] };
    }
    case "GoogleDoc": {
      return saveToGoogleDrive(
        caps,
        moduleArgs,
        out,
        "application/vnd.google-apps.document",
        googleDocTitle
      );
    }
    case "GoogleSlides": {
      return saveToGoogleDrive(
        caps,
        moduleArgs,
        out,
        "application/vnd.google-apps.presentation",
        googleDocTitle,
        slideDeckMode,
        slideWriteMode
      );
    }
    case "GoogleSheets": {
      return saveToGoogleDrive(
        caps,
        moduleArgs,
        out,
        "application/vnd.google-apps.spreadsheet",
        googleDocTitle
      );
    }
    case "ConsistentUI": {
      const context = await renderConsistentUI(
        caps,
        moduleArgs,
        out,
        systemInstruction
      );
      if (!ok(context)) return context;
      return { context };
    }
  }
  return { context: [out] };
}

function advancedSettings(
  renderType: RenderType,
  slideDeckMode?: string
): Record<string, Schema> {
  switch (renderType) {
    case "HTML":
      return {
        "b-system-instruction": {
          type: "object",
          behavior: ["llm-content", "config", "hint-advanced"],
          title: "System Instruction",
          description: "The system instruction used for auto-layout",
        },
        "b-render-model-name": {
          type: "string",
          enum: MODELS,
          behavior: ["llm-content", "config", "hint-advanced"],
          title: "Model",
          description: "The model to use for auto-generating display code",
        },
      };
    case "GoogleDoc": {
      return {
        "b-google-doc-title": {
          type: "string",
          behavior: ["config", "hint-advanced"],
          title: "Google Doc Title",
          description:
            "The title of the Google Drive Document that content will be saved to",
        },
      };
    }
    case "GoogleSlides": {
      const settings: Record<string, Schema> = {
        "b-slide-deck-mode": {
          type: "string",
          enum: [
            {
              id: "new",
              title: "New slide deck",
            },
            {
              id: "same",
              title: "Same slide deck",
            },
          ],
          behavior: ["config", "hint-advanced", "reactive"],
          title: "Edit each time",
          default: "new",
        },
      };
      if (slideDeckMode === "same") {
        settings["b-slide-write-mode"] = {
          type: "string",
          enum: [
            {
              id: "prepend",
              title: "Prepend",
              description: "Add to the beginning",
            },
            {
              id: "append",
              title: "Append",
              description: "Add to the end",
            },
            {
              id: "overwrite",
              title: "Overwrite",
              description: "Replace everything",
            },
          ],
          behavior: ["config", "hint-advanced", "reactive"],
          title: "Write mode",
          default: "prepend",
        };
      }
      settings["b-google-doc-title"] = {
        type: "string",
        behavior: ["config", "hint-advanced"],
        title: "Slide deck name",
        description: "Title of slide deck",
      };
      return settings;
    }
    case "GoogleSheets": {
      return {
        "b-google-doc-title": {
          type: "string",
          behavior: ["config", "hint-advanced"],
          title: "Google Spreadsheet Title",
          description:
            "The title of a Google Drive Spreadsheet that content will be saved to",
        },
      };
    }
    case "ConsistentUI": {
      return {
        "b-system-instruction": {
          type: "object",
          behavior: ["llm-content", "config", "hint-advanced"],
          title: "UI System Instruction",
          description: "The system instruction used for auto-layout",
        },
      };
    }
  }
  return {};
}

async function describe(
  {
    inputs: {
      text,
      "p-render-mode": renderMode,
      "b-slide-deck-mode": slideDeckMode,
    },
  }: DescribeInputs,
  _caps: Capabilities,
  moduleArgs: A2ModuleArgs
) {
  const flags = await readFlags(moduleArgs);
  const showConsistentUIMode = flags?.consistentUI ?? false;
  const modes = showConsistentUIMode
    ? MODES
    : MODES.filter(({ id }) => id !== "consistent-ui");

  const template = new Template(text, moduleArgs.context.currentGraph);
  const { renderType, icon } = getMode(renderMode);

  return {
    inputSchema: {
      type: "object",
      properties: {
        text: {
          type: "object",
          behavior: ["llm-content", "hint-preview", "config", "at-wireable"],
          title: "Outputs to render",
          description:
            "Type the @ character to select the outputs to combine. Optionally include style and layout guidlines if using Rendering mode of Markdown or HTML.",
        },
        "p-render-mode": {
          type: "string",
          enum: modes,
          title: "Display format",
          behavior: ["config", "hint-preview", "reactive", "hint-controller"],
          default: MANUAL_MODE,
          description: "Choose how to combine and display the outputs",
        },
        ...advancedSettings(renderType, slideDeckMode),
        ...template.schemas(),
      },
      behavior: ["at-wireable"],
      ...template.requireds(),
    } satisfies Schema,
    outputSchema: {
      type: "object",
      properties: {
        context: {
          type: "array",
          items: {
            type: "object",
            behavior: ["llm-content"],
          },
          title: "Context out",
          behavior: ["main-port", "hint-multimodal"],
        },
      },
    } satisfies Schema,
    title: "Output",
    metadata: {
      icon: icon,
      tags: ["quick-access", "core", "output"],
      order: 100,
    },
  };
}
