{
  "title": "Specialist",
  "description": "All-in-one worker. A work in progress, incorporates all the learnings from making previous workers.",
  "$schema": "https://raw.githubusercontent.com/breadboard-ai/breadboard/@google-labs/breadboard-schema@1.4.1/packages/schema/breadboard.schema.json",
  "edges": [
    {
      "from": "fn-10",
      "to": "output-2",
      "out": "context",
      "in": "out"
    },
    {
      "from": "fn-5",
      "to": "text-6",
      "out": "context",
      "in": "context"
    },
    {
      "from": "fn-5",
      "to": "fn-10",
      "out": "context",
      "in": "context"
    },
    {
      "from": "router",
      "to": "assembleBoardInvoke",
      "out": "context",
      "in": "context"
    },
    {
      "from": "router",
      "to": "assembleBoardInvoke",
      "out": "functionCall",
      "in": "functionCall"
    },
    {
      "from": "router",
      "to": "fn-10",
      "out": "context",
      "in": "generated"
    },
    {
      "from": "router",
      "to": "fn-10",
      "out": "text",
      "in": "text"
    },
    {
      "from": "fn-3",
      "to": "fn-5",
      "out": "context",
      "in": "context"
    },
    {
      "from": "fn-3",
      "to": "fn-8",
      "out": "context",
      "in": "context"
    },
    {
      "from": "fn-4",
      "to": "fn-5",
      "out": "progress",
      "in": "progress"
    },
    {
      "from": "text-6",
      "to": "router",
      "out": "context",
      "in": "context"
    },
    {
      "from": "assembleBoardInvoke",
      "to": "invokeBoard",
      "out": "*",
      "in": ""
    },
    {
      "from": "input-1",
      "to": "fn-3",
      "out": "in",
      "in": "context"
    },
    {
      "from": "input-1",
      "to": "fn-3",
      "out": "task",
      "in": "toAdd"
    },
    {
      "from": "input-1",
      "to": "fn-4",
      "out": "in",
      "in": "context"
    },
    {
      "from": "input-1",
      "to": "turnBoardsToFunctions",
      "out": "tools",
      "in": "list"
    },
    {
      "from": "input-1",
      "to": "text-6",
      "out": "persona",
      "in": "systemInstruction"
    },
    {
      "from": "fn-8",
      "to": "output-9",
      "out": "context",
      "in": "out"
    },
    {
      "from": "formatFunctionDeclarations",
      "to": "text-6",
      "out": "tools",
      "in": "tools"
    },
    {
      "from": "formatFunctionDeclarations",
      "to": "assembleBoardInvoke",
      "out": "urlMap",
      "in": "urlMap"
    },
    {
      "from": "invokeBoard",
      "to": "fn-7",
      "out": "*",
      "in": ""
    },
    {
      "from": "turnBoardsToFunctions",
      "to": "formatFunctionDeclarations",
      "out": "list",
      "in": "list"
    },
    {
      "from": "fn-7",
      "to": "fn-8",
      "out": "response",
      "in": "toAdd"
    }
  ],
  "nodes": [
    {
      "id": "output-2",
      "type": "output",
      "configuration": {
        "schema": {
          "type": "object",
          "properties": {
            "out": {
              "title": "Context out",
              "type": "string"
            }
          }
        }
      }
    },
    {
      "id": "fn-10",
      "type": "runJavascript",
      "configuration": {
        "code": "const fn_10 = ({ context: context2, generated }) => {\n  if (!context2) throw new Error(\"Context is required\");\n  if (!generated) throw new Error(\"Generated is required\");\n  const c = context2;\n  const g = generated;\n  let doneMarker = null;\n  for (let i = 0; i < c.length; ++i) {\n    const item = c[i];\n    if (item.role === \"$metadata\") {\n      const plan = item.data;\n      if (plan.doneMarker) {\n        doneMarker = plan.doneMarker;\n        break;\n      }\n    }\n  }\n  if (!doneMarker) {\n    return { context: [...c, g] };\n  }\n  let containsMarkers = false;\n  for (let i = 0; i < g.parts.length; ++i) {\n    const part = g.parts[i];\n    if (\"text\" in part && part.text.includes(doneMarker)) {\n      containsMarkers = true;\n      part.text = part.text.replaceAll(doneMarker, \"\").trim();\n      break;\n    }\n  }\n  if (!containsMarkers) {\n    return { context: [...c, g] };\n  }\n  const metadata5 = {\n    role: \"$metadata\",\n    data: {\n      type: \"looper\",\n      done: true\n    }\n  };\n  return { context: [...c, g, metadata5] };\n};",
        "name": "fn_10",
        "raw": true
      },
      "metadata": {
        "title": "Done Check",
        "description": "Checking for the 'Done' marker"
      }
    },
    {
      "id": "fn-5",
      "type": "runJavascript",
      "configuration": {
        "code": "const fn_5 = ({ context: context2, progress }) => {\n  const contents = Array.isArray(context2) ? context2 : [context2];\n  const plans = Array.isArray(progress) ? progress : [progress];\n  const last = plans[0];\n  if (!last || !last.next) {\n    return { context: context2 };\n  }\n  contents.push({ role: \"user\", parts: [{ text: last.next }] });\n  return { context: contents };\n};",
        "name": "fn_5",
        "raw": true
      },
      "metadata": {
        "title": "Add Looper Task",
        "description": "If there is a pending Looper task, add it."
      }
    },
    {
      "id": "router",
      "type": "runJavascript",
      "configuration": {
        "code": "const router = ({ context: context2 }) => {\n  if (!context2) throw new Error(\"Context is a required input\");\n  const item = context2;\n  const part = item.parts[0];\n  console.warn(\n    item.parts.length === 1,\n    \"Only one part is expected in Gemini response\"\n  );\n  if (\"text\" in part) {\n    return { context: context2, text: part.text };\n  }\n  return { context: context2, functionCall: part.functionCall };\n};",
        "name": "router",
        "raw": true
      },
      "metadata": {
        "title": "Router",
        "description": "Routing to either function call invocation or text reply"
      }
    },
    {
      "id": "fn-3",
      "type": "runJavascript",
      "configuration": {
        "code": "const fn_3 = ({ context: context2, toAdd }) => {\n  if (!context2) throw new Error(\"Context is required\");\n  const existing = Array.isArray(context2) ? context2 : [context2];\n  const incoming = structuredClone(toAdd);\n  if (!incoming.parts) {\n    const containsUserRole = existing.filter(\n      (item) => item.role !== \"model\" && item.role !== \"$metadata\"\n    ).length > 0;\n    if (!containsUserRole) {\n      return {\n        context: [\n          ...existing,\n          { role: \"user\", parts: [{ text: \"Do your magic\" }] }\n        ]\n      };\n    }\n    return { context: existing };\n  }\n  if (!incoming.role) {\n    incoming.role = \"user\";\n  }\n  const last = existing[existing.length - 1];\n  if (!last) {\n    return { context: [incoming] };\n  }\n  if (last.role !== incoming.role) {\n    return { context: [...existing, incoming] };\n  } else {\n    const result = structuredClone(existing);\n    const index = result.length - 1;\n    result[index].parts.push(...incoming.parts);\n    return { context: result };\n  }\n};",
        "name": "fn_3",
        "raw": true
      },
      "metadata": {
        "title": "Add Task",
        "description": "Adding task to the prompt."
      }
    },
    {
      "id": "fn-4",
      "type": "runJavascript",
      "configuration": {
        "code": "const fn_4 = ({ context: context2, forkOutputs }) => {\n  const fork = forkOutputs;\n  const existing = Array.isArray(context2) ? context2 : [context2];\n  const progress = [];\n  for (let i = existing.length - 1; i >= 0; i--) {\n    const item = existing[i];\n    if (item.role === \"$metadata\") {\n      progress.push(item.data);\n    }\n  }\n  if (fork) {\n    if (progress.length) {\n      return { progress };\n    } else {\n      return { context: context2 };\n    }\n  } else {\n    return { context: context2, progress };\n  }\n};",
        "name": "fn_4",
        "raw": true
      },
      "metadata": {
        "title": "Read Progress so far"
      }
    },
    {
      "id": "text-6",
      "type": "text",
      "configuration": {},
      "metadata": {
        "title": "Gemini API Call",
        "description": "Applying Gemini to do work"
      }
    },
    {
      "id": "assembleBoardInvoke",
      "type": "runJavascript",
      "configuration": {
        "code": "const assembleBoardInvoke = ({ functionCall, urlMap }) => {\n  if (!functionCall) throw new Error(\"Function call is a required input\");\n  if (!urlMap) throw new Error(\"URL map is a required input\");\n  const call = functionCall;\n  const $board = urlMap[call.name];\n  const generator = \"https://raw.githubusercontent.com/breadboard-ai/breadboard/05136f811e443dd931a2a2a40ff5a3f388d5ce75/packages/breadboard-web/public/graphs/gemini-generator.json\";\n  return { $board, generator, ...call.args };\n};",
        "name": "assembleBoardInvoke",
        "raw": true
      },
      "metadata": {
        "title": "Assemble Tool Invoke",
        "description": "Assembling the tool invocation based on Gemini response"
      }
    },
    {
      "id": "input-1",
      "type": "input",
      "configuration": {
        "schema": {
          "type": "object",
          "properties": {
            "in": {
              "title": "Context in",
              "description": "The source material for the worker",
              "type": "array",
              "items": {
                "type": "object",
                "behavior": [
                  "llm-content"
                ]
              },
              "examples": [
                "[\n  {\n    \"role\": \"user\",\n    \"parts\": [\n      {\n        \"text\": \"\\nbook description: This book will be about breadboards and how awesome they are\\nchapter target: 10\\npage target: 400\\nfiction genre: space opera\\nsetting: the planet where there are no breadboards\\nstory arc: A girl named Aurora invents a breadboard on the planet where breadboards are strictly forbidden. Through struggles and determination, and with the help of trusted friends, Aurora overcomes many challenges and changes the whole planet for the better. \\ntonality: futuristic struggle, but optimistic\\nworking title: Aurora\\n\"\n      }\n    ]\n  }\n]"
              ]
            },
            "task": {
              "title": "Task",
              "description": "Optional. Give it a task to perform on the provided source materials. The ideal task is a call to action with the necessary details on how to best complete this action.",
              "type": "object",
              "default": "{}",
              "behavior": [
                "llm-content",
                "config"
              ],
              "examples": [
                "{\n  \"parts\": [\n    {\n      \"text\": \"\\nWrite an outline for a novel, following the provided specs.\\n\"\n    }\n  ]\n}"
              ]
            },
            "tools": {
              "title": "Tools",
              "type": "array",
              "description": "Optional. Equip it with tools by adding them to this list. If specified, the worker will invoke them when the job calls for it.",
              "items": {
                "type": "object",
                "behavior": [
                  "board",
                  "config"
                ]
              },
              "default": "[]"
            },
            "persona": {
              "type": "object",
              "title": "Persona",
              "description": "Describe the worker persona: the skills and various capabilities, the mindset, the thinking process, etc.",
              "default": "",
              "examples": [
                "{\n  \"parts\": [\n    {\n      \"text\": \"\\nYou are a famous author.  You are writing a novel.\\n\\nYour well-established process starts with collecting the book description, chapter target, page target, fiction genre, setting, story arc, tonality and the working title.\\n\\nThen, your first step is to write a detailed outline for the novel.  You keep the page target in mind for the finished novel, so your outline typically contains contain key bullets for the story arc across the chapters. You usually create a part of the outline for each chapter. You also keep in mind that the outline must cover at least the target number of chapters.\\n\\nYou are very creative and you pride yourself in adding interesting twists and unexpected turns of the story, something that keeps the reader glued to your book.\\n\"\n    }\n  ]\n}"
              ],
              "behavior": [
                "llm-content",
                "config"
              ]
            }
          },
          "required": [
            "in",
            "persona"
          ]
        }
      }
    },
    {
      "id": "fn-8",
      "type": "runJavascript",
      "configuration": {
        "code": "const fn_8 = ({ context: context2, toAdd }) => {\n  if (!context2) throw new Error(\"Context is required\");\n  const existing = Array.isArray(context2) ? context2 : [context2];\n  const incoming = structuredClone(toAdd);\n  if (!incoming.parts) {\n    const containsUserRole = existing.filter(\n      (item) => item.role !== \"model\" && item.role !== \"$metadata\"\n    ).length > 0;\n    if (!containsUserRole) {\n      return {\n        context: [\n          ...existing,\n          { role: \"user\", parts: [{ text: \"Do your magic\" }] }\n        ]\n      };\n    }\n    return { context: existing };\n  }\n  if (!incoming.role) {\n    incoming.role = \"user\";\n  }\n  const last = existing[existing.length - 1];\n  if (!last) {\n    return { context: [incoming] };\n  }\n  if (last.role !== incoming.role) {\n    return { context: [...existing, incoming] };\n  } else {\n    const result = structuredClone(existing);\n    const index = result.length - 1;\n    result[index].parts.push(...incoming.parts);\n    return { context: result };\n  }\n};",
        "name": "fn_8",
        "raw": true
      },
      "metadata": {
        "title": "Add Tool Response",
        "description": "Adding tool response to context"
      }
    },
    {
      "id": "formatFunctionDeclarations",
      "type": "runJavascript",
      "configuration": {
        "code": "const formatFunctionDeclarations = ({ list }) => {\n  const tools2 = [];\n  const urlMap = {};\n  list.forEach((item) => {\n    tools2.push(item.function);\n    urlMap[item.function.name] = item.boardURL;\n  });\n  return { tools: tools2, urlMap };\n};",
        "name": "formatFunctionDeclarations",
        "raw": true
      },
      "metadata": {
        "title": "Format Function Declarations",
        "description": "Formatting the function declarations"
      }
    },
    {
      "id": "invokeBoard",
      "type": "invoke",
      "configuration": {},
      "metadata": {
        "title": "Invoke Tool",
        "description": "Invoking the board"
      }
    },
    {
      "id": "turnBoardsToFunctions",
      "type": "map",
      "configuration": {
        "board": "#boardToFunction"
      },
      "metadata": {
        "title": "Turn Boards into Functions",
        "description": "Turning provided boards into functions"
      }
    },
    {
      "id": "fn-7",
      "type": "runJavascript",
      "configuration": {
        "code": "const fn_7 = (inputs) => {\n  for (const key in inputs) {\n    const input2 = inputs[key];\n    if (\"content\" in input2) {\n      const content = input2.content;\n      if (content.parts && Array.isArray(content.parts)) {\n        content.role = \"tool\";\n        return { response: content };\n      }\n    }\n  }\n  const text2 = JSON.stringify(inputs);\n  return { response: { parts: [{ text: text2 }], role: \"tool\" } };\n};",
        "name": "fn_7",
        "raw": true
      },
      "metadata": {
        "title": "Format Tool Response",
        "description": "Formatting tool response"
      }
    },
    {
      "id": "output-9",
      "type": "output",
      "configuration": {
        "schema": {
          "type": "object",
          "properties": {
            "out": {
              "title": "Context out",
              "type": "string"
            }
          }
        }
      },
      "metadata": {
        "title": "Tool Output",
        "description": "Return tool results as output"
      }
    }
  ],
  "kits": [],
  "graphs": {
    "boardToFunction": {
      "title": "Board to functions",
      "description": "Use this board to convert specified boards into function-calling signatures",
      "edges": [
        {
          "from": "getFunctionSignature",
          "to": "output-2",
          "out": "function",
          "in": "function"
        },
        {
          "from": "input-1",
          "to": "curry-3",
          "out": "item",
          "in": "$board"
        },
        {
          "from": "input-1",
          "to": "output-2",
          "out": "item",
          "in": "boardURL"
        },
        {
          "from": "curry-3",
          "to": "getFunctionSignature",
          "out": "board",
          "in": "json"
        }
      ],
      "nodes": [
        {
          "id": "output-2",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "function": {
                  "type": [
                    "array",
                    "boolean",
                    "null",
                    "number",
                    "object",
                    "string"
                  ],
                  "title": "function"
                },
                "boardURL": {
                  "type": "string",
                  "title": "boardURL"
                }
              }
            }
          }
        },
        {
          "id": "getFunctionSignature",
          "type": "jsonata",
          "configuration": {
            "expression": "\n      (\n        $adjustType := function ($type) {\n            $type = \"object\" or $type = \"array\" ? \"string\" : $type\n        };\n\n        {\n        \"function\": {\n            \"name\": $replace(title, /\\W/, \"_\"),\n            \"description\": description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": nodes[type=\"input\"][0].configuration.schema.properties ~> $each(function($v, $k) {\n                { $k: {\n                    \"type\": $v.type ~> $adjustType,\n                    \"description\": $v.description\n                } }\n                }) ~> $merge\n            }\n        },\n        \"returns\": nodes[type=\"output\"][0].configuration.schema ~> | ** | {}, 'title' |\n        }\n    )",
            "raw": true
          }
        },
        {
          "id": "input-1",
          "type": "input",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "item": {
                  "title": "board",
                  "behavior": [
                    "board"
                  ],
                  "description": "The board to curry. Can be a BoardCapability, a graph or a URL",
                  "type": "string"
                }
              },
              "required": [
                "item"
              ]
            }
          }
        },
        {
          "id": "curry-3",
          "type": "curry",
          "configuration": {}
        }
      ],
      "graphs": {}
    }
  }
}