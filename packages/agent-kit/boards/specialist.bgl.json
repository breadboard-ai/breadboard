{
  "title": "Specialist",
  "metadata": {
    "icon": "smart-toy",
    "help": {
      "url": "https://breadboard-ai.github.io/breadboard/docs/kits/agents/#specialist"
    }
  },
  "description": "Given instructions on how to act, performs a single task, optionally invoking tools.",
  "edges": [
    {
      "from": "fn-15",
      "to": "output-2",
      "out": "context",
      "in": "out"
    },
    {
      "from": "fn-7",
      "to": "fn-8",
      "out": "context",
      "in": "context"
    },
    {
      "from": "fn-7",
      "to": "text-10",
      "out": "context",
      "in": "context"
    },
    {
      "from": "fn-7",
      "to": "fn-15",
      "out": "context",
      "in": "context"
    },
    {
      "from": "router",
      "to": "assembleBoardInvoke",
      "out": "context",
      "in": "context"
    },
    {
      "from": "router",
      "to": "assembleBoardInvoke",
      "out": "functionCalls",
      "in": "functionCalls"
    },
    {
      "from": "router",
      "to": "fn-15",
      "out": "context",
      "in": "generated"
    },
    {
      "from": "router",
      "to": "fn-15",
      "out": "text",
      "in": "text"
    },
    {
      "from": "fn-5",
      "to": "fn-7",
      "out": "context",
      "in": "context"
    },
    {
      "from": "fn-6",
      "to": "fn-7",
      "out": "progress",
      "in": "progress"
    },
    {
      "from": "fn-8",
      "to": "curry-9",
      "out": "context",
      "in": "context"
    },
    {
      "from": "fn-8",
      "to": "fn-12",
      "out": "context",
      "in": "context"
    },
    {
      "from": "text-10",
      "to": "router",
      "out": "context",
      "in": "context"
    },
    {
      "from": "assembleBoardInvoke",
      "to": "map-11",
      "out": "list",
      "in": "list"
    },
    {
      "from": "input-1",
      "to": "fn-5",
      "out": "in",
      "in": "context"
    },
    {
      "from": "input-1",
      "to": "fn-5",
      "out": "task",
      "in": "toAdd"
    },
    {
      "from": "input-1",
      "to": "fn-6",
      "out": "in",
      "in": "context"
    },
    {
      "from": "input-1",
      "to": "text-10",
      "out": "persona",
      "in": "systemInstruction"
    },
    {
      "from": "curry-9",
      "to": "turnBoardsToFunctions",
      "out": "board",
      "in": "board"
    },
    {
      "from": "fn-12",
      "to": "fn-13",
      "out": "*",
      "in": ""
    },
    {
      "from": "formatFunctionDeclarations",
      "to": "text-10",
      "out": "tools",
      "in": "tools"
    },
    {
      "from": "formatFunctionDeclarations",
      "to": "assembleBoardInvoke",
      "out": "urlMap",
      "in": "urlMap"
    },
    {
      "from": "input-4",
      "to": "text-10",
      "out": "model",
      "in": "model"
    },
    {
      "from": "map-11",
      "to": "fn-12",
      "out": "list",
      "in": "response"
    },
    {
      "from": "turnBoardsToFunctions",
      "to": "formatFunctionDeclarations",
      "out": "list",
      "in": "list"
    },
    {
      "from": "fn-13",
      "to": "output-14",
      "out": "context",
      "in": "out"
    },
    {
      "from": "input-3",
      "to": "turnBoardsToFunctions",
      "out": "tools",
      "in": "list"
    }
  ],
  "nodes": [
    {
      "id": "output-2",
      "type": "output",
      "configuration": {
        "schema": {
          "type": "object",
          "properties": {
            "out": {
              "title": "Context out",
              "type": "array",
              "items": {
                "type": "object",
                "behavior": [
                  "llm-content"
                ]
              }
            }
          }
        }
      }
    },
    {
      "id": "fn-15",
      "type": "runJavascript",
      "configuration": {
        "code": "const fn_15 = ({context,generated})=>{if(!context)throw new Error(\"Context is required\");if(!generated)throw new Error(\"Generated is required\");const c=context;const g=generated;let doneMarker=null;for(let i=0;i<c.length;++i){const item=c[i];if(item.role===\"$metadata\"&&item.type===\"looper\"){const plan=item.data;if(plan.doneMarker){doneMarker=plan.doneMarker;break}}}if(!doneMarker){return{context:[...c,g]}}let containsMarkers=false;for(let i=0;i<g.parts.length;++i){const part=g.parts[i];if(\"text\"in part&&part.text.includes(doneMarker)){containsMarkers=true;part.text=part.text.replaceAll(doneMarker,\"\").trim();break}}if(!containsMarkers){return{context:[...c,g]}}const metadata={role:\"$metadata\",type:\"looper\",data:{done:true}};return{context:[...c,g,metadata]}};",
        "name": "fn_15",
        "raw": true
      },
      "metadata": {
        "title": "Done Check",
        "description": "Checking for the 'Done' marker"
      }
    },
    {
      "id": "fn-7",
      "type": "runJavascript",
      "configuration": {
        "code": "const fn_7 = ({context,progress})=>{const contents=Array.isArray(context)?context:[context];const plans=Array.isArray(progress)?progress:[progress];const last=plans[0];if(!last||!last.next){return{context}}const lastLooperMarker=contents.findLastIndex(item=>item.role===\"$metadata\"&&item.type===\"looper\");if(lastLooperMarker>=0){const pastLooper=contents.slice(lastLooperMarker);const hasModel=pastLooper.some(item=>item.role===\"model\");if(hasModel){return{context:contents}}}contents.push({role:\"user\",parts:[{text:last.next}]});return{context:contents}};",
        "name": "fn_7",
        "raw": true
      },
      "metadata": {
        "title": "Add Looper Task",
        "description": "If there is a pending Looper task, add it."
      }
    },
    {
      "id": "router",
      "type": "runJavascript",
      "configuration": {
        "code": "const router = ({context})=>{if(!context)throw new Error(\"Context is a required input\");const item=context;const functionCallParts=item.parts.filter(part=>\"functionCall\"in part).map(part=>part.functionCall);if(functionCallParts.length===0){const textPart=item.parts.find(part=>\"text\"in part);if(!textPart)throw new Error(\"No text or function call found in context\");return{context,text:textPart.text}}return{context,functionCalls:functionCallParts}};",
        "name": "router",
        "raw": true
      },
      "metadata": {
        "title": "Router",
        "description": "Routing to either function call invocation or text reply"
      }
    },
    {
      "id": "fn-5",
      "type": "runJavascript",
      "configuration": {
        "code": "const fn_5 = ({context,toAdd})=>{if(!context)throw new Error(\"Context is required\");const existing=Array.isArray(context)?context:[context];const incoming=toAdd;if(!incoming.parts){const containsUserRole=existing.filter(item=>item.role!==\"model\"&&item.role!==\"$metadata\").length>0;if(!containsUserRole){return{context:[...existing,{role:\"user\",parts:[{text:\"Do your magic\"}]}]}}return{context:existing}}if(!incoming.role){incoming.role=\"user\"}const last=existing[existing.length-1];if(!last){return{context:[incoming]}}if(last.role!==incoming.role){return{context:[...existing,incoming]}}else{const result=structuredClone(existing);const index=result.length-1;result[index].parts.push(...incoming.parts);return{context:result}}};",
        "name": "fn_5",
        "raw": true
      },
      "metadata": {
        "title": "Add Task",
        "description": "Adding task to the prompt."
      }
    },
    {
      "id": "fn-6",
      "type": "runJavascript",
      "configuration": {
        "code": "const fn_6 = ({context,forkOutputs})=>{const fork=forkOutputs;const existing=Array.isArray(context)?context:[context];const progress=[];for(let i=existing.length-1;i>=0;i--){const item=existing[i];if(item.role===\"$metadata\"&&item.type===\"looper\"){progress.push(item.data)}}if(fork){if(progress.length){return{progress}}else{return{context}}}else{return{context,progress}}};",
        "name": "fn_6",
        "raw": true
      },
      "metadata": {
        "title": "Read Progress so far"
      }
    },
    {
      "id": "fn-8",
      "type": "runJavascript",
      "configuration": {
        "code": "const fn_8 = ({context})=>{if(!context)throw new Error(\"Context is required\");const c=context;const id=Math.random().toString(36).substring(7);const metadata={role:\"$metadata\",type:\"split\",data:{type:\"start\",id}};return{context:[...c,metadata],id}};",
        "name": "fn_8",
        "raw": true
      },
      "metadata": {
        "title": "Add Split Start",
        "description": "Marking the start of parallel processing in the context"
      }
    },
    {
      "id": "text-10",
      "type": "text",
      "configuration": {},
      "metadata": {
        "title": "Gemini API Call",
        "description": "Applying Gemini to do work"
      }
    },
    {
      "id": "assembleBoardInvoke",
      "type": "runJavascript",
      "configuration": {
        "code": "const assembleBoardInvoke = ({functionCalls,urlMap})=>{if(!functionCalls){throw new Error(\"Function call array is a required input\")}if(!urlMap){throw new Error(\"URL map is a required input\")}const calls=functionCalls;if(calls.length===0){throw new Error(\"Function call array must not be empty.\")}const list=[];for(const call of calls){const item=urlMap[call.name];const $board=item.url;const $flags=item.flags;const llmContentProperty=$flags.inputLLMContent||$flags.inputLLMContentArray;const invokeArgs={$board,$flags,...call.args};if(llmContentProperty){const args=call.args;const text=args[llmContentProperty];const parts=[{text}];const llmContent={parts,role:\"user\"};if($flags.inputLLMContentArray){invokeArgs[llmContentProperty]=[llmContent]}else{invokeArgs[llmContentProperty]=llmContent}}list.push(invokeArgs)}return{list}};",
        "name": "assembleBoardInvoke",
        "raw": true
      },
      "metadata": {
        "title": "Assemble Tool Invoke",
        "description": "Assembling the tool invocation based on Gemini response"
      }
    },
    {
      "id": "input-1",
      "type": "input",
      "configuration": {
        "schema": {
          "type": "object",
          "properties": {
            "in": {
              "title": "Context in",
              "description": "Incoming conversation context",
              "type": "array",
              "items": {
                "type": "object",
                "behavior": [
                  "llm-content"
                ]
              }
            },
            "task": {
              "title": "Task",
              "description": "(Optional) Provide a specific task with clear instructions for the worker to complete using the conversation context",
              "type": "object",
              "default": "{}",
              "behavior": [
                "llm-content",
                "config"
              ]
            },
            "persona": {
              "type": "object",
              "behavior": [
                "llm-content",
                "config"
              ],
              "title": "Persona",
              "description": "Describe the worker's skills, capabilities, mindset, and thinking process",
              "default": ""
            }
          },
          "required": [
            "in",
            "persona"
          ]
        }
      }
    },
    {
      "id": "curry-9",
      "type": "curry",
      "configuration": {
        "$board": "#boardToFunction"
      },
      "metadata": {
        "title": "Add Context",
        "description": "Adding context to the board to function converter"
      }
    },
    {
      "id": "fn-12",
      "type": "runJavascript",
      "configuration": {
        "code": "const fn_12 = ({response,context})=>{const r=response;const c=context;const result=Object.fromEntries(r.map((item,i)=>[`context-${i+1}`,item.item]));if(c){result[\"context-0\"]=c}return result};",
        "name": "fn_12",
        "raw": true
      },
      "metadata": {
        "title": "Format Tool Response",
        "description": "Formatting tool response"
      }
    },
    {
      "id": "formatFunctionDeclarations",
      "type": "runJavascript",
      "configuration": {
        "code": "const formatFunctionDeclarations = ({list})=>{const tools=[];const urlMap={};list.forEach(item=>{tools.push(item.function);const flags=item.flags;urlMap[item.function.name]={url:item.boardURL,flags}});return{tools,urlMap}};",
        "name": "formatFunctionDeclarations",
        "raw": true
      },
      "metadata": {
        "title": "Format Function Declarations",
        "description": "Formatting the function declarations"
      }
    },
    {
      "id": "input-4",
      "type": "input",
      "configuration": {
        "schema": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string",
              "title": "Model",
              "description": "Choose the model to use for this specialist.",
              "enum": [
                "gemini-1.5-flash-latest",
                "gemini-1.5-pro-latest",
                "gemini-1.5-pro-exp-0801",
                "gemini-1.5-pro-exp-0827",
                "gemini-1.5-flash-8b-exp-0827",
                "gemini-1.5-pro-exp-0827"
              ],
              "default": "gemini-1.5-flash-latest",
              "examples": [
                "gemini-1.5-flash-latest"
              ],
              "behavior": [
                "config"
              ]
            }
          }
        }
      },
      "metadata": {
        "title": "Model Input",
        "description": "Ask which model to use"
      }
    },
    {
      "id": "map-11",
      "type": "map",
      "configuration": {
        "board": "#invokeBoardWithArgs"
      },
      "metadata": {
        "title": "Invoke Tools in Parallel",
        "description": "Invoking tools in parallel"
      }
    },
    {
      "id": "turnBoardsToFunctions",
      "type": "map",
      "configuration": {},
      "metadata": {
        "title": "Turn Boards into Functions",
        "description": "Turning provided boards into functions"
      }
    },
    {
      "id": "fn-13",
      "type": "runJavascript",
      "configuration": {
        "code": "const fn_13 = ({merge,...inputs})=>{const entries=Object.entries(inputs).sort();if(merge){const context=[];const parts=[];for(const[,input]of entries){const c=asContextArray(input);let lastIndex=c.length-1;let last;do{last=c[lastIndex--]}while(lastIndex>=0&&last.role===\"$metadata\");if(last){parts.push(...last.parts)}}context.push({parts,role:\"user\"});return{context}}else{let mode;const[f,...rest]=entries;if(!f){return{context:[]}}const first=asContextArray(f[1]);const firstOpenSplits=scanForSplits(first);const preambleIndices=[];for(const[,input]of rest){const c=asContextArray(input);const hasOpenSplits=scanForSplits(c);if(hasOpenSplits){preambleIndices.push(hasOpenSplits[1])}}if(!firstOpenSplits){if(preambleIndices.length===0){mode=\"simple\"}else{mode=\"adhoc\"}}else{const preamblesMatch=preambleIndices.length>0&&preambleIndices.every(value=>value===firstOpenSplits[1]);if(preamblesMatch){mode=\"preamble\"}else{if(firstOpenSplits[1]===first.length-1){mode=\"single\"}else{mode=\"adhoc\"}}}const context=[];if(mode===\"adhoc\"){for(const[,input]of entries){const c=asContextArray(input);context.push(...c)}return{context}}else if(mode===\"simple\"){const splitId=Math.random().toString(36).substring(7);context.push({role:\"$metadata\",type:\"split\",data:{type:\"start\",id:splitId}});for(const[,input]of entries){const c=asContextArray(input);context.push(...c);context.push({role:\"$metadata\",type:\"split\",data:{type:\"next\",id:splitId}})}}else if(mode===\"preamble\"){const preambleIndex=firstOpenSplits?.[1]||0;const preamble=entries[0][1].slice(0,preambleIndex+1);context.push(...preamble);const splitId=preamble[preamble.length-1].data.id;for(const[,input]of entries){let c=asContextArray(input);if(preambleIndex>=0){c=c.slice(preambleIndex+1)}if(c.length){context.push(...c);context.push({role:\"$metadata\",type:\"split\",data:{type:\"next\",id:splitId}})}}}else if(mode===\"single\"){const splitId=first[first.length-1].data.id;context.push(...first);for(const[,input]of rest){const c=asContextArray(input);context.push(...c);context.push({role:\"$metadata\",type:\"split\",data:{type:\"next\",id:splitId}})}}const last=context[context.length-1];last.data.type=\"end\";return{context}}function asContextArray(input){return Array.isArray(input)?input:[input]}__name(asContextArray,\"asContextArray\");function scanForSplits(c){const stack=[];for(const[i,item]of c.entries()){if(item.role!==\"$metadata\")continue;if(item.type!==\"split\")continue;if(item.data.type===\"start\"){stack.push([item.data.id,i])}if(item.data.type===\"end\"){const[id]=stack.pop()||[];if(id!==item.data.id){console.warn(\"Split integrity error: mismatched split start/end markers. Start:\",id,\"End:\",item.data.id);return null}}}return stack.pop()||null}__name(scanForSplits,\"scanForSplits\")};",
        "name": "fn_13",
        "raw": true
      },
      "metadata": {
        "title": "Add Tool Response",
        "description": "Adding tool response to context"
      }
    },
    {
      "id": "input-3",
      "type": "input",
      "configuration": {
        "schema": {
          "type": "object",
          "properties": {
            "tools": {
              "title": "Tools",
              "description": "(Optional) Add tools to this list for the worker to use when needed",
              "type": "array",
              "items": {
                "type": "object",
                "behavior": [
                  "board"
                ]
              },
              "behavior": [
                "config"
              ],
              "default": "[]"
            }
          }
        }
      },
      "metadata": {
        "title": "Tools Input",
        "description": "Specify the tools to use"
      }
    },
    {
      "id": "output-14",
      "type": "output",
      "configuration": {
        "schema": {
          "type": "object",
          "properties": {
            "out": {
              "title": "Context out",
              "type": "array",
              "items": {
                "type": "object",
                "behavior": [
                  "llm-content"
                ]
              }
            }
          }
        }
      },
      "metadata": {
        "title": "Tool Output",
        "description": "Return tool results as output"
      }
    }
  ],
  "graphs": {
    "boardToFunction": {
      "title": "Board to functions",
      "description": "Use this board to convert specified boards into function-calling signatures",
      "edges": [
        {
          "from": "fn-4",
          "to": "output-2",
          "out": "function",
          "in": "function"
        },
        {
          "from": "fn-4",
          "to": "output-2",
          "out": "board",
          "in": "boardURL"
        },
        {
          "from": "fn-4",
          "to": "output-2",
          "out": "flags",
          "in": "flags"
        },
        {
          "from": "curry-3",
          "to": "fn-4",
          "out": "board",
          "in": "board"
        },
        {
          "from": "input-1",
          "to": "curry-3",
          "out": "item",
          "in": "$board"
        },
        {
          "from": "input-1",
          "to": "curry-3",
          "out": "context",
          "in": "context"
        }
      ],
      "nodes": [
        {
          "id": "output-2",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "function": {
                  "type": "string",
                  "title": "function"
                },
                "boardURL": {
                  "type": "string",
                  "title": "boardURL"
                },
                "flags": {
                  "type": "string",
                  "title": "flags"
                }
              }
            }
          }
        },
        {
          "id": "fn-4",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_4 = ({board:board2})=>{const b=board2;const inputs=b.nodes.filter(node=>node.type===\"input\")||[];const outputs=b.nodes.filter(node=>node.type===\"output\");if(outputs.length===0){throw new Error(\"No outputs found\")}const inputSchema=inputs[0]?.configuration?.schema||{};const outputSchema=outputs[0].configuration?.schema;if(!outputSchema){throw new Error(\"No output schema found\")}const properties={};const flags={};for(const key in inputSchema.properties){const property=inputSchema.properties[key];const isObject=property.type===\"object\";const isArray=property.type===\"array\";const type=isObject||isArray?\"string\":property.type;if(isObject&&property.behavior?.includes(\"llm-content\")){flags.inputLLMContent=key}else if(isArray&&property.items?.behavior?.includes(\"llm-content\")){flags.inputLLMContentArray=key;continue}const description2=property.description||property.title||\"text\";properties[key]={type,description:description2}}if(flags.inputLLMContentArray){if(flags.inputLLMContentArray!==\"context\"){const c=b.args?.context;if(c){b.args??={};b.args[flags.inputLLMContentArray]=c;delete b.args.context}}}else{delete b.args?.context}for(const key in outputSchema.properties){const property=outputSchema.properties[key];const isObject=property.type===\"object\";const isArray=property.type===\"array\";if(isObject&&property.behavior?.includes(\"llm-content\")){flags.outputLLMContent=key}else if(isArray&&property.items?.behavior?.includes(\"llm-content\")){flags.outputLLMContentArray=key}}const name=b.title?.replace(/\\W/g,\"_\")||\"function\";const description=b.description;const parameters=Object.entries(properties).length>0?{type:\"object\",properties}:void 0;const f={name,description};if(parameters){f.parameters=parameters}return{function:f,returns:outputSchema,flags,board:board2}};",
            "name": "fn_4",
            "raw": true
          },
          "metadata": {
            "title": "Get Function Signature from board"
          }
        },
        {
          "id": "curry-3",
          "type": "curry",
          "configuration": {}
        },
        {
          "id": "input-1",
          "type": "input",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "item": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "object",
                      "properties": {},
                      "required": [],
                      "additionalProperties": true
                    }
                  ],
                  "title": "Board",
                  "description": "The board to curry. Can be a BoardCapability, a graph or a URL",
                  "behavior": [
                    "board"
                  ],
                  "type": "string"
                },
                "context": {
                  "type": "string",
                  "title": "context"
                }
              },
              "required": [
                "item",
                "context"
              ]
            }
          }
        }
      ],
      "graphs": {}
    },
    "invokeBoardWithArgs": {
      "title": "Invoke Board With Args",
      "description": "Takes one item of `boardInvocationAssembler` output and invokes it as a board with arguments.",
      "version": "0.0.1",
      "edges": [
        {
          "from": "fn-7",
          "to": "output-2",
          "out": "item",
          "in": "item"
        },
        {
          "from": "fn-6",
          "to": "fn-7",
          "out": "result",
          "in": "result"
        },
        {
          "from": "fn-4",
          "to": "fn-7",
          "out": "flags",
          "in": "flags"
        },
        {
          "from": "invoke-5",
          "to": "fn-6",
          "out": "*",
          "in": ""
        },
        {
          "from": "input-1",
          "to": "fn-3",
          "out": "item",
          "in": "item"
        },
        {
          "from": "input-1",
          "to": "fn-4",
          "out": "item",
          "in": "item"
        },
        {
          "from": "fn-3",
          "to": "invoke-5",
          "out": "*",
          "in": ""
        }
      ],
      "nodes": [
        {
          "id": "output-2",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "item": {
                  "type": "string",
                  "title": "item"
                }
              }
            }
          }
        },
        {
          "id": "fn-7",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_7 = ({result,flags})=>{let contentDetected=false;const inputs=result;const item=[];const f=flags;if(f){if(f.outputLLMContent){const content=inputs[f.outputLLMContent];content.role=\"tool\";item.push(content);contentDetected=true}else if(f.outputLLMContentArray){const contentArray=inputs[f.outputLLMContentArray];contentArray.forEach(content=>{if(content.role!==\"$metadata\"){content.role=\"tool\"}item.push(content)});contentDetected=true}}else{for(const key in inputs){const input=inputs[key];if(input!==null&&typeof input===\"object\"&&\"content\"in input){const content=input.content;if(content.parts&&Array.isArray(content.parts)){content.role=\"tool\";item.push(content);contentDetected=true}}}}if(!contentDetected){const text=JSON.stringify(inputs);item.push({parts:[{text}],role:\"tool\"})}return{item}};",
            "name": "fn_7",
            "raw": true
          },
          "metadata": {
            "title": "Format results",
            "description": "Formatting results"
          }
        },
        {
          "id": "fn-6",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_6 = result=>{return{result}};",
            "name": "fn_6",
            "raw": true
          },
          "metadata": {
            "title": "Pack results",
            "description": "Packing results"
          }
        },
        {
          "id": "fn-4",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_4 = ({item})=>{const{$flags}=item;return{flags:$flags}};",
            "name": "fn_4",
            "raw": true
          },
          "metadata": {
            "title": "Get flags",
            "description": "Getting flags for the board invocation"
          }
        },
        {
          "id": "invoke-5",
          "type": "invoke",
          "configuration": {},
          "metadata": {
            "title": "Invoke board",
            "description": "Invoking the board with unpacked arguments"
          }
        },
        {
          "id": "input-1",
          "type": "input",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "item": {
                  "type": "string",
                  "title": "item"
                }
              },
              "required": [
                "item"
              ]
            }
          }
        },
        {
          "id": "fn-3",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_3 = ({item})=>{const{$flags,...result}=item;return result};",
            "name": "fn_3",
            "raw": true
          },
          "metadata": {
            "title": "Unpack args",
            "description": "Unpacking board arguments"
          }
        }
      ],
      "graphs": {}
    }
  }
}