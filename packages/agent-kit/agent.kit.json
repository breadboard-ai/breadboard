{
  "title": "Agent Kit",
  "description": "A collection of nodes for building Agent-like experiences.",
  "version": "0.0.1",
  "url": "https://raw.githubusercontent.com/breadboard-ai/breadboard/main/packages/agent-kit/agent.kit.json",
  "nodes": {
    "human": {
      "title": "Human",
      "metadata": {
        "icon": "human"
      },
      "description": "A human in the loop. Use this node to insert a real person (user input) into your team of synthetic workers.",
      "version": "0.0.1",
      "edges": [
        {
          "from": "appendContext",
          "to": "output-2",
          "out": "context",
          "in": "context"
        },
        {
          "from": "input",
          "to": "appendContext",
          "out": "text",
          "in": "toAdd"
        },
        {
          "from": "input",
          "to": "output-2",
          "out": "text",
          "in": "text"
        },
        {
          "from": "fn-5",
          "to": "createSchema",
          "out": "input",
          "in": "context"
        },
        {
          "from": "fn-5",
          "to": "fn-6",
          "out": "choose",
          "in": "context"
        },
        {
          "from": "fn-5",
          "to": "fn-8",
          "out": "choose",
          "in": "context"
        },
        {
          "from": "fn-5",
          "to": "output",
          "out": "output",
          "in": "output"
        },
        {
          "from": "fn-5",
          "to": "appendContext",
          "out": "input",
          "in": "context"
        },
        {
          "from": "createSchema",
          "to": "input",
          "out": "schema",
          "in": "schema"
        },
        {
          "from": "fn-3",
          "to": "output-4",
          "out": "done",
          "in": "context"
        },
        {
          "from": "fn-3",
          "to": "fn-5",
          "out": "context",
          "in": "context"
        },
        {
          "from": "fn-6",
          "to": "input-7",
          "out": "schema",
          "in": "schema"
        },
        {
          "from": "fn-6",
          "to": "fn-8",
          "out": "total",
          "in": "total"
        },
        {
          "from": "fn-8",
          "to": "output-9",
          "out": "context",
          "in": "context"
        },
        {
          "from": "input-1",
          "to": "fn-3",
          "out": "context",
          "in": "context"
        },
        {
          "from": "input-1",
          "to": "createSchema",
          "out": "title",
          "in": "title"
        },
        {
          "from": "input-1",
          "to": "createSchema",
          "out": "description",
          "in": "description"
        },
        {
          "from": "input-1",
          "to": "fn-6",
          "out": "title",
          "in": "title"
        },
        {
          "from": "input-1",
          "to": "fn-6",
          "out": "description",
          "in": "description"
        },
        {
          "from": "input-7",
          "to": "fn-8",
          "out": "choice",
          "in": "choice"
        }
      ],
      "nodes": [
        {
          "id": "output-2",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "context": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "behavior": [
                      "llm-content"
                    ]
                  },
                  "title": "Context out"
                },
                "text": {
                  "title": "Text",
                  "behavior": [
                    "deprecated"
                  ],
                  "type": "string"
                }
              }
            }
          }
        },
        {
          "id": "appendContext",
          "type": "runJavascript",
          "configuration": {
            "code": "const appendContext = ({context,toAdd})=>{if(!context)throw new Error(\"Context is required\");const existing=Array.isArray(context)?context:[context];const incoming=toAdd;if(!incoming.parts){const containsUserRole=existing.filter(item=>item.role!==\"model\"&&item.role!==\"$metadata\").length>0;if(!containsUserRole){return{context:[...existing,{role:\"user\",parts:[{text:\"Do your magic\"}]}]}}return{context:existing}}if(!incoming.role){incoming.role=\"user\"}const last=existing[existing.length-1];if(!last){return{context:[incoming]}}if(last.role!==incoming.role){return{context:[...existing,incoming]}}else{const result=structuredClone(existing);const index=result.length-1;result[index].parts.push(...incoming.parts);return{context:result}}};",
            "name": "appendContext",
            "raw": true
          },
          "metadata": {
            "title": "Append Context",
            "description": "Appending user input to the conversation context"
          }
        },
        {
          "id": "input",
          "type": "input",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "text": {
                  "title": "Text",
                  "behavior": [
                    "deprecated"
                  ],
                  "type": "string"
                }
              },
              "required": [
                "text"
              ]
            }
          },
          "metadata": {
            "title": "Input",
            "description": "Asking user for input"
          }
        },
        {
          "id": "fn-5",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_5 = ({context})=>{const c=asContextArray(context);const mode=computeMode(c);if(mode===\"input\"){return{input:c}}else if(mode===\"inputOutput\"){return{input:c,output:c}}return{output:onlyChoices(c),choose:c};function asContextArray(context2){const input=context2;return Array.isArray(input)?input:[input]}__name(asContextArray,\"asContextArray\");function onlyChoices(context2){const choices=[];const reversed=[...context2].reverse();for(const item of reversed){choices.push(item);if(item.role===\"$metadata\"&&item.type===\"split\"&&item.data.type===\"start\"){break}}return choices.reverse()}__name(onlyChoices,\"onlyChoices\");function computeMode(context2){const lastItem=context2[context2.length-1];if(lastItem.role===\"user\"){return\"input\"}if(lastItem.role!==\"$metadata\"){return\"inputOutput\"}if(lastItem.type===\"split\"&&lastItem.data.type===\"end\"){return\"choose\"}return\"inputOutput\"}__name(computeMode,\"computeMode\")};",
            "name": "fn_5",
            "raw": true
          },
          "metadata": {
            "title": "Compute Mode",
            "description": "Determining the mode of operation"
          }
        },
        {
          "id": "createSchema",
          "type": "runJavascript",
          "configuration": {
            "code": "const createSchema = ({title,action,description,context})=>{const text={title,description,type:\"object\",behavior:[\"transient\",\"llm-content\"]};const schema={type:\"object\",properties:{text}};if(action?.action==\"vote\"){text.title=action.title;text.enum=[\"Yes\",\"No\"]}return{schema,context}};",
            "name": "createSchema",
            "raw": true
          },
          "metadata": {
            "title": "Create Schema",
            "description": "Creating a schema for user input"
          }
        },
        {
          "id": "fn-3",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_3 = ({context})=>{if(!context)throw new Error(\"Context is required\");const c=context;let done=false;for(let i=0;i<c.length;++i){const item=c[i];if(item.role===\"$metadata\"&&item.type===\"looper\"){const plan=item.data;if(plan.done){done=true;break}}}if(done){return{done:context}}else{return{context}}};",
            "name": "fn_3",
            "raw": true
          },
          "metadata": {
            "title": "Done Check",
            "description": "Checking to see if we can skip work altogether"
          }
        },
        {
          "id": "fn-6",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_6 = ({context,title,description})=>{const c=asContextArray(context).reverse();const choices=[];for(const item of c){if(item.role===\"$metadata\"&&item.type===\"split\"){const type=item.data.type;if(type===\"start\"){break}else{choices.push(`Choice ${choices.length+1}`)}}}const schema={type:\"object\",properties:{choice:{title,description,type:\"string\",enum:choices}}};return{schema,total:choices.length};function asContextArray(context2){const input=context2;return Array.isArray(input)?input:[input]}__name(asContextArray,\"asContextArray\")};",
            "name": "fn_6",
            "raw": true
          },
          "metadata": {
            "title": "Choose Options",
            "description": "Creating the options to choose from"
          }
        },
        {
          "id": "fn-8",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_8 = ({context,choice,total})=>{const chosenIndex=total-parseInt(choice.split(\" \")[1],10);const c=context.reverse();const current=[];let found=\"before\";let chunkIndex=0;let startIndex=0;for(const[i,item]of c.entries()){if(item.role===\"$metadata\"&&item.type===\"split\"){const type=item.data.type;if(type===\"start\"){startIndex=i;break}else{if(chunkIndex===chosenIndex){found=\"found\"}else if(chunkIndex>chosenIndex){found=\"after\"}else{found=\"before\"}chunkIndex++}}else if(found===\"found\"){current.push(item)}}const preamble=c.slice(startIndex+1).reverse();if(!found){throw new Error(`Integrity error: choice \"${choice}\" not found`)}return{context:[...preamble,...current.reverse()]}};",
            "name": "fn_8",
            "raw": true
          },
          "metadata": {
            "title": "Read Choice",
            "description": "Reading the user's choice"
          }
        },
        {
          "id": "output",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "behavior": [
                "bubble"
              ],
              "properties": {
                "output": {
                  "type": "object",
                  "behavior": [
                    "llm-content"
                  ],
                  "title": "Output",
                  "description": "The output to display"
                }
              }
            }
          },
          "metadata": {
            "title": "Output",
            "description": "Displaying the output the user."
          }
        },
        {
          "id": "input-1",
          "type": "input",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "context": {
                  "title": "Context in",
                  "description": "Incoming conversation context",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "behavior": [
                      "llm-content"
                    ]
                  },
                  "examples": [
                    "[{\"parts\":[{\"text\":\"{\\\"adCampaign\\\":{\\\"headlines\\\":[\\\"Breadboard: AI Playground\\\",\\\"Exp. AI Patterns\\\",\\\"Rapid Prototyping\\\",\\\"AI Power, Gemini\\\",\\\"Integrate AI Seamlessly\\\",\\\"Create Graphs, Prompts\\\",\\\"Accessible AI\\\",\\\"Breadboard: Dev's AI Kit\\\",\\\"Supercharge Dev, Breadboard\\\",\\\"Accelerate Innovation\\\",\\\"Revolutionize Dev, AI\\\",\\\"Breadboard: AI, Ingenuity\\\",\\\"Elevate Projects, Breadboard\\\",\\\"Unlock AI Power, Breadboard\\\"],\\\"descriptions\\\":[\\\"Breadboard: Play, experiment, prototype with AI. Integrate AI with Gemini.\\\",\\\"Stunning graphs with prompts. Accessible AI for devs.\\\",\\\"Accelerate innovation with Breadboard. Experiment with AI risk-free.\\\",\\\"Elevate projects with Breadboard AI. Integrate AI seamlessly.\\\"]},\\\"voteRequest\\\":\\\"Does this ad campaign seem ok to you?\\\"}\"}],\"role\":\"model\"}]"
                  ],
                  "default": "[]"
                },
                "title": {
                  "title": "Title",
                  "description": "The user label",
                  "behavior": [
                    "config"
                  ],
                  "default": "User",
                  "type": "string"
                },
                "description": {
                  "title": "Description",
                  "description": "The user's input",
                  "behavior": [
                    "config"
                  ],
                  "default": "A request or response",
                  "type": "string"
                }
              },
              "required": []
            }
          }
        },
        {
          "id": "output-4",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "context": {
                  "title": "Context out",
                  "type": "string"
                }
              }
            }
          },
          "metadata": {
            "title": "Done",
            "description": "Skipping because we're done"
          }
        },
        {
          "id": "input-7",
          "type": "input",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "choice": {
                  "type": "string",
                  "title": "choice"
                }
              },
              "required": [
                "choice"
              ]
            }
          },
          "metadata": {
            "title": "Look at the choices above and pick one",
            "description": "Asking user to choose an option"
          }
        },
        {
          "id": "output-9",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "context": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "behavior": [
                      "llm-content"
                    ]
                  },
                  "title": "Context out"
                }
              }
            }
          },
          "metadata": {
            "title": "Choice Output",
            "description": "Outputting the user's choice"
          }
        }
      ],
      "graphs": {}
    },
    "repeater": {
      "title": "Repeater",
      "description": "A worker whose job it is to repeat the same thing over and over, until some condition is met or the max count of repetitions is reached.",
      "version": "0.0.1",
      "edges": [
        {
          "from": "counter",
          "to": "invokeAgent",
          "out": "continue",
          "in": "context"
        },
        {
          "from": "counter",
          "to": "counter",
          "out": "count",
          "in": "count"
        },
        {
          "from": "counter",
          "to": "output-2",
          "out": "stop",
          "in": "context"
        },
        {
          "from": "invokeAgent",
          "to": "exit",
          "out": "exit",
          "in": "context"
        },
        {
          "from": "invokeAgent",
          "to": "counter",
          "out": "context",
          "in": "context"
        },
        {
          "from": "input-1",
          "to": "invokeAgent",
          "out": "worker",
          "in": "$board",
          "constant": true
        },
        {
          "from": "input-1",
          "to": "invokeAgent",
          "out": "context",
          "in": "context"
        },
        {
          "from": "input-1",
          "to": "counter",
          "out": "max",
          "in": "count"
        }
      ],
      "nodes": [
        {
          "id": "output-2",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "context": {
                  "type": "string",
                  "title": "context"
                }
              }
            }
          }
        },
        {
          "id": "counter",
          "type": "runJavascript",
          "configuration": {
            "code": "const counter = ({context,count})=>{const num=count-1;if(num!=0){return{continue:context,count:num}}return{stop:context}};",
            "name": "counter",
            "raw": true
          },
          "metadata": {
            "title": "Counter",
            "description": "Counting the number of repetitions"
          }
        },
        {
          "id": "invokeAgent",
          "type": "invoke",
          "configuration": {},
          "metadata": {
            "title": "Invoke Worker",
            "description": "Invoking the worker"
          }
        },
        {
          "id": "input-1",
          "type": "input",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "worker": {
                  "type": "object",
                  "properties": {},
                  "required": [],
                  "additionalProperties": false,
                  "title": "Worker",
                  "description": "Worker to repeat",
                  "behavior": [
                    "board"
                  ]
                },
                "context": {
                  "title": "Context",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "format": "multiline",
                    "behavior": [
                      "llm-content"
                    ]
                  },
                  "default": "[]",
                  "description": "Initial conversation context"
                },
                "max": {
                  "title": "Max",
                  "description": "The maximum number of repetitions to make (set to -1 to go infinitely)",
                  "type": "number",
                  "default": "-1",
                  "examples": [
                    "3"
                  ]
                }
              },
              "required": [
                "worker"
              ]
            }
          }
        },
        {
          "id": "exit",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "context": {
                  "type": "string",
                  "title": "context"
                }
              }
            }
          },
          "metadata": {
            "title": "Exit",
            "description": "Exiting early from the repeater"
          }
        }
      ],
      "graphs": {}
    },
    "structuredWorker": {
      "title": "Structured Worker",
      "description": "A worker who outputs structure data (JSON) provided a schema.",
      "version": "0.0.1",
      "edges": [
        {
          "from": "assembleContext",
          "to": "output-2",
          "out": "context",
          "in": "context"
        },
        {
          "from": "validate",
          "to": "count",
          "out": "$error",
          "in": "error"
        },
        {
          "from": "validate",
          "to": "errorOutput",
          "out": "$error",
          "in": "$error"
        },
        {
          "from": "validate",
          "to": "assembleContext",
          "out": "json",
          "in": "json"
        },
        {
          "from": "validate",
          "to": "output-2",
          "out": "json",
          "in": "json"
        },
        {
          "from": "buildContext",
          "to": "count",
          "out": "context",
          "in": "context",
          "constant": true
        },
        {
          "from": "buildContext",
          "to": "assembleContext",
          "out": "context",
          "in": "context"
        },
        {
          "from": "generate",
          "to": "validate",
          "out": "text",
          "in": "json"
        },
        {
          "from": "input-1",
          "to": "schemish",
          "out": "schema",
          "in": "schema"
        },
        {
          "from": "input-1",
          "to": "buildContext",
          "out": "context",
          "in": "context"
        },
        {
          "from": "input-1",
          "to": "buildContext",
          "out": "instruction",
          "in": "instruction"
        },
        {
          "from": "input-1",
          "to": "validate",
          "out": "schema",
          "in": "schema",
          "constant": true
        },
        {
          "from": "count",
          "to": "count",
          "out": "count",
          "in": "count"
        },
        {
          "from": "count",
          "to": "generate",
          "out": "continue",
          "in": "context"
        },
        {
          "from": "count",
          "to": "errorOutput",
          "out": "stop",
          "in": "context"
        },
        {
          "from": "format",
          "to": "buildContext",
          "out": "prompt",
          "in": "format"
        },
        {
          "from": "schemish",
          "to": "format",
          "out": "schemish",
          "in": "schemish"
        },
        {
          "from": "initialValues",
          "to": "count",
          "out": "count",
          "in": "count"
        },
        {
          "from": "initialValues",
          "to": "count",
          "out": "error",
          "in": "error"
        }
      ],
      "nodes": [
        {
          "id": "output-2",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "context": {
                  "type": "string",
                  "title": "context"
                },
                "json": {
                  "title": "json",
                  "description": "The validated JSON.",
                  "type": "string"
                }
              }
            }
          }
        },
        {
          "id": "assembleContext",
          "type": "runJavascript",
          "configuration": {
            "code": "const assembleContext = ({context,json:json2})=>{if(!context)throw new Error(\"Context is required\");return{context:[...context,{role:\"model\",parts:{text:JSON.stringify(json2)}}]}};",
            "name": "assembleContext",
            "raw": true
          },
          "metadata": {
            "title": "Assemble Context",
            "description": "Assembling the context for the agent"
          }
        },
        {
          "id": "validate",
          "type": "validateJson",
          "configuration": {},
          "metadata": {
            "title": "Validate JSON",
            "logLevel": "info",
            "description": "Checking my work"
          }
        },
        {
          "id": "buildContext",
          "type": "runJavascript",
          "configuration": {
            "code": "const buildContext = ({context,format,instruction})=>{if(!Array.isArray(context)){const text=typeof context===\"string\"?context:JSON.stringify(context);context=[{role:\"user\",parts:[{text}]}]}const list=context||[];if(list.length>0){const last=list[list.length-1];if(last.role===\"user\"){last.parts.unshift({text:instruction},{text:format});return{context:list}}}return{context:[...list,{role:\"user\",parts:[{text:instruction},{text:format}]}]}};",
            "name": "buildContext",
            "raw": true
          },
          "metadata": {
            "title": "Build Context",
            "description": "Building the context for the agent"
          }
        },
        {
          "id": "generate",
          "type": "text",
          "configuration": {
            "text": "unused"
          },
          "metadata": {
            "title": "Generate",
            "logLevel": "info",
            "description": "Generating an answer"
          }
        },
        {
          "id": "input-1",
          "type": "input",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "schema": {
                  "title": "Schema",
                  "description": "The schema to convert to schemish.",
                  "type": "object",
                  "examples": [
                    "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"poems\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"inspiration\": {\n            \"type\": \"string\",\n            \"description\": \"The inspiration behind the poem\"\n          },\n          \"poem\": {\n            \"type\": \"string\",\n            \"description\": \"The poem itself\"\n          }\n        }\n      }\n    }\n  }\n}"
                  ],
                  "behavior": [
                    "json-schema",
                    "config"
                  ],
                  "default": "{}"
                },
                "context": {
                  "title": "Context",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "behavior": [
                      "llm-content"
                    ]
                  },
                  "default": "[]",
                  "examples": [
                    "the universe within us"
                  ]
                },
                "instruction": {
                  "title": "Instruction",
                  "behavior": [
                    "config"
                  ],
                  "format": "multiline",
                  "examples": [
                    "You are a brilliant poet who specializes in two-line rhyming poems.\nGiven any topic, you can quickly whip up three two-line rhyming poems about it.\nLook at the topic below and do your magic"
                  ],
                  "type": "string"
                }
              },
              "required": [
                "instruction"
              ]
            }
          }
        },
        {
          "id": "count",
          "type": "runJavascript",
          "configuration": {
            "code": "const count = ({context,error,count})=>{const num=count-1;if(num!=0){return{continue:context,count:num}}return{stop:error}};",
            "name": "count",
            "raw": true
          },
          "metadata": {
            "title": "Counter",
            "description": "Counting the JSON healing iteration"
          }
        },
        {
          "id": "errorOutput",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "$error": {
                  "title": "$error",
                  "description": "The error if the JSON is invalid.",
                  "type": "object",
                  "properties": {
                    "kind": {
                      "type": "string",
                      "enum": [
                        "error"
                      ]
                    },
                    "error": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string",
                          "enum": [
                            "parsing",
                            "validation"
                          ]
                        },
                        "message": {
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "context": {
                  "type": "string",
                  "title": "context"
                }
              }
            }
          },
          "metadata": {
            "title": "Error Output",
            "description": "Displaying error output, giving up on JSON healing"
          }
        },
        {
          "id": "format",
          "type": "promptTemplate",
          "configuration": {
            "template": "Reply as valid JSON of the following format:\n\n```json\n{{schemish}}\n```\n"
          },
          "metadata": {
            "title": "Reply Structure Formatter",
            "description": "Formatting the reply structure for the agent."
          }
        },
        {
          "id": "schemish",
          "type": "schemish",
          "configuration": {},
          "metadata": {
            "title": "Schemish",
            "description": "Converting JSON schema to a more compact format"
          }
        },
        {
          "id": "initialValues",
          "type": "passthrough",
          "configuration": {
            "count": 5,
            "error": "stub"
          },
          "metadata": {
            "title": "Initial Values",
            "description": "Populating initial values for the counter"
          }
        }
      ],
      "graphs": {}
    },
    "specialist": {
      "title": "Specialist",
      "metadata": {
        "icon": "smart-toy"
      },
      "description": "All-in-one worker. A work in progress, incorporates all the learnings from making previous workers.",
      "edges": [
        {
          "from": "fn-13",
          "to": "output-2",
          "out": "context",
          "in": "out"
        },
        {
          "from": "fn-5",
          "to": "fn-6",
          "out": "context",
          "in": "context"
        },
        {
          "from": "fn-5",
          "to": "text-8",
          "out": "context",
          "in": "context"
        },
        {
          "from": "fn-5",
          "to": "fn-13",
          "out": "context",
          "in": "context"
        },
        {
          "from": "router",
          "to": "assembleBoardInvoke",
          "out": "context",
          "in": "context"
        },
        {
          "from": "router",
          "to": "assembleBoardInvoke",
          "out": "functionCalls",
          "in": "functionCalls"
        },
        {
          "from": "router",
          "to": "fn-13",
          "out": "context",
          "in": "generated"
        },
        {
          "from": "router",
          "to": "fn-13",
          "out": "text",
          "in": "text"
        },
        {
          "from": "fn-3",
          "to": "fn-5",
          "out": "context",
          "in": "context"
        },
        {
          "from": "fn-4",
          "to": "fn-5",
          "out": "progress",
          "in": "progress"
        },
        {
          "from": "fn-6",
          "to": "curry-7",
          "out": "context",
          "in": "context"
        },
        {
          "from": "fn-6",
          "to": "fn-10",
          "out": "context",
          "in": "context"
        },
        {
          "from": "text-8",
          "to": "router",
          "out": "context",
          "in": "context"
        },
        {
          "from": "assembleBoardInvoke",
          "to": "map-9",
          "out": "list",
          "in": "list"
        },
        {
          "from": "input-1",
          "to": "fn-3",
          "out": "in",
          "in": "context"
        },
        {
          "from": "input-1",
          "to": "fn-3",
          "out": "task",
          "in": "toAdd"
        },
        {
          "from": "input-1",
          "to": "fn-4",
          "out": "in",
          "in": "context"
        },
        {
          "from": "input-1",
          "to": "turnBoardsToFunctions",
          "out": "tools",
          "in": "list"
        },
        {
          "from": "input-1",
          "to": "text-8",
          "out": "persona",
          "in": "systemInstruction"
        },
        {
          "from": "curry-7",
          "to": "turnBoardsToFunctions",
          "out": "board",
          "in": "board"
        },
        {
          "from": "fn-10",
          "to": "fn-11",
          "out": "*",
          "in": ""
        },
        {
          "from": "formatFunctionDeclarations",
          "to": "text-8",
          "out": "tools",
          "in": "tools"
        },
        {
          "from": "formatFunctionDeclarations",
          "to": "assembleBoardInvoke",
          "out": "urlMap",
          "in": "urlMap"
        },
        {
          "from": "map-9",
          "to": "fn-10",
          "out": "list",
          "in": "response"
        },
        {
          "from": "turnBoardsToFunctions",
          "to": "formatFunctionDeclarations",
          "out": "list",
          "in": "list"
        },
        {
          "from": "fn-11",
          "to": "output-12",
          "out": "context",
          "in": "out"
        }
      ],
      "nodes": [
        {
          "id": "output-2",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "out": {
                  "title": "Context out",
                  "type": "string"
                }
              }
            }
          }
        },
        {
          "id": "fn-13",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_13 = ({context,generated})=>{if(!context)throw new Error(\"Context is required\");if(!generated)throw new Error(\"Generated is required\");const c=context;const g=generated;let doneMarker=null;for(let i=0;i<c.length;++i){const item=c[i];if(item.role===\"$metadata\"&&item.type===\"looper\"){const plan=item.data;if(plan.doneMarker){doneMarker=plan.doneMarker;break}}}if(!doneMarker){return{context:[...c,g]}}let containsMarkers=false;for(let i=0;i<g.parts.length;++i){const part=g.parts[i];if(\"text\"in part&&part.text.includes(doneMarker)){containsMarkers=true;part.text=part.text.replaceAll(doneMarker,\"\").trim();break}}if(!containsMarkers){return{context:[...c,g]}}const metadata={role:\"$metadata\",type:\"looper\",data:{done:true}};return{context:[...c,g,metadata]}};",
            "name": "fn_13",
            "raw": true
          },
          "metadata": {
            "title": "Done Check",
            "description": "Checking for the 'Done' marker"
          }
        },
        {
          "id": "fn-5",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_5 = ({context,progress})=>{const contents=Array.isArray(context)?context:[context];const plans=Array.isArray(progress)?progress:[progress];const last=plans[0];if(!last||!last.next){return{context}}const lastLooperMarker=contents.findLastIndex(item=>item.role===\"$metadata\"&&item.type===\"looper\");if(lastLooperMarker>=0){const pastLooper=contents.slice(lastLooperMarker);const hasModel=pastLooper.some(item=>item.role===\"model\");if(hasModel){return{context:contents}}}contents.push({role:\"user\",parts:[{text:last.next}]});return{context:contents}};",
            "name": "fn_5",
            "raw": true
          },
          "metadata": {
            "title": "Add Looper Task",
            "description": "If there is a pending Looper task, add it."
          }
        },
        {
          "id": "router",
          "type": "runJavascript",
          "configuration": {
            "code": "const router = ({context})=>{if(!context)throw new Error(\"Context is a required input\");const item=context;const functionCallParts=item.parts.filter(part=>\"functionCall\"in part).map(part=>part.functionCall);if(functionCallParts.length===0){const textPart=item.parts.find(part=>\"text\"in part);if(!textPart)throw new Error(\"No text or function call found in context\");return{context,text:textPart.text}}return{context,functionCalls:functionCallParts}};",
            "name": "router",
            "raw": true
          },
          "metadata": {
            "title": "Router",
            "description": "Routing to either function call invocation or text reply"
          }
        },
        {
          "id": "fn-3",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_3 = ({context,toAdd})=>{if(!context)throw new Error(\"Context is required\");const existing=Array.isArray(context)?context:[context];const incoming=toAdd;if(!incoming.parts){const containsUserRole=existing.filter(item=>item.role!==\"model\"&&item.role!==\"$metadata\").length>0;if(!containsUserRole){return{context:[...existing,{role:\"user\",parts:[{text:\"Do your magic\"}]}]}}return{context:existing}}if(!incoming.role){incoming.role=\"user\"}const last=existing[existing.length-1];if(!last){return{context:[incoming]}}if(last.role!==incoming.role){return{context:[...existing,incoming]}}else{const result=structuredClone(existing);const index=result.length-1;result[index].parts.push(...incoming.parts);return{context:result}}};",
            "name": "fn_3",
            "raw": true
          },
          "metadata": {
            "title": "Add Task",
            "description": "Adding task to the prompt."
          }
        },
        {
          "id": "fn-4",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_4 = ({context,forkOutputs})=>{const fork=forkOutputs;const existing=Array.isArray(context)?context:[context];const progress=[];for(let i=existing.length-1;i>=0;i--){const item=existing[i];if(item.role===\"$metadata\"&&item.type===\"looper\"){progress.push(item.data)}}if(fork){if(progress.length){return{progress}}else{return{context}}}else{return{context,progress}}};",
            "name": "fn_4",
            "raw": true
          },
          "metadata": {
            "title": "Read Progress so far"
          }
        },
        {
          "id": "fn-6",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_6 = ({context})=>{if(!context)throw new Error(\"Context is required\");const c=context;const id=Math.random().toString(36).substring(7);const metadata={role:\"$metadata\",type:\"split\",data:{type:\"start\",id}};return{context:[...c,metadata],id}};",
            "name": "fn_6",
            "raw": true
          },
          "metadata": {
            "title": "Add Split Start",
            "description": "Marking the start of parallel processing in the context"
          }
        },
        {
          "id": "text-8",
          "type": "text",
          "configuration": {},
          "metadata": {
            "title": "Gemini API Call",
            "description": "Applying Gemini to do work"
          }
        },
        {
          "id": "assembleBoardInvoke",
          "type": "runJavascript",
          "configuration": {
            "code": "const assembleBoardInvoke = ({functionCalls,urlMap})=>{if(!functionCalls){throw new Error(\"Function call array is a required input\")}if(!urlMap){throw new Error(\"URL map is a required input\")}const calls=functionCalls;if(calls.length===0){throw new Error(\"Function call array must not be empty.\")}const list=[];for(const call of calls){const item=urlMap[call.name];const $board=item.url;const $flags=item.flags;const llmContentProperty=$flags.inputLLMContent||$flags.inputLLMContentArray;const invokeArgs={$board,$flags,...call.args};if(llmContentProperty){const args=call.args;const text=args[llmContentProperty];const parts=[{text}];const llmContent={parts,role:\"user\"};if($flags.inputLLMContentArray){invokeArgs[llmContentProperty]=[llmContent]}else{invokeArgs[llmContentProperty]=llmContent}}list.push(invokeArgs)}return{list}};",
            "name": "assembleBoardInvoke",
            "raw": true
          },
          "metadata": {
            "title": "Assemble Tool Invoke",
            "description": "Assembling the tool invocation based on Gemini response"
          }
        },
        {
          "id": "input-1",
          "type": "input",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "in": {
                  "title": "Context in",
                  "description": "Incoming conversation context",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "behavior": [
                      "llm-content"
                    ]
                  },
                  "examples": [
                    "[\n  {\n    \"role\": \"user\",\n    \"parts\": [\n      {\n        \"text\": \"\\nbook description: This book will be about breadboards and how awesome they are\\nchapter target: 10\\npage target: 400\\nfiction genre: space opera\\nsetting: the planet where there are no breadboards\\nstory arc: A girl named Aurora invents a breadboard on the planet where breadboards are strictly forbidden. Through struggles and determination, and with the help of trusted friends, Aurora overcomes many challenges and changes the whole planet for the better. \\ntonality: futuristic struggle, but optimistic\\nworking title: Aurora\\n\"\n      }\n    ]\n  }\n]"
                  ]
                },
                "task": {
                  "title": "Task",
                  "description": "(Optional) Provide a specific task with clear instructions for the worker to complete using the conversation context",
                  "type": "object",
                  "default": "{}",
                  "behavior": [
                    "llm-content",
                    "config"
                  ],
                  "examples": [
                    "{\n  \"parts\": [\n    {\n      \"text\": \"\\nWrite an outline for a novel, following the provided specs.\\n\"\n    }\n  ]\n}"
                  ]
                },
                "tools": {
                  "title": "Tools",
                  "type": "array",
                  "description": "(Optional) Add tools to this list for the worker to use when needed",
                  "items": {
                    "type": "object",
                    "behavior": [
                      "board",
                      "config"
                    ]
                  },
                  "default": "[]"
                },
                "persona": {
                  "type": "object",
                  "title": "Persona",
                  "description": "Describe the worker's skills, capabilities, mindset, and thinking process",
                  "default": "",
                  "examples": [
                    "{\n  \"parts\": [\n    {\n      \"text\": \"\\nYou are a famous author.  You are writing a novel.\\n\\nYour well-established process starts with collecting the book description, chapter target, page target, fiction genre, setting, story arc, tonality and the working title.\\n\\nThen, your first step is to write a detailed outline for the novel.  You keep the page target in mind for the finished novel, so your outline typically contains contain key bullets for the story arc across the chapters. You usually create a part of the outline for each chapter. You also keep in mind that the outline must cover at least the target number of chapters.\\n\\nYou are very creative and you pride yourself in adding interesting twists and unexpected turns of the story, something that keeps the reader glued to your book.\\n\"\n    }\n  ]\n}"
                  ],
                  "behavior": [
                    "llm-content",
                    "config"
                  ]
                }
              },
              "required": [
                "in",
                "persona"
              ]
            }
          }
        },
        {
          "id": "curry-7",
          "type": "curry",
          "configuration": {
            "$board": "#boardToFunction"
          },
          "metadata": {
            "title": "Add Context",
            "description": "Adding context to the board to function converter"
          }
        },
        {
          "id": "fn-10",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_10 = ({response,context})=>{const r=response;const c=context;const result=Object.fromEntries(r.map((item,i)=>[`context-${i+1}`,item.item]));if(c){result[\"context-0\"]=c}return result};",
            "name": "fn_10",
            "raw": true
          },
          "metadata": {
            "title": "Format Tool Response",
            "description": "Formatting tool response"
          }
        },
        {
          "id": "formatFunctionDeclarations",
          "type": "runJavascript",
          "configuration": {
            "code": "const formatFunctionDeclarations = ({list})=>{const tools=[];const urlMap={};list.forEach(item=>{tools.push(item.function);const flags=item.flags;urlMap[item.function.name]={url:item.boardURL,flags}});return{tools,urlMap}};",
            "name": "formatFunctionDeclarations",
            "raw": true
          },
          "metadata": {
            "title": "Format Function Declarations",
            "description": "Formatting the function declarations"
          }
        },
        {
          "id": "map-9",
          "type": "map",
          "configuration": {
            "board": "#invokeBoardWithArgs"
          },
          "metadata": {
            "title": "Invoke Tools in Parallel",
            "description": "Invoking tools in parallel"
          }
        },
        {
          "id": "turnBoardsToFunctions",
          "type": "map",
          "configuration": {},
          "metadata": {
            "title": "Turn Boards into Functions",
            "description": "Turning provided boards into functions"
          }
        },
        {
          "id": "fn-11",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_11 = ({merge,...inputs})=>{const entries=Object.entries(inputs).sort();if(merge){const context=[];const parts=[];for(const[,input]of entries){const c=asContextArray(input);let lastIndex=c.length-1;let last;do{last=c[lastIndex--]}while(lastIndex>=0&&last.role===\"$metadata\");if(last){parts.push(...last.parts)}}context.push({parts});return{context}}else{let mode;const[f,...rest]=entries;if(!f){return{context:[]}}const first=asContextArray(f[1]);const firstOpenSplits=scanForSplits(first);const preambleIndices=[];for(const[,input]of rest){const c=asContextArray(input);const hasOpenSplits=scanForSplits(c);if(hasOpenSplits){preambleIndices.push(hasOpenSplits[1])}}if(!firstOpenSplits){if(preambleIndices.length===0){mode=\"simple\"}else{mode=\"adhoc\"}}else{const preamblesMatch=preambleIndices.length>0&&preambleIndices.every(value=>value===firstOpenSplits[1]);if(preamblesMatch){mode=\"preamble\"}else{if(firstOpenSplits[1]===first.length-1){mode=\"single\"}else{mode=\"adhoc\"}}}const context=[];if(mode===\"adhoc\"){for(const[,input]of entries){const c=asContextArray(input);context.push(...c)}return{context}}else if(mode===\"simple\"){const splitId=Math.random().toString(36).substring(7);context.push({role:\"$metadata\",type:\"split\",data:{type:\"start\",id:splitId}});for(const[,input]of entries){const c=asContextArray(input);context.push(...c);context.push({role:\"$metadata\",type:\"split\",data:{type:\"next\",id:splitId}})}}else if(mode===\"preamble\"){const preambleIndex=firstOpenSplits?.[1]||0;const preamble=entries[0][1].slice(0,preambleIndex+1);context.push(...preamble);const splitId=preamble[preamble.length-1].data.id;for(const[,input]of entries){let c=asContextArray(input);if(preambleIndex>=0){c=c.slice(preambleIndex+1)}if(c.length){context.push(...c);context.push({role:\"$metadata\",type:\"split\",data:{type:\"next\",id:splitId}})}}}else if(mode===\"single\"){const splitId=first[first.length-1].data.id;context.push(...first);for(const[,input]of rest){const c=asContextArray(input);context.push(...c);context.push({role:\"$metadata\",type:\"split\",data:{type:\"next\",id:splitId}})}}const last=context[context.length-1];last.data.type=\"end\";return{context}}function asContextArray(input){return Array.isArray(input)?input:[input]}__name(asContextArray,\"asContextArray\");function scanForSplits(c){const stack=[];for(const[i,item]of c.entries()){if(item.role!==\"$metadata\")continue;if(item.type!==\"split\")continue;if(item.data.type===\"start\"){stack.push([item.data.id,i])}if(item.data.type===\"end\"){const[id]=stack.pop()||[];if(id!==item.data.id){console.warn(\"Split integrity error: mismatched split start/end markers. Start:\",id,\"End:\",item.data.id);return null}}}return stack.pop()||null}__name(scanForSplits,\"scanForSplits\")};",
            "name": "fn_11",
            "raw": true
          },
          "metadata": {
            "title": "Add Tool Response",
            "description": "Adding tool response to context"
          }
        },
        {
          "id": "output-12",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "out": {
                  "title": "Context out",
                  "type": "string"
                }
              }
            }
          },
          "metadata": {
            "title": "Tool Output",
            "description": "Return tool results as output"
          }
        }
      ],
      "graphs": {
        "boardToFunction": {
          "title": "Board to functions",
          "description": "Use this board to convert specified boards into function-calling signatures",
          "edges": [
            {
              "from": "fn-4",
              "to": "output-2",
              "out": "function",
              "in": "function"
            },
            {
              "from": "fn-4",
              "to": "output-2",
              "out": "board",
              "in": "boardURL"
            },
            {
              "from": "fn-4",
              "to": "output-2",
              "out": "flags",
              "in": "flags"
            },
            {
              "from": "curry-3",
              "to": "fn-4",
              "out": "board",
              "in": "board"
            },
            {
              "from": "input-1",
              "to": "curry-3",
              "out": "item",
              "in": "$board"
            },
            {
              "from": "input-1",
              "to": "curry-3",
              "out": "context",
              "in": "context"
            }
          ],
          "nodes": [
            {
              "id": "output-2",
              "type": "output",
              "configuration": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "function": {
                      "type": "string",
                      "title": "function"
                    },
                    "boardURL": {
                      "type": "string",
                      "title": "boardURL"
                    },
                    "flags": {
                      "type": "string",
                      "title": "flags"
                    }
                  }
                }
              }
            },
            {
              "id": "fn-4",
              "type": "runJavascript",
              "configuration": {
                "code": "const fn_4 = ({board:board2})=>{const b=board2;const inputs=b.nodes.filter(node=>node.type===\"input\");if(inputs.length===0){throw new Error(\"No inputs found\")}const outputs=b.nodes.filter(node=>node.type===\"output\");if(outputs.length===0){throw new Error(\"No outputs found\")}const inputSchema=inputs[0].configuration?.schema;if(!inputSchema){throw new Error(\"No input schema found\")}const outputSchema=outputs[0].configuration?.schema;if(!outputSchema){throw new Error(\"No output schema found\")}const properties={};const flags={};for(const key in inputSchema.properties){const property=inputSchema.properties[key];const isObject=property.type===\"object\";const isArray=property.type===\"array\";const type=isObject||isArray?\"string\":property.type;if(isObject&&property.behavior?.includes(\"llm-content\")){flags.inputLLMContent=key}else if(isArray&&property.items?.behavior?.includes(\"llm-content\")){flags.inputLLMContentArray=key;continue}const description2=property.description||property.title||\"text\";properties[key]={type,description:description2}}if(flags.inputLLMContentArray){const c=b.args?.context;if(c){b.args??={};b.args[flags.inputLLMContentArray]=c;delete b.args.context}}else{delete b.args?.context}for(const key in outputSchema.properties){const property=outputSchema.properties[key];const isObject=property.type===\"object\";const isArray=property.type===\"array\";if(isObject&&property.behavior?.includes(\"llm-content\")){flags.outputLLMContent=key}else if(isArray&&property.items?.behavior?.includes(\"llm-content\")){flags.outputLLMContentArray=key}}const name=b.title?.replace(/\\W/g,\"_\");const description=b.description;const parameters={type:\"object\",properties};return{function:{name,description,parameters},returns:outputSchema,flags,board:board2}};",
                "name": "fn_4",
                "raw": true
              },
              "metadata": {
                "title": "Get Function Signature from board"
              }
            },
            {
              "id": "curry-3",
              "type": "curry",
              "configuration": {}
            },
            {
              "id": "input-1",
              "type": "input",
              "configuration": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "item": {
                      "title": "board",
                      "behavior": [
                        "board"
                      ],
                      "description": "The board to curry. Can be a BoardCapability, a graph or a URL",
                      "type": "string"
                    },
                    "context": {
                      "type": "string",
                      "title": "context"
                    }
                  },
                  "required": [
                    "item",
                    "context"
                  ]
                }
              }
            }
          ],
          "graphs": {}
        },
        "invokeBoardWithArgs": {
          "title": "Invoke Board With Args",
          "description": "Takes one item of `boardInvocationAssembler` output and invokes it as a board with arguments.",
          "version": "0.0.1",
          "edges": [
            {
              "from": "fn-7",
              "to": "output-2",
              "out": "item",
              "in": "item"
            },
            {
              "from": "fn-6",
              "to": "fn-7",
              "out": "result",
              "in": "result"
            },
            {
              "from": "fn-4",
              "to": "fn-7",
              "out": "flags",
              "in": "flags"
            },
            {
              "from": "invoke-5",
              "to": "fn-6",
              "out": "*",
              "in": ""
            },
            {
              "from": "input-1",
              "to": "fn-3",
              "out": "item",
              "in": "item"
            },
            {
              "from": "input-1",
              "to": "fn-4",
              "out": "item",
              "in": "item"
            },
            {
              "from": "fn-3",
              "to": "invoke-5",
              "out": "*",
              "in": ""
            }
          ],
          "nodes": [
            {
              "id": "output-2",
              "type": "output",
              "configuration": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "item": {
                      "type": "string",
                      "title": "item"
                    }
                  }
                }
              }
            },
            {
              "id": "fn-7",
              "type": "runJavascript",
              "configuration": {
                "code": "const fn_7 = ({result,flags})=>{let contentDetected=false;const inputs=result;const item=[];const f=flags;if(f){if(f.outputLLMContent){const content=inputs[f.outputLLMContent];content.role=\"tool\";item.push(content);contentDetected=true}else if(f.outputLLMContentArray){const contentArray=inputs[f.outputLLMContentArray];contentArray.forEach(content=>{if(content.role!==\"$metadata\"){content.role=\"tool\"}item.push(content)});contentDetected=true}}else{for(const key in inputs){const input=inputs[key];if(input!==null&&typeof input===\"object\"&&\"content\"in input){const content=input.content;if(content.parts&&Array.isArray(content.parts)){content.role=\"tool\";item.push(content);contentDetected=true}}}}if(!contentDetected){const text=JSON.stringify(inputs);item.push({parts:[{text}],role:\"tool\"})}return{item}};",
                "name": "fn_7",
                "raw": true
              },
              "metadata": {
                "title": "Format results",
                "description": "Formatting results"
              }
            },
            {
              "id": "fn-6",
              "type": "runJavascript",
              "configuration": {
                "code": "const fn_6 = result=>{return{result}};",
                "name": "fn_6",
                "raw": true
              },
              "metadata": {
                "title": "Pack results",
                "description": "Packing results"
              }
            },
            {
              "id": "fn-4",
              "type": "runJavascript",
              "configuration": {
                "code": "const fn_4 = ({item})=>{const{$flags}=item;return{flags:$flags}};",
                "name": "fn_4",
                "raw": true
              },
              "metadata": {
                "title": "Get flags",
                "description": "Getting flags for the board invocation"
              }
            },
            {
              "id": "invoke-5",
              "type": "invoke",
              "configuration": {},
              "metadata": {
                "title": "Invoke board",
                "description": "Invoking the board with unpacked arguments"
              }
            },
            {
              "id": "input-1",
              "type": "input",
              "configuration": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "item": {
                      "type": "string",
                      "title": "item"
                    }
                  },
                  "required": [
                    "item"
                  ]
                }
              }
            },
            {
              "id": "fn-3",
              "type": "runJavascript",
              "configuration": {
                "code": "const fn_3 = ({item})=>{const{$flags,...result}=item;return result};",
                "name": "fn_3",
                "raw": true
              },
              "metadata": {
                "title": "Unpack args",
                "description": "Unpacking board arguments"
              }
            }
          ],
          "graphs": {}
        }
      }
    },
    "toolWorker": {
      "title": "Tool Worker",
      "description": "A worker that can use tools to accomplish tasks.",
      "version": "0.0.1",
      "metadata": {
        "deprecated": true
      },
      "edges": [
        {
          "from": "fn-3",
          "to": "output-2",
          "out": "context",
          "in": "context"
        },
        {
          "from": "router",
          "to": "assembleBoardInvoke",
          "out": "context",
          "in": "context"
        },
        {
          "from": "router",
          "to": "assembleBoardInvoke",
          "out": "functionCall",
          "in": "functionCall"
        },
        {
          "from": "router",
          "to": "formatFunctionResponse",
          "out": "context",
          "in": "generated"
        },
        {
          "from": "router",
          "to": "formatFunctionResponse",
          "out": "functionCall",
          "in": "functionCall"
        },
        {
          "from": "router",
          "to": "fn-3",
          "out": "context",
          "in": "generated"
        },
        {
          "from": "router",
          "to": "output-2",
          "out": "text",
          "in": "text"
        },
        {
          "from": "buildContext",
          "to": "doWork",
          "out": "context",
          "in": "context"
        },
        {
          "from": "buildContext",
          "to": "formatFunctionResponse",
          "out": "context",
          "in": "context"
        },
        {
          "from": "buildContext",
          "to": "fn-3",
          "out": "context",
          "in": "context"
        },
        {
          "from": "doWork",
          "to": "router",
          "out": "context",
          "in": "context"
        },
        {
          "from": "assembleBoardInvoke",
          "to": "invokeBoard",
          "out": "*",
          "in": ""
        },
        {
          "from": "formatFunctionResponse",
          "to": "replyToFunction",
          "out": "context",
          "in": "context"
        },
        {
          "from": "formatFunctionResponse",
          "to": "assembleContext",
          "out": "context",
          "in": "context"
        },
        {
          "from": "input-1",
          "to": "buildContext",
          "out": "context",
          "in": "context"
        },
        {
          "from": "input-1",
          "to": "buildContext",
          "out": "instruction",
          "in": "instruction"
        },
        {
          "from": "input-1",
          "to": "turnBoardsToFunctions",
          "out": "tools",
          "in": "list"
        },
        {
          "from": "input-1",
          "to": "doWork",
          "out": "instruction",
          "in": "systemInstruction"
        },
        {
          "from": "input-1",
          "to": "replyToFunction",
          "out": "retry",
          "in": "retry"
        },
        {
          "from": "formatFunctionDeclarations",
          "to": "doWork",
          "out": "tools",
          "in": "tools"
        },
        {
          "from": "formatFunctionDeclarations",
          "to": "assembleBoardInvoke",
          "out": "urlMap",
          "in": "urlMap"
        },
        {
          "from": "formatFunctionDeclarations",
          "to": "replyToFunction",
          "out": "tools",
          "in": "tools"
        },
        {
          "from": "invokeBoard",
          "to": "extractBoardResponse",
          "out": "*",
          "in": ""
        },
        {
          "from": "extractBoardResponse",
          "to": "formatFunctionResponse",
          "out": "response",
          "in": "response"
        },
        {
          "from": "replyToFunction",
          "to": "assembleContext",
          "out": "context",
          "in": "generated"
        },
        {
          "from": "replyToFunction",
          "to": "functionOutput",
          "out": "text",
          "in": "text"
        },
        {
          "from": "assembleContext",
          "to": "functionOutput",
          "out": "context",
          "in": "context"
        },
        {
          "from": "turnBoardsToFunctions",
          "to": "formatFunctionDeclarations",
          "out": "list",
          "in": "list"
        }
      ],
      "nodes": [
        {
          "id": "output-2",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "context": {
                  "type": "string",
                  "title": "context"
                },
                "text": {
                  "type": "string",
                  "title": "text"
                }
              }
            }
          }
        },
        {
          "id": "fn-3",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_3 = ({context,generated})=>{if(!context)throw new Error(\"Context is required\");return{context:[...context,generated]}};",
            "name": "fn_3",
            "raw": true
          },
          "metadata": {
            "title": "Assemble Non-function call Context",
            "description": "Assembling the final context for the output"
          }
        },
        {
          "id": "router",
          "type": "runJavascript",
          "configuration": {
            "code": "const router = ({context})=>{if(!context)throw new Error(\"Context is a required input\");const item=context;const functionCallParts=item.parts.filter(part=>\"functionCall\"in part).map(part=>part.functionCall);if(functionCallParts.length===0){const textPart=item.parts.find(part=>\"text\"in part);if(!textPart)throw new Error(\"No text or function call found in context\");return{context,text:textPart.text}}return{context,functionCalls:functionCallParts}};",
            "name": "router",
            "raw": true
          },
          "metadata": {
            "title": "Router",
            "description": "Routing to either function call invocation or text reply"
          }
        },
        {
          "id": "buildContext",
          "type": "runJavascript",
          "configuration": {
            "code": "const buildContext = ({context})=>{if(typeof context===\"string\"){context=[{role:\"user\",parts:[{text:context}]}]}const list=context||[];return{context:list}};",
            "name": "buildContext",
            "raw": true
          },
          "metadata": {
            "title": "Build Context",
            "description": "Combining the context and instruction into a single context"
          }
        },
        {
          "id": "doWork",
          "type": "text",
          "configuration": {},
          "metadata": {
            "title": "Do Work",
            "description": "Using Gemini to do the work"
          }
        },
        {
          "id": "assembleBoardInvoke",
          "type": "runJavascript",
          "configuration": {
            "code": "const assembleBoardInvoke = ({functionCalls,urlMap})=>{if(!functionCalls)throw new Error(\"Function call array is a required input\");if(!urlMap)throw new Error(\"URL map is a required input\");const calls=functionCalls;if(calls.length===0)throw new Error(\"Function call array must not be empty.\");const call=calls[0];const $board=urlMap[call.name];const generator=\"https://raw.githubusercontent.com/breadboard-ai/breadboard/05136f811e443dd931a2a2a40ff5a3f388d5ce75/packages/breadboard-web/public/graphs/gemini-generator.json\";return{$board,generator,...call.args}};",
            "name": "assembleBoardInvoke",
            "raw": true
          },
          "metadata": {
            "title": "Assemble Board Invoke",
            "description": "Assembling the board invocation based on Gemini response"
          }
        },
        {
          "id": "formatFunctionResponse",
          "type": "runJavascript",
          "configuration": {
            "code": "const formatFunctionResponse = ({context,generated,functionCall,response})=>{const call=functionCall;return{context:[...context,generated,{role:\"function\",parts:[{functionResponse:{name:call.name,response}}]}]}};",
            "name": "formatFunctionResponse",
            "raw": true
          },
          "metadata": {
            "title": "Format Function Response",
            "description": "Formatting the function response"
          }
        },
        {
          "id": "input-1",
          "type": "input",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "context": {
                  "title": "Context In",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "behavior": [
                      "llm-content"
                    ]
                  },
                  "default": "What is the square root of e?"
                },
                "instruction": {
                  "type": "string",
                  "title": "Instruction",
                  "description": "Describe the worker persona and the task given: the skills and various capabilities, the mindset, the thinking process, etc. The ideal task is a call to action with the necessary details on how to best complete this action.",
                  "default": "",
                  "examples": [
                    "You are a hip, fun-loving mathematician who loves to help solve problems and chat about math. You also love finding answers to questions using Search. Use the right tool for solving the problems and reply without engaging tools otherwise. After using the tool, make sure to summarize and expand the answer in a hip, humorous way to help the user enjoy the beauty of math.\n\nIn situations where the tool use is not necessary, just carry the conversation with the user."
                  ],
                  "format": "multiline"
                },
                "tools": {
                  "title": "Tools",
                  "type": "array",
                  "description": "The boards to use as tools",
                  "items": {
                    "type": "object",
                    "behavior": [
                      "board"
                    ]
                  },
                  "examples": [
                    "[\"https://raw.githubusercontent.com/breadboard-ai/breadboard/b5577943bdd0956bed3874244b34ea80f1589eaa/packages/breadboard-web/public/graphs/search-summarize.json\",{\"title\":\"The Calculator Board\",\"description\":\"A simple AI pattern that leans on the power of the LLMs to generate language to solve math problems.\",\"version\":\"0.0.2\",\"edges\":[{\"from\":\"compute\",\"to\":\"answer\",\"out\":\"*\",\"in\":\"\"},{\"from\":\"generator\",\"to\":\"compute\",\"out\":\"text\",\"in\":\"code\"},{\"from\":\"math-question\",\"to\":\"math-function\",\"out\":\"question\",\"in\":\"question\"},{\"from\":\"math-question\",\"to\":\"generator\",\"out\":\"generator\",\"in\":\"path\"},{\"from\":\"math-function\",\"to\":\"generator\",\"out\":\"prompt\",\"in\":\"text\"}],\"nodes\":[{\"id\":\"answer\",\"type\":\"output\",\"configuration\":{\"schema\":{\"type\":\"object\",\"properties\":{\"result\":{\"type\":\"string\",\"title\":\"Answer\",\"description\":\"The answer to the math problem\"}},\"required\":[\"text\"]}}},{\"id\":\"compute\",\"type\":\"runJavascript\",\"configuration\":{\"name\":\"compute\"}},{\"id\":\"generator\",\"type\":\"invoke\",\"configuration\":{}},{\"id\":\"math-question\",\"type\":\"input\",\"configuration\":{\"schema\":{\"type\":\"object\",\"properties\":{\"question\":{\"type\":\"string\",\"title\":\"Math problem\",\"description\":\"Ask a math question\",\"examples\":[\"What is the square root of pi?\"]},\"generator\":{\"type\":\"string\",\"title\":\"Generator\",\"description\":\"The URL of the generator to call\",\"default\":\"text-generator.json\"}},\"required\":[\"text\"]}}},{\"id\":\"math-function\",\"type\":\"promptTemplate\",\"configuration\":{\"template\":\"Translate the math problem below into a self-contained,\\nzero-argument JavaScript function named `compute` that can be executed\\nto provide the answer to the problem.\\n\\nDo not use any dependencies or libraries.\\n\\nMath Problem: {{question}}\\n\\nSolution:\"}}],\"graphs\":{}}]"
                  ],
                  "default": "[]"
                },
                "retry": {
                  "type": "number",
                  "title": "Retry Count",
                  "description": "How many times to retry in case of LLM error",
                  "default": "5"
                }
              },
              "required": [
                "instruction"
              ]
            }
          }
        },
        {
          "id": "formatFunctionDeclarations",
          "type": "runJavascript",
          "configuration": {
            "code": "const formatFunctionDeclarations = ({list})=>{const tools=[];const urlMap={};list.forEach(item=>{tools.push(item.function);const flags=item.flags;urlMap[item.function.name]={url:item.boardURL,flags}});return{tools,urlMap}};",
            "name": "formatFunctionDeclarations",
            "raw": true
          },
          "metadata": {
            "title": "Format Function Declarations",
            "description": "Formatting the function declarations"
          }
        },
        {
          "id": "invokeBoard",
          "type": "invoke",
          "configuration": {},
          "metadata": {
            "title": "Invoke Board",
            "description": "Invoking the board"
          }
        },
        {
          "id": "extractBoardResponse",
          "type": "runJavascript",
          "configuration": {
            "code": "const extractBoardResponse = inputs=>{const{schema,...response}=inputs;schema;return{response}};",
            "name": "extractBoardResponse",
            "raw": true
          },
          "metadata": {
            "title": "Format Board Response",
            "description": "Extracting the board response from the invocation"
          }
        },
        {
          "id": "replyToFunction",
          "type": "text",
          "configuration": {},
          "metadata": {
            "title": "Reply to Function",
            "description": "Using Gemini to reply to function results"
          }
        },
        {
          "id": "assembleContext",
          "type": "runJavascript",
          "configuration": {
            "code": "const assembleContext = ({context,generated})=>{if(!context)throw new Error(\"Context is required\");return{context:[...context,generated]}};",
            "name": "assembleContext",
            "raw": true
          },
          "metadata": {
            "title": "Assemble Context",
            "description": "Assembling the final context for the output"
          }
        },
        {
          "id": "turnBoardsToFunctions",
          "type": "map",
          "configuration": {
            "board": "#boardToFunction"
          },
          "metadata": {
            "title": "Turn Boards into Functions",
            "description": "Turning provided boards into functions"
          }
        },
        {
          "id": "functionOutput",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "context": {
                  "type": "string",
                  "title": "context"
                },
                "text": {
                  "type": "string",
                  "title": "Text",
                  "description": "The generated text"
                }
              }
            }
          },
          "metadata": {
            "title": "Function Call Output",
            "description": "Outputting the function call results"
          }
        }
      ],
      "graphs": {
        "boardToFunction": {
          "title": "Board to functions",
          "description": "Use this board to convert specified boards into function-calling signatures",
          "edges": [
            {
              "from": "fn-4",
              "to": "output-2",
              "out": "function",
              "in": "function"
            },
            {
              "from": "fn-4",
              "to": "output-2",
              "out": "board",
              "in": "boardURL"
            },
            {
              "from": "fn-4",
              "to": "output-2",
              "out": "flags",
              "in": "flags"
            },
            {
              "from": "curry-3",
              "to": "fn-4",
              "out": "board",
              "in": "board"
            },
            {
              "from": "input-1",
              "to": "curry-3",
              "out": "item",
              "in": "$board"
            },
            {
              "from": "input-1",
              "to": "curry-3",
              "out": "context",
              "in": "context"
            }
          ],
          "nodes": [
            {
              "id": "output-2",
              "type": "output",
              "configuration": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "function": {
                      "type": "string",
                      "title": "function"
                    },
                    "boardURL": {
                      "type": "string",
                      "title": "boardURL"
                    },
                    "flags": {
                      "type": "string",
                      "title": "flags"
                    }
                  }
                }
              }
            },
            {
              "id": "fn-4",
              "type": "runJavascript",
              "configuration": {
                "code": "const fn_4 = ({board:board2})=>{const b=board2;const inputs=b.nodes.filter(node=>node.type===\"input\");if(inputs.length===0){throw new Error(\"No inputs found\")}const outputs=b.nodes.filter(node=>node.type===\"output\");if(outputs.length===0){throw new Error(\"No outputs found\")}const inputSchema=inputs[0].configuration?.schema;if(!inputSchema){throw new Error(\"No input schema found\")}const outputSchema=outputs[0].configuration?.schema;if(!outputSchema){throw new Error(\"No output schema found\")}const properties={};const flags={};for(const key in inputSchema.properties){const property=inputSchema.properties[key];const isObject=property.type===\"object\";const isArray=property.type===\"array\";const type=isObject||isArray?\"string\":property.type;if(isObject&&property.behavior?.includes(\"llm-content\")){flags.inputLLMContent=key}else if(isArray&&property.items?.behavior?.includes(\"llm-content\")){flags.inputLLMContentArray=key;continue}const description2=property.description||property.title||\"text\";properties[key]={type,description:description2}}if(flags.inputLLMContentArray){const c=b.args?.context;if(c){b.args??={};b.args[flags.inputLLMContentArray]=c;delete b.args.context}}else{delete b.args?.context}for(const key in outputSchema.properties){const property=outputSchema.properties[key];const isObject=property.type===\"object\";const isArray=property.type===\"array\";if(isObject&&property.behavior?.includes(\"llm-content\")){flags.outputLLMContent=key}else if(isArray&&property.items?.behavior?.includes(\"llm-content\")){flags.outputLLMContentArray=key}}const name=b.title?.replace(/\\W/g,\"_\");const description=b.description;const parameters={type:\"object\",properties};return{function:{name,description,parameters},returns:outputSchema,flags,board:board2}};",
                "name": "fn_4",
                "raw": true
              },
              "metadata": {
                "title": "Get Function Signature from board"
              }
            },
            {
              "id": "curry-3",
              "type": "curry",
              "configuration": {}
            },
            {
              "id": "input-1",
              "type": "input",
              "configuration": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "item": {
                      "title": "board",
                      "behavior": [
                        "board"
                      ],
                      "description": "The board to curry. Can be a BoardCapability, a graph or a URL",
                      "type": "string"
                    },
                    "context": {
                      "type": "string",
                      "title": "context"
                    }
                  },
                  "required": [
                    "item",
                    "context"
                  ]
                }
              }
            }
          ],
          "graphs": {}
        }
      }
    },
    "worker": {
      "title": "Worker",
      "description": "The essential Agent building block",
      "version": "0.0.1",
      "edges": [
        {
          "from": "assembleContext",
          "to": "output-2",
          "out": "context",
          "in": "context"
        },
        {
          "from": "generate",
          "to": "assembleContext",
          "out": "context",
          "in": "generated"
        },
        {
          "from": "generate",
          "to": "output-2",
          "out": "text",
          "in": "text"
        },
        {
          "from": "buildContext",
          "to": "generate",
          "out": "context",
          "in": "context"
        },
        {
          "from": "buildContext",
          "to": "assembleContext",
          "out": "context",
          "in": "context"
        },
        {
          "from": "input-1",
          "to": "buildContext",
          "out": "context",
          "in": "context"
        },
        {
          "from": "input-1",
          "to": "buildContext",
          "out": "instruction",
          "in": "instruction"
        },
        {
          "from": "input-1",
          "to": "generate",
          "out": "stopSequences",
          "in": "stopSequences"
        }
      ],
      "nodes": [
        {
          "id": "output-2",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "context": {
                  "type": "string",
                  "title": "context"
                },
                "text": {
                  "type": "string",
                  "title": "Output",
                  "description": "Agent's output"
                }
              }
            }
          }
        },
        {
          "id": "assembleContext",
          "type": "runJavascript",
          "configuration": {
            "code": "const assembleContext = ({context,generated})=>{if(!context)throw new Error(\"Context is required\");return{context:[...context,generated]}};",
            "name": "assembleContext",
            "raw": true
          },
          "metadata": {
            "title": "Assemble Context",
            "description": "Assembling the context after generation"
          }
        },
        {
          "id": "generate",
          "type": "text",
          "configuration": {
            "text": "unused"
          },
          "metadata": {
            "title": "Generate",
            "description": "Using Gemini to generate worker output"
          }
        },
        {
          "id": "buildContext",
          "type": "runJavascript",
          "configuration": {
            "code": "const buildContext = ({context,instruction})=>{if(typeof context===\"string\"){context=[{role:\"user\",parts:[{text:context}]}]}const list=context||[];if(list.length>0){const last=list[list.length-1];if(last.role===\"user\"){last.parts.unshift({text:instruction});return{context:list}}}return{context:[...list,{role:\"user\",parts:[{text:instruction}]}]}};",
            "name": "buildContext",
            "raw": true
          },
          "metadata": {
            "title": "Build Context",
            "description": "Building the context for the worker"
          }
        },
        {
          "id": "input-1",
          "type": "input",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "context": {
                  "title": "Context",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "behavior": [
                      "llm-content"
                    ]
                  },
                  "examples": [
                    "the universe within us"
                  ]
                },
                "instruction": {
                  "title": "Instruction",
                  "format": "multiline",
                  "behavior": [
                    "config"
                  ],
                  "examples": [
                    "You are a brilliant poet who specializes in two-line rhyming poems.\nGiven any topic, you can quickly whip up a two-line rhyming poem about it.\nLook at the topic below and do your magic"
                  ],
                  "type": "string"
                },
                "stopSequences": {
                  "type": "array",
                  "title": "Stop Sequences",
                  "description": "An array of strings that will stop the output",
                  "default": "[]",
                  "items": {
                    "type": "object",
                    "behavior": [
                      "config"
                    ]
                  }
                }
              },
              "required": [
                "context",
                "instruction"
              ]
            }
          }
        }
      ],
      "graphs": {}
    },
    "looper": {
      "title": "Looper",
      "metadata": {
        "icon": "laps"
      },
      "description": "A worker whose job it is to repeat the same thing over and over, until some condition is met or the max count of repetitions is reached.",
      "version": "0.0.1",
      "edges": [
        {
          "from": "fn-7",
          "to": "fn-8",
          "out": "done",
          "in": "context"
        },
        {
          "from": "fn-7",
          "to": "output-2",
          "out": "context",
          "in": "loop"
        },
        {
          "from": "input-1",
          "to": "fn-3",
          "out": "context",
          "in": "context"
        },
        {
          "from": "input-1",
          "to": "fn-4",
          "out": "task",
          "in": "toAdd"
        },
        {
          "from": "input-1",
          "to": "fn-7",
          "out": "context",
          "in": "context"
        },
        {
          "from": "fn-3",
          "to": "fn-4",
          "out": "context",
          "in": "context"
        },
        {
          "from": "fn-3",
          "to": "fn-7",
          "out": "progress",
          "in": "progress"
        },
        {
          "from": "validateJson-6",
          "to": "fn-7",
          "out": "json",
          "in": "progress"
        },
        {
          "from": "fn-8",
          "to": "output-9",
          "out": "context",
          "in": "done"
        },
        {
          "from": "fn-4",
          "to": "text-5",
          "out": "context",
          "in": "context"
        },
        {
          "from": "text-5",
          "to": "validateJson-6",
          "out": "text",
          "in": "json"
        }
      ],
      "nodes": [
        {
          "id": "output-2",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "loop": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "behavior": [
                      "llm-content"
                    ]
                  },
                  "title": "Loop"
                }
              }
            }
          }
        },
        {
          "id": "fn-7",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_7 = ({context,progress})=>{const plans=Array.isArray(progress)?progress:[progress];const existing=Array.isArray(context)?context:[context];if(!plans||!plans.length){throw new Error(\"Plan is required for Looper to function.\")}try{const current=plans[0];if(current.done){return{done:existing}}const originalPlan=plans[plans.length-1];let max=originalPlan.max;const doneMarker=originalPlan.doneMarker;if(!max){const planItems=originalPlan.todo?.length;if(planItems){max=planItems+1}else{max=Infinity}}const contents=structuredClone(existing);const count=plans.length;if(count>=max){return{done:existing}}if(current.todo&&Array.isArray(current.todo)){const next=current.todo?.shift();if(!next){return{done:existing}}delete current.doneMarker;contents.push({role:\"$metadata\",type:\"looper\",data:{...current,next:next.task}});return{context:contents}}else if(doneMarker){contents.push({role:\"$metadata\",type:\"looper\",data:{doneMarker}});return{context:contents}}else if(max){const count2=plans.length;if(count2>=max){return{done:existing}}contents.push({role:\"$metadata\",type:\"looper\",data:{max}});return{context:contents}}return{done:existing}}catch(e){const error=e;throw new Error(`Invalid plan, unable to proceed: ${error.message}`)}};",
            "name": "fn_7",
            "raw": true
          },
          "metadata": {
            "title": "Read Plan"
          }
        },
        {
          "id": "input-1",
          "type": "input",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "context": {
                  "title": "Context in",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "behavior": [
                      "llm-content"
                    ]
                  },
                  "default": "[]",
                  "examples": [
                    "{\"parts\":[{\"text\":\"test\"}],\"role\":\"user\"}"
                  ],
                  "description": "Incoming conversation context"
                },
                "task": {
                  "title": "Task",
                  "default": "{}",
                  "description": "The task to be used for loop planning",
                  "type": "object",
                  "behavior": [
                    "llm-content",
                    "config"
                  ]
                }
              },
              "required": []
            }
          }
        },
        {
          "id": "fn-3",
          "type": "runJavascript",
          "configuration": {
            "forkOutputs": true,
            "code": "const fn_3 = ({context,forkOutputs})=>{const fork=forkOutputs;const existing=Array.isArray(context)?context:[context];const progress=[];for(let i=existing.length-1;i>=0;i--){const item=existing[i];if(item.role===\"$metadata\"&&item.type===\"looper\"){progress.push(item.data)}}if(fork){if(progress.length){return{progress}}else{return{context}}}else{return{context,progress}}};",
            "name": "fn_3",
            "raw": true
          },
          "metadata": {
            "title": "Read progress so far"
          }
        },
        {
          "id": "validateJson-6",
          "type": "validateJson",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "max": {
                  "type": "number",
                  "description": "Maximum iterations to make, optional. Default is infinity"
                },
                "todo": {
                  "type": "array",
                  "description": "Items in the plan, optional. Use this if the plan contains a definite, concrete list of items",
                  "items": {
                    "type": "object",
                    "description": "The object that represent an item in the plan",
                    "properties": {
                      "task": {
                        "type": "string",
                        "description": "The task description. Use action-oriented language, starting with a verb that fits the task"
                      }
                    }
                  }
                },
                "doneMarker": {
                  "type": "string",
                  "description": "The marker that will be used by others to signal completion of the job."
                },
                "error": {
                  "type": "string",
                  "description": "Describe the reason why the plan generation failed"
                }
              }
            }
          },
          "metadata": {
            "title": "Validate Plan",
            "description": "Validating JSON of the Plan"
          }
        },
        {
          "id": "fn-8",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_8 = ({context})=>{if(!context)throw new Error(\"Context is required\");const c=context;const result=c.filter(item=>item.role!==\"$metadata\");return{context:result}};",
            "name": "fn_8",
            "raw": true
          },
          "metadata": {
            "title": "Clean up",
            "description": "Cleaning up the metadata that was used for running loops"
          }
        },
        {
          "id": "fn-4",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_4 = ({context,toAdd})=>{if(!context)throw new Error(\"Context is required\");const existing=Array.isArray(context)?context:[context];const incoming=toAdd;if(!incoming.parts){const containsUserRole=existing.filter(item=>item.role!==\"model\"&&item.role!==\"$metadata\").length>0;if(!containsUserRole){return{context:[...existing,{role:\"user\",parts:[{text:\"Do your magic\"}]}]}}return{context:existing}}if(!incoming.role){incoming.role=\"user\"}const last=existing[existing.length-1];if(!last){return{context:[incoming]}}if(last.role!==incoming.role){return{context:[...existing,incoming]}}else{const result=structuredClone(existing);const index=result.length-1;result[index].parts.push(...incoming.parts);return{context:result}}};",
            "name": "fn_4",
            "raw": true
          },
          "metadata": {
            "title": "Add Task"
          }
        },
        {
          "id": "text-5",
          "type": "text",
          "configuration": {
            "systemInstruction": {
              "parts": [
                {
                  "text": "\nYou are to create a precise plan for a given job. This plan will be executed by others and your responsibility is to produce a plan that reflects the job. \n\nYour output must be a valid JSON of the following format:\n\n```json\n{\n  \"max\": \"number, optional. Specifies how many iterations to make. Useful when the job specifies the upper limit the number of items in the list.\",\n  \"todo\": [{\n    \"task\": \"string, The task description. Use action-oriented language, starting with a verb that fits the task.\"\n  }]\n  \"doneMarker\": \"string, optional. The marker that will be used by others to signal completion.\"\n  \"error\": \"string, optional. A description of why you're unable to create a plan\"\n}\n```\n\nThere are four kinds of jobs that you can make plans for. \n\n1) The indefinite job. These are useful when there is not a definite completion condition, and is usually formulated with words like \"indefinitely\" or \"forever\". In such cases, the plan will look like an object without a \"todo\" property, with \"max\" set to a very large number:\n\n```json\n{\n  \"max\": 100000000\n}\n```\n\n2) The step-by-step job. These are for situations when a distinct, known number of tasks can be discerned from the job. For example, when asked to write chapters of a book following an outline, there's a clear list of tasks that can be discerned (one \"Write <chapter title>\" per chapter). \n\nA plan for this kind of job will look like an object with \"todo\" items:\n\n```json\n{\n  \"todo\": [\n    { \"task\": \"<action-oriented description of task 1\" },\n    { \"task\": \"<action-oriented description of task 2\" },\n    { \"task\": \"<action-oriented description of task 3\" }\n  ]\n}\n```\nIf the job includes a limit on how many tasks to produce, use the \"max\" property to indicate that. For instance, if the job contains three items that can be discerned, but asks to only do two of them:\n\n```json\n{\n  \"max:\" 2,\n  \"todo\": [\n    { \"task\": \"<action-oriented description of task 1\" },\n    { \"task\": \"<action-oriented description of task 2\" },\n    { \"task\": \"<action-oriented description of task 3\" }\n  ]\n}\n```\n\n3) Just repeat the steps job. These jobs do not have a distinct tasks, but rather just a number of steps to repeat. In this case, omit the \"todo\" and just use \"max\" property:\n\n```json\n{\n  \"max\": 4\n}\n```\n\n4) The job where the completion is signaled by others. These are the types of jobs where the number of iterations or the exact steps are unknown, and the\ncompletion signal is issued by those who are executing the individual steps. In such cases, use the \"doneMarker\" property and use the marker specified:\n\n```json\n{\n  \"doneMarker\": \"<the marker that will be used to signal completion>\"\n}\n```\n\nCommon markers are \"##STOP##\" or \"##DONE##\", but could be different depending on a job. This type of the job is mutually exclusive with the step-by-step type, so the \"todo\" and \"doneMarker\" may never be specified together.\n\nWhen you are unable to create plan from the job, reply with:\n\n```json\n{\n  \"error\": \"<description of why you're unable to create a plan>\"\n}\n```\n\n"
                }
              ]
            },
            "responseMimeType": "application/json"
          },
          "metadata": {
            "title": "Generating Plan"
          }
        },
        {
          "id": "output-9",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "done": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "behavior": [
                      "llm-content"
                    ]
                  },
                  "title": "Context out"
                }
              }
            }
          },
          "metadata": {
            "title": "Exit"
          }
        }
      ],
      "graphs": {}
    },
    "joiner": {
      "title": "Joiner",
      "metadata": {
        "icon": "merge-type"
      },
      "description": "Joins two or more worker contexts into one. Great for combining results of multiple workers.",
      "version": "0.0.1",
      "edges": [
        {
          "from": "fn-4",
          "to": "output-5",
          "out": "context",
          "in": "context"
        },
        {
          "from": "input-3",
          "to": "fn-4",
          "out": "*",
          "in": ""
        },
        {
          "from": "input-1",
          "to": "fn-4",
          "out": "merge",
          "in": "merge"
        }
      ],
      "nodes": [
        {
          "id": "output-5",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "context": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "behavior": [
                      "llm-content"
                    ]
                  },
                  "title": "context"
                }
              }
            }
          },
          "metadata": {
            "title": "Output",
            "description": "Returning combined values"
          }
        },
        {
          "id": "fn-4",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_4 = ({merge,...inputs})=>{const entries=Object.entries(inputs).sort();if(merge){const context=[];const parts=[];for(const[,input]of entries){const c=asContextArray(input);let lastIndex=c.length-1;let last;do{last=c[lastIndex--]}while(lastIndex>=0&&last.role===\"$metadata\");if(last){parts.push(...last.parts)}}context.push({parts});return{context}}else{let mode;const[f,...rest]=entries;if(!f){return{context:[]}}const first=asContextArray(f[1]);const firstOpenSplits=scanForSplits(first);const preambleIndices=[];for(const[,input]of rest){const c=asContextArray(input);const hasOpenSplits=scanForSplits(c);if(hasOpenSplits){preambleIndices.push(hasOpenSplits[1])}}if(!firstOpenSplits){if(preambleIndices.length===0){mode=\"simple\"}else{mode=\"adhoc\"}}else{const preamblesMatch=preambleIndices.length>0&&preambleIndices.every(value=>value===firstOpenSplits[1]);if(preamblesMatch){mode=\"preamble\"}else{if(firstOpenSplits[1]===first.length-1){mode=\"single\"}else{mode=\"adhoc\"}}}const context=[];if(mode===\"adhoc\"){for(const[,input]of entries){const c=asContextArray(input);context.push(...c)}return{context}}else if(mode===\"simple\"){const splitId=Math.random().toString(36).substring(7);context.push({role:\"$metadata\",type:\"split\",data:{type:\"start\",id:splitId}});for(const[,input]of entries){const c=asContextArray(input);context.push(...c);context.push({role:\"$metadata\",type:\"split\",data:{type:\"next\",id:splitId}})}}else if(mode===\"preamble\"){const preambleIndex=firstOpenSplits?.[1]||0;const preamble=entries[0][1].slice(0,preambleIndex+1);context.push(...preamble);const splitId=preamble[preamble.length-1].data.id;for(const[,input]of entries){let c=asContextArray(input);if(preambleIndex>=0){c=c.slice(preambleIndex+1)}if(c.length){context.push(...c);context.push({role:\"$metadata\",type:\"split\",data:{type:\"next\",id:splitId}})}}}else if(mode===\"single\"){const splitId=first[first.length-1].data.id;context.push(...first);for(const[,input]of rest){const c=asContextArray(input);context.push(...c);context.push({role:\"$metadata\",type:\"split\",data:{type:\"next\",id:splitId}})}}const last=context[context.length-1];last.data.type=\"end\";return{context}}function asContextArray(input){return Array.isArray(input)?input:[input]}__name(asContextArray,\"asContextArray\");function scanForSplits(c){const stack=[];for(const[i,item]of c.entries()){if(item.role!==\"$metadata\")continue;if(item.type!==\"split\")continue;if(item.data.type===\"start\"){stack.push([item.data.id,i])}if(item.data.type===\"end\"){const[id]=stack.pop()||[];if(id!==item.data.id){console.warn(\"Split integrity error: mismatched split start/end markers. Start:\",id,\"End:\",item.data.id);return null}}}return stack.pop()||null}__name(scanForSplits,\"scanForSplits\")};",
            "name": "fn_4",
            "raw": true
          },
          "metadata": {
            "title": "Combine Context",
            "description": "Combining context into one"
          }
        },
        {
          "id": "input-3",
          "type": "input",
          "configuration": {},
          "metadata": {
            "title": "Input",
            "description": "Getting all the data"
          }
        },
        {
          "id": "input-1",
          "type": "input",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "merge": {
                  "type": "boolean",
                  "behavior": [
                    "config"
                  ],
                  "title": "Merge Contexts",
                  "default": "false",
                  "description": "Merge the last items of all incoming conversation into one."
                }
              },
              "required": []
            }
          }
        }
      ],
      "graphs": {}
    }
  }
}