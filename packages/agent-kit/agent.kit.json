{
  "title": "Agent Kit",
  "description": "A collection of nodes for building Agent-like experiences.",
  "version": "0.0.1",
  "url": "https://raw.githubusercontent.com/breadboard-ai/breadboard/main/packages/agent-kit/agent.kit.json",
  "nodes": {
    "human": {
      "title": "Human",
      "metadata": {
        "icon": "human"
      },
      "description": "A human in the loop. Use this node to insert a real person (user input) into your team of synthetic workers.",
      "version": "0.0.1",
      "edges": [
        {
          "from": "appendContext",
          "to": "output-2",
          "out": "context",
          "in": "context"
        },
        {
          "from": "input",
          "to": "fn-6",
          "out": "text",
          "in": "text"
        },
        {
          "from": "input",
          "to": "output-2",
          "out": "text",
          "in": "text"
        },
        {
          "from": "fn-6",
          "to": "output-7",
          "out": "again",
          "in": "again"
        },
        {
          "from": "fn-6",
          "to": "appendContext",
          "out": "context",
          "in": "context"
        },
        {
          "from": "fn-6",
          "to": "appendContext",
          "out": "text",
          "in": "text"
        },
        {
          "from": "createSchema",
          "to": "input",
          "out": "schema",
          "in": "schema"
        },
        {
          "from": "createSchema",
          "to": "fn-6",
          "out": "context",
          "in": "context"
        },
        {
          "from": "maybeOutputRouter",
          "to": "fn-3",
          "out": "context",
          "in": "context"
        },
        {
          "from": "maybeOutputRouter",
          "to": "createSchema",
          "out": "action",
          "in": "action"
        },
        {
          "from": "maybeOutputRouter",
          "to": "output-5",
          "out": "feedback",
          "in": "feedback"
        },
        {
          "from": "maybeOutputRouter",
          "to": "output",
          "out": "output",
          "in": "output"
        },
        {
          "from": "maybeOutputRouter",
          "to": "fn-6",
          "out": "action",
          "in": "action"
        },
        {
          "from": "input-1",
          "to": "maybeOutputRouter",
          "out": "context",
          "in": "context"
        },
        {
          "from": "input-1",
          "to": "createSchema",
          "out": "title",
          "in": "title"
        },
        {
          "from": "input-1",
          "to": "createSchema",
          "out": "description",
          "in": "description"
        },
        {
          "from": "fn-3",
          "to": "output-4",
          "out": "done",
          "in": "context"
        },
        {
          "from": "fn-3",
          "to": "createSchema",
          "out": "context",
          "in": "context"
        }
      ],
      "nodes": [
        {
          "id": "output-2",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "context": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "behavior": [
                      "llm-content"
                    ]
                  },
                  "title": "Context out"
                },
                "text": {
                  "title": "Text",
                  "behavior": [
                    "deprecated"
                  ],
                  "type": "string"
                }
              }
            }
          }
        },
        {
          "id": "appendContext",
          "type": "runJavascript",
          "configuration": {
            "code": "const appendContext = ({context,text})=>{if(!text)return{context};return{context:[...context||[],{role:\"user\",parts:[{text}]}]}};",
            "name": "appendContext",
            "raw": true
          },
          "metadata": {
            "title": "Append Context",
            "description": "Appending user input to the conversation context"
          }
        },
        {
          "id": "input",
          "type": "input",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "text": {
                  "title": "Text",
                  "behavior": [
                    "deprecated"
                  ],
                  "type": "string"
                }
              },
              "required": [
                "text"
              ]
            }
          },
          "metadata": {
            "title": "Input",
            "description": "Asking user for input"
          }
        },
        {
          "id": "fn-6",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_6 = ({text,context,action})=>{const a=action;if(a?.action===\"vote\"){if(text===\"No\"){context.pop();return{text,again:context}}const c=structuredClone(context);const lastItem=c[c.length-1];const parts=lastItem.parts;const t=Array.isArray(parts)?parts.map(item=>item.text).join(\"/n\"):parts.text;const output=t;const data=JSON.parse(output);delete data[\"voteRequest\"];lastItem.parts=[{text:JSON.stringify(data)}];return{text:\"\",context:c}}return{text,context}};",
            "name": "fn_6",
            "raw": true
          },
          "metadata": {
            "title": "Action Recognizer",
            "description": "Recognizing the action that user has taken"
          }
        },
        {
          "id": "createSchema",
          "type": "runJavascript",
          "configuration": {
            "code": "const createSchema = ({title,action,description,context})=>{const text={title,description,type:\"string\",behavior:[\"transient\"]};const schema2={type:\"object\",properties:{text}};if(action?.action==\"vote\"){text.title=action.title;text.enum=[\"Yes\",\"No\"]}return{schema:schema2,context}};",
            "name": "createSchema",
            "raw": true
          },
          "metadata": {
            "title": "Create Schema",
            "description": "Creating a schema for user input"
          }
        },
        {
          "id": "maybeOutputRouter",
          "type": "runJavascript",
          "configuration": {
            "code": "const maybeOutputRouter = ({context})=>{const action={action:\"none\"};if(Array.isArray(context)&&context.length>0){let lastItem=context[context.length-1];if(lastItem.role===\"$metadata\"){lastItem=context[context.length-2]}if(lastItem&&lastItem.role!==\"user\"){const output=lastItem;try{if(\"parts\"in output&&\"text\"in output.parts[0]){const json=output.parts[0]?.text;const data=JSON.parse(json);if(data.voteRequest){const feedback=structuredClone(data);delete feedback[\"voteRequest\"];const action2={action:\"vote\",title:data.voteRequest};return{feedback,action:action2,context}}}}catch{}return{output,action,context}}}return{context,action}};",
            "name": "maybeOutputRouter",
            "raw": true
          },
          "metadata": {
            "title": "Maybe Output",
            "description": "Checking if the last message was from the model"
          }
        },
        {
          "id": "output-7",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "again": {
                  "behavior": [
                    "deprecated"
                  ],
                  "type": "string",
                  "title": "again"
                }
              }
            }
          },
          "metadata": {
            "title": "Rejection",
            "description": "Rejecting latest agent work per user action"
          }
        },
        {
          "id": "input-1",
          "type": "input",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "context": {
                  "title": "Context in",
                  "description": "Incoming conversation context",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "behavior": [
                      "llm-content"
                    ]
                  },
                  "examples": [
                    "[{\"parts\":[{\"text\":\"{\\\"adCampaign\\\":{\\\"headlines\\\":[\\\"Breadboard: AI Playground\\\",\\\"Exp. AI Patterns\\\",\\\"Rapid Prototyping\\\",\\\"AI Power, Gemini\\\",\\\"Integrate AI Seamlessly\\\",\\\"Create Graphs, Prompts\\\",\\\"Accessible AI\\\",\\\"Breadboard: Dev's AI Kit\\\",\\\"Supercharge Dev, Breadboard\\\",\\\"Accelerate Innovation\\\",\\\"Revolutionize Dev, AI\\\",\\\"Breadboard: AI, Ingenuity\\\",\\\"Elevate Projects, Breadboard\\\",\\\"Unlock AI Power, Breadboard\\\"],\\\"descriptions\\\":[\\\"Breadboard: Play, experiment, prototype with AI. Integrate AI with Gemini.\\\",\\\"Stunning graphs with prompts. Accessible AI for devs.\\\",\\\"Accelerate innovation with Breadboard. Experiment with AI risk-free.\\\",\\\"Elevate projects with Breadboard AI. Integrate AI seamlessly.\\\"]},\\\"voteRequest\\\":\\\"Does this ad campaign seem ok to you?\\\"}\"}],\"role\":\"model\"}]"
                  ],
                  "default": "[]"
                },
                "title": {
                  "title": "Title",
                  "description": "The user label",
                  "behavior": [
                    "config"
                  ],
                  "default": "User",
                  "type": "string"
                },
                "description": {
                  "title": "Description",
                  "description": "The user's input",
                  "behavior": [
                    "config"
                  ],
                  "default": "A request or response",
                  "type": "string"
                }
              },
              "required": []
            }
          }
        },
        {
          "id": "fn-3",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_3 = ({context})=>{if(!context)throw new Error(\"Context is required\");const c=context;let done=false;for(let i=0;i<c.length;++i){const item=c[i];if(item.role===\"$metadata\"){const plan=item.data;if(plan.done){done=true;break}}}if(done){return{done:context}}else{return{context}}};",
            "name": "fn_3",
            "raw": true
          },
          "metadata": {
            "title": "Done Check",
            "description": "Checking to see if we can skip work altogether"
          }
        },
        {
          "id": "output-5",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "behavior": [
                "bubble"
              ],
              "properties": {
                "feedback": {
                  "type": "string",
                  "title": "Feedback",
                  "description": "The feedback to display"
                }
              }
            }
          },
          "metadata": {
            "title": "Feedback",
            "description": "Displaying the output to user with feedback"
          }
        },
        {
          "id": "output",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "behavior": [
                "bubble"
              ],
              "properties": {
                "output": {
                  "type": "object",
                  "behavior": [
                    "llm-content"
                  ],
                  "title": "Output",
                  "description": "The output to display"
                }
              }
            }
          },
          "metadata": {
            "title": "Output",
            "description": "Displaying the output the user."
          }
        },
        {
          "id": "output-4",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "context": {
                  "title": "Context out",
                  "type": "string"
                }
              }
            }
          },
          "metadata": {
            "title": "Done",
            "description": "Skipping because we're done"
          }
        }
      ],
      "graphs": {}
    },
    "repeater": {
      "title": "Repeater",
      "description": "A worker whose job it is to repeat the same thing over and over, until some condition is met or the max count of repetitions is reached.",
      "version": "0.0.1",
      "edges": [
        {
          "from": "counter",
          "to": "invokeAgent",
          "out": "continue",
          "in": "context"
        },
        {
          "from": "counter",
          "to": "counter",
          "out": "count",
          "in": "count"
        },
        {
          "from": "counter",
          "to": "output-2",
          "out": "stop",
          "in": "context"
        },
        {
          "from": "invokeAgent",
          "to": "exit",
          "out": "exit",
          "in": "context"
        },
        {
          "from": "invokeAgent",
          "to": "counter",
          "out": "context",
          "in": "context"
        },
        {
          "from": "input-1",
          "to": "invokeAgent",
          "out": "worker",
          "in": "$board",
          "constant": true
        },
        {
          "from": "input-1",
          "to": "invokeAgent",
          "out": "context",
          "in": "context"
        },
        {
          "from": "input-1",
          "to": "counter",
          "out": "max",
          "in": "count"
        }
      ],
      "nodes": [
        {
          "id": "output-2",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "context": {
                  "type": "string",
                  "title": "context"
                }
              }
            }
          }
        },
        {
          "id": "counter",
          "type": "runJavascript",
          "configuration": {
            "code": "const counter = ({context,count})=>{const num=count-1;if(num!=0){return{continue:context,count:num}}return{stop:context}};",
            "name": "counter",
            "raw": true
          },
          "metadata": {
            "title": "Counter",
            "description": "Counting the number of repetitions"
          }
        },
        {
          "id": "invokeAgent",
          "type": "invoke",
          "configuration": {},
          "metadata": {
            "title": "Invoke Worker",
            "description": "Invoking the worker"
          }
        },
        {
          "id": "input-1",
          "type": "input",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "worker": {
                  "type": "object",
                  "properties": {},
                  "required": [],
                  "additionalProperties": false,
                  "title": "Worker",
                  "description": "Worker to repeat",
                  "behavior": [
                    "board"
                  ]
                },
                "context": {
                  "title": "Context",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "format": "multiline",
                    "behavior": [
                      "llm-content"
                    ]
                  },
                  "default": "[]",
                  "description": "Initial conversation context"
                },
                "max": {
                  "title": "Max",
                  "description": "The maximum number of repetitions to make (set to -1 to go infinitely)",
                  "type": "number",
                  "default": "-1",
                  "examples": [
                    "3"
                  ]
                }
              },
              "required": [
                "worker"
              ]
            }
          }
        },
        {
          "id": "exit",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "context": {
                  "type": "string",
                  "title": "context"
                }
              }
            }
          },
          "metadata": {
            "title": "Exit",
            "description": "Exiting early from the repeater"
          }
        }
      ],
      "graphs": {}
    },
    "structuredWorker": {
      "title": "Structured Worker",
      "description": "A worker who outputs structure data (JSON) provided a schema.",
      "version": "0.0.1",
      "edges": [
        {
          "from": "assembleContext",
          "to": "output-2",
          "out": "context",
          "in": "context"
        },
        {
          "from": "validate",
          "to": "count",
          "out": "$error",
          "in": "error"
        },
        {
          "from": "validate",
          "to": "errorOutput",
          "out": "$error",
          "in": "$error"
        },
        {
          "from": "validate",
          "to": "assembleContext",
          "out": "json",
          "in": "json"
        },
        {
          "from": "validate",
          "to": "output-2",
          "out": "json",
          "in": "json"
        },
        {
          "from": "buildContext",
          "to": "count",
          "out": "context",
          "in": "context",
          "constant": true
        },
        {
          "from": "buildContext",
          "to": "assembleContext",
          "out": "context",
          "in": "context"
        },
        {
          "from": "generate",
          "to": "validate",
          "out": "text",
          "in": "json"
        },
        {
          "from": "input-1",
          "to": "schemish",
          "out": "schema",
          "in": "schema"
        },
        {
          "from": "input-1",
          "to": "buildContext",
          "out": "context",
          "in": "context"
        },
        {
          "from": "input-1",
          "to": "buildContext",
          "out": "instruction",
          "in": "instruction"
        },
        {
          "from": "input-1",
          "to": "validate",
          "out": "schema",
          "in": "schema",
          "constant": true
        },
        {
          "from": "count",
          "to": "count",
          "out": "count",
          "in": "count"
        },
        {
          "from": "count",
          "to": "generate",
          "out": "continue",
          "in": "context"
        },
        {
          "from": "count",
          "to": "errorOutput",
          "out": "stop",
          "in": "context"
        },
        {
          "from": "format",
          "to": "buildContext",
          "out": "prompt",
          "in": "format"
        },
        {
          "from": "schemish",
          "to": "format",
          "out": "schemish",
          "in": "schemish"
        },
        {
          "from": "initialValues",
          "to": "count",
          "out": "count",
          "in": "count"
        },
        {
          "from": "initialValues",
          "to": "count",
          "out": "error",
          "in": "error"
        }
      ],
      "nodes": [
        {
          "id": "output-2",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "context": {
                  "type": "string",
                  "title": "context"
                },
                "json": {
                  "title": "json",
                  "description": "The validated JSON.",
                  "type": "string"
                }
              }
            }
          }
        },
        {
          "id": "assembleContext",
          "type": "runJavascript",
          "configuration": {
            "code": "const assembleContext = ({context,json:json2})=>{if(!context)throw new Error(\"Context is required\");return{context:[...context,{role:\"model\",parts:{text:JSON.stringify(json2)}}]}};",
            "name": "assembleContext",
            "raw": true
          },
          "metadata": {
            "title": "Assemble Context",
            "description": "Assembling the context for the agent"
          }
        },
        {
          "id": "validate",
          "type": "validateJson",
          "configuration": {},
          "metadata": {
            "title": "Validate JSON",
            "logLevel": "info",
            "description": "Checking my work"
          }
        },
        {
          "id": "buildContext",
          "type": "runJavascript",
          "configuration": {
            "code": "const buildContext = ({context,format,instruction})=>{if(!Array.isArray(context)){const text=typeof context===\"string\"?context:JSON.stringify(context);context=[{role:\"user\",parts:[{text}]}]}const list=context||[];if(list.length>0){const last=list[list.length-1];if(last.role===\"user\"){last.parts.unshift({text:instruction},{text:format});return{context:list}}}return{context:[...list,{role:\"user\",parts:[{text:instruction},{text:format}]}]}};",
            "name": "buildContext",
            "raw": true
          },
          "metadata": {
            "title": "Build Context",
            "description": "Building the context for the agent"
          }
        },
        {
          "id": "generate",
          "type": "text",
          "configuration": {
            "text": "unused"
          },
          "metadata": {
            "title": "Generate",
            "logLevel": "info",
            "description": "Generating an answer"
          }
        },
        {
          "id": "input-1",
          "type": "input",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "schema": {
                  "title": "Schema",
                  "description": "The schema to convert to schemish.",
                  "type": "object",
                  "examples": [
                    "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"poems\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"inspiration\": {\n            \"type\": \"string\",\n            \"description\": \"The inspiration behind the poem\"\n          },\n          \"poem\": {\n            \"type\": \"string\",\n            \"description\": \"The poem itself\"\n          }\n        }\n      }\n    }\n  }\n}"
                  ],
                  "behavior": [
                    "json-schema",
                    "config"
                  ],
                  "default": "{}"
                },
                "context": {
                  "title": "Context",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "behavior": [
                      "llm-content"
                    ]
                  },
                  "default": "[]",
                  "examples": [
                    "the universe within us"
                  ]
                },
                "instruction": {
                  "title": "Instruction",
                  "behavior": [
                    "config"
                  ],
                  "format": "multiline",
                  "examples": [
                    "You are a brilliant poet who specializes in two-line rhyming poems.\nGiven any topic, you can quickly whip up three two-line rhyming poems about it.\nLook at the topic below and do your magic"
                  ],
                  "type": "string"
                }
              },
              "required": [
                "instruction"
              ]
            }
          }
        },
        {
          "id": "count",
          "type": "runJavascript",
          "configuration": {
            "code": "const count = ({context,error,count})=>{const num=count-1;if(num!=0){return{continue:context,count:num}}return{stop:error}};",
            "name": "count",
            "raw": true
          },
          "metadata": {
            "title": "Counter",
            "description": "Counting the JSON healing iteration"
          }
        },
        {
          "id": "errorOutput",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "$error": {
                  "title": "$error",
                  "description": "The error if the JSON is invalid.",
                  "type": "object",
                  "properties": {
                    "kind": {
                      "type": "string",
                      "enum": [
                        "error"
                      ]
                    },
                    "error": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string",
                          "enum": [
                            "parsing",
                            "validation"
                          ]
                        },
                        "message": {
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "context": {
                  "type": "string",
                  "title": "context"
                }
              }
            }
          },
          "metadata": {
            "title": "Error Output",
            "description": "Displaying error output, giving up on JSON healing"
          }
        },
        {
          "id": "format",
          "type": "promptTemplate",
          "configuration": {
            "template": "Reply as valid JSON of the following format:\n\n```json\n{{schemish}}\n```\n"
          },
          "metadata": {
            "title": "Reply Structure Formatter",
            "description": "Formatting the reply structure for the agent."
          }
        },
        {
          "id": "schemish",
          "type": "schemish",
          "configuration": {},
          "metadata": {
            "title": "Schemish",
            "description": "Converting JSON schema to a more compact format"
          }
        },
        {
          "id": "initialValues",
          "type": "passthrough",
          "configuration": {
            "count": 5,
            "error": "stub"
          },
          "metadata": {
            "title": "Initial Values",
            "description": "Populating initial values for the counter"
          }
        }
      ],
      "graphs": {}
    },
    "specialist": {
      "title": "Specialist",
      "metadata": {
        "icon": "smart-toy"
      },
      "description": "All-in-one worker. A work in progress, incorporates all the learnings from making previous workers.",
      "edges": [
        {
          "from": "fn-10",
          "to": "output-2",
          "out": "context",
          "in": "out"
        },
        {
          "from": "fn-5",
          "to": "text-6",
          "out": "context",
          "in": "context"
        },
        {
          "from": "fn-5",
          "to": "fn-10",
          "out": "context",
          "in": "context"
        },
        {
          "from": "router",
          "to": "assembleBoardInvoke",
          "out": "context",
          "in": "context"
        },
        {
          "from": "router",
          "to": "assembleBoardInvoke",
          "out": "functionCall",
          "in": "functionCall"
        },
        {
          "from": "router",
          "to": "fn-10",
          "out": "context",
          "in": "generated"
        },
        {
          "from": "router",
          "to": "fn-10",
          "out": "text",
          "in": "text"
        },
        {
          "from": "fn-3",
          "to": "fn-5",
          "out": "context",
          "in": "context"
        },
        {
          "from": "fn-3",
          "to": "fn-8",
          "out": "context",
          "in": "context"
        },
        {
          "from": "fn-4",
          "to": "fn-5",
          "out": "progress",
          "in": "progress"
        },
        {
          "from": "text-6",
          "to": "router",
          "out": "context",
          "in": "context"
        },
        {
          "from": "assembleBoardInvoke",
          "to": "invokeBoard",
          "out": "*",
          "in": ""
        },
        {
          "from": "input-1",
          "to": "fn-3",
          "out": "in",
          "in": "context"
        },
        {
          "from": "input-1",
          "to": "fn-3",
          "out": "task",
          "in": "toAdd"
        },
        {
          "from": "input-1",
          "to": "fn-4",
          "out": "in",
          "in": "context"
        },
        {
          "from": "input-1",
          "to": "turnBoardsToFunctions",
          "out": "tools",
          "in": "list"
        },
        {
          "from": "input-1",
          "to": "text-6",
          "out": "persona",
          "in": "systemInstruction"
        },
        {
          "from": "fn-8",
          "to": "output-9",
          "out": "context",
          "in": "out"
        },
        {
          "from": "formatFunctionDeclarations",
          "to": "text-6",
          "out": "tools",
          "in": "tools"
        },
        {
          "from": "formatFunctionDeclarations",
          "to": "assembleBoardInvoke",
          "out": "urlMap",
          "in": "urlMap"
        },
        {
          "from": "invokeBoard",
          "to": "fn-7",
          "out": "*",
          "in": ""
        },
        {
          "from": "turnBoardsToFunctions",
          "to": "formatFunctionDeclarations",
          "out": "list",
          "in": "list"
        },
        {
          "from": "fn-7",
          "to": "fn-8",
          "out": "response",
          "in": "toAdd"
        }
      ],
      "nodes": [
        {
          "id": "output-2",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "out": {
                  "title": "Context out",
                  "type": "string"
                }
              }
            }
          }
        },
        {
          "id": "fn-10",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_10 = ({context,generated})=>{if(!context)throw new Error(\"Context is required\");if(!generated)throw new Error(\"Generated is required\");const c=context;const g=generated;let doneMarker=null;for(let i=0;i<c.length;++i){const item=c[i];if(item.role===\"$metadata\"){const plan=item.data;if(plan.doneMarker){doneMarker=plan.doneMarker;break}}}if(!doneMarker){return{context:[...c,g]}}let containsMarkers=false;for(let i=0;i<g.parts.length;++i){const part=g.parts[i];if(\"text\"in part&&part.text.includes(doneMarker)){containsMarkers=true;part.text=part.text.replaceAll(doneMarker,\"\").trim();break}}if(!containsMarkers){return{context:[...c,g]}}const metadata={role:\"$metadata\",data:{type:\"looper\",done:true}};return{context:[...c,g,metadata]}};",
            "name": "fn_10",
            "raw": true
          },
          "metadata": {
            "title": "Done Check",
            "description": "Checking for the 'Done' marker"
          }
        },
        {
          "id": "fn-5",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_5 = ({context,progress})=>{const contents=Array.isArray(context)?context:[context];const plans=Array.isArray(progress)?progress:[progress];const last=plans[0];if(!last||!last.next){return{context}}contents.push({role:\"user\",parts:[{text:last.next}]});return{context:contents}};",
            "name": "fn_5",
            "raw": true
          },
          "metadata": {
            "title": "Add Looper Task",
            "description": "If there is a pending Looper task, add it."
          }
        },
        {
          "id": "router",
          "type": "runJavascript",
          "configuration": {
            "code": "const router = ({context})=>{if(!context)throw new Error(\"Context is a required input\");const item=context;const functionCallPart=item.parts.find(part=>\"functionCall\"in part);if(!functionCallPart){const textPart=item.parts.find(part=>\"text\"in part);if(!textPart)throw new Error(\"No text or function call found in context\");return{context,text:textPart.text}}return{context,functionCall:functionCallPart.functionCall}};",
            "name": "router",
            "raw": true
          },
          "metadata": {
            "title": "Router",
            "description": "Routing to either function call invocation or text reply"
          }
        },
        {
          "id": "fn-3",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_3 = ({context,toAdd})=>{if(!context)throw new Error(\"Context is required\");const existing=Array.isArray(context)?context:[context];const incoming=structuredClone(toAdd);if(!incoming.parts){const containsUserRole=existing.filter(item=>item.role!==\"model\"&&item.role!==\"$metadata\").length>0;if(!containsUserRole){return{context:[...existing,{role:\"user\",parts:[{text:\"Do your magic\"}]}]}}return{context:existing}}if(!incoming.role){incoming.role=\"user\"}const last=existing[existing.length-1];if(!last){return{context:[incoming]}}if(last.role!==incoming.role){return{context:[...existing,incoming]}}else{const result=structuredClone(existing);const index=result.length-1;result[index].parts.push(...incoming.parts);return{context:result}}};",
            "name": "fn_3",
            "raw": true
          },
          "metadata": {
            "title": "Add Task",
            "description": "Adding task to the prompt."
          }
        },
        {
          "id": "fn-4",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_4 = ({context,forkOutputs})=>{const fork=forkOutputs;const existing=Array.isArray(context)?context:[context];const progress=[];for(let i=existing.length-1;i>=0;i--){const item=existing[i];if(item.role===\"$metadata\"){progress.push(item.data)}}if(fork){if(progress.length){return{progress}}else{return{context}}}else{return{context,progress}}};",
            "name": "fn_4",
            "raw": true
          },
          "metadata": {
            "title": "Read Progress so far"
          }
        },
        {
          "id": "text-6",
          "type": "text",
          "configuration": {},
          "metadata": {
            "title": "Gemini API Call",
            "description": "Applying Gemini to do work"
          }
        },
        {
          "id": "assembleBoardInvoke",
          "type": "runJavascript",
          "configuration": {
            "code": "const assembleBoardInvoke = ({functionCall,urlMap})=>{if(!functionCall)throw new Error(\"Function call is a required input\");if(!urlMap)throw new Error(\"URL map is a required input\");const call=functionCall;const $board=urlMap[call.name];const generator=\"https://raw.githubusercontent.com/breadboard-ai/breadboard/05136f811e443dd931a2a2a40ff5a3f388d5ce75/packages/breadboard-web/public/graphs/gemini-generator.json\";return{$board,generator,...call.args}};",
            "name": "assembleBoardInvoke",
            "raw": true
          },
          "metadata": {
            "title": "Assemble Tool Invoke",
            "description": "Assembling the tool invocation based on Gemini response"
          }
        },
        {
          "id": "input-1",
          "type": "input",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "in": {
                  "title": "Context in",
                  "description": "Incoming conversation context",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "behavior": [
                      "llm-content"
                    ]
                  },
                  "examples": [
                    "[\n  {\n    \"role\": \"user\",\n    \"parts\": [\n      {\n        \"text\": \"\\nbook description: This book will be about breadboards and how awesome they are\\nchapter target: 10\\npage target: 400\\nfiction genre: space opera\\nsetting: the planet where there are no breadboards\\nstory arc: A girl named Aurora invents a breadboard on the planet where breadboards are strictly forbidden. Through struggles and determination, and with the help of trusted friends, Aurora overcomes many challenges and changes the whole planet for the better. \\ntonality: futuristic struggle, but optimistic\\nworking title: Aurora\\n\"\n      }\n    ]\n  }\n]"
                  ]
                },
                "task": {
                  "title": "Task",
                  "description": "(Optional) Provide a specific task with clear instructions for the worker to complete using the conversation context",
                  "type": "object",
                  "default": "{}",
                  "behavior": [
                    "llm-content",
                    "config"
                  ],
                  "examples": [
                    "{\n  \"parts\": [\n    {\n      \"text\": \"\\nWrite an outline for a novel, following the provided specs.\\n\"\n    }\n  ]\n}"
                  ]
                },
                "tools": {
                  "title": "Tools",
                  "type": "array",
                  "description": "(Optional) Add tools to this list for the worker to use when needed",
                  "items": {
                    "type": "object",
                    "behavior": [
                      "board",
                      "config"
                    ]
                  },
                  "default": "[]"
                },
                "persona": {
                  "type": "object",
                  "title": "Persona",
                  "description": "Describe the worker's skills, capabilities, mindset, and thinking process",
                  "default": "",
                  "examples": [
                    "{\n  \"parts\": [\n    {\n      \"text\": \"\\nYou are a famous author.  You are writing a novel.\\n\\nYour well-established process starts with collecting the book description, chapter target, page target, fiction genre, setting, story arc, tonality and the working title.\\n\\nThen, your first step is to write a detailed outline for the novel.  You keep the page target in mind for the finished novel, so your outline typically contains contain key bullets for the story arc across the chapters. You usually create a part of the outline for each chapter. You also keep in mind that the outline must cover at least the target number of chapters.\\n\\nYou are very creative and you pride yourself in adding interesting twists and unexpected turns of the story, something that keeps the reader glued to your book.\\n\"\n    }\n  ]\n}"
                  ],
                  "behavior": [
                    "llm-content",
                    "config"
                  ]
                }
              },
              "required": [
                "in",
                "persona"
              ]
            }
          }
        },
        {
          "id": "fn-8",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_8 = ({context,toAdd})=>{if(!context)throw new Error(\"Context is required\");const existing=Array.isArray(context)?context:[context];const incoming=structuredClone(toAdd);if(!incoming.parts){const containsUserRole=existing.filter(item=>item.role!==\"model\"&&item.role!==\"$metadata\").length>0;if(!containsUserRole){return{context:[...existing,{role:\"user\",parts:[{text:\"Do your magic\"}]}]}}return{context:existing}}if(!incoming.role){incoming.role=\"user\"}const last=existing[existing.length-1];if(!last){return{context:[incoming]}}if(last.role!==incoming.role){return{context:[...existing,incoming]}}else{const result=structuredClone(existing);const index=result.length-1;result[index].parts.push(...incoming.parts);return{context:result}}};",
            "name": "fn_8",
            "raw": true
          },
          "metadata": {
            "title": "Add Tool Response",
            "description": "Adding tool response to context"
          }
        },
        {
          "id": "formatFunctionDeclarations",
          "type": "runJavascript",
          "configuration": {
            "code": "const formatFunctionDeclarations = ({list})=>{const tools=[];const urlMap={};list.forEach(item=>{tools.push(item.function);urlMap[item.function.name]=item.boardURL});return{tools,urlMap}};",
            "name": "formatFunctionDeclarations",
            "raw": true
          },
          "metadata": {
            "title": "Format Function Declarations",
            "description": "Formatting the function declarations"
          }
        },
        {
          "id": "invokeBoard",
          "type": "invoke",
          "configuration": {},
          "metadata": {
            "title": "Invoke Tool",
            "description": "Invoking the board"
          }
        },
        {
          "id": "turnBoardsToFunctions",
          "type": "map",
          "configuration": {
            "board": "#boardToFunction"
          },
          "metadata": {
            "title": "Turn Boards into Functions",
            "description": "Turning provided boards into functions"
          }
        },
        {
          "id": "fn-7",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_7 = inputs=>{for(const key in inputs){const input=inputs[key];if(\"content\"in input){const content=input.content;if(content.parts&&Array.isArray(content.parts)){content.role=\"tool\";return{response:content}}}}const text=JSON.stringify(inputs);return{response:{parts:[{text}],role:\"tool\"}}};",
            "name": "fn_7",
            "raw": true
          },
          "metadata": {
            "title": "Format Tool Response",
            "description": "Formatting tool response"
          }
        },
        {
          "id": "output-9",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "out": {
                  "title": "Context out",
                  "type": "string"
                }
              }
            }
          },
          "metadata": {
            "title": "Tool Output",
            "description": "Return tool results as output"
          }
        }
      ],
      "graphs": {
        "boardToFunction": {
          "title": "Board to functions",
          "description": "Use this board to convert specified boards into function-calling signatures",
          "edges": [
            {
              "from": "getFunctionSignature",
              "to": "output-2",
              "out": "function",
              "in": "function"
            },
            {
              "from": "input-1",
              "to": "curry-3",
              "out": "item",
              "in": "$board"
            },
            {
              "from": "input-1",
              "to": "output-2",
              "out": "item",
              "in": "boardURL"
            },
            {
              "from": "curry-3",
              "to": "getFunctionSignature",
              "out": "board",
              "in": "json"
            }
          ],
          "nodes": [
            {
              "id": "output-2",
              "type": "output",
              "configuration": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "function": {
                      "type": [
                        "array",
                        "boolean",
                        "null",
                        "number",
                        "object",
                        "string"
                      ],
                      "title": "function"
                    },
                    "boardURL": {
                      "type": "string",
                      "title": "boardURL"
                    }
                  }
                }
              }
            },
            {
              "id": "getFunctionSignature",
              "type": "jsonata",
              "configuration": {
                "expression": "\n      (\n        $adjustType := function ($type) {\n            $type = \"object\" or $type = \"array\" ? \"string\" : $type\n        };\n\n        {\n        \"function\": {\n            \"name\": $replace(title, /\\W/, \"_\"),\n            \"description\": description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": nodes[type=\"input\"][0].configuration.schema.properties ~> $each(function($v, $k) {\n                { $k: {\n                    \"type\": $v.type ~> $adjustType,\n                    \"description\": $v.description\n                } }\n                }) ~> $merge\n            }\n        },\n        \"returns\": nodes[type=\"output\"][0].configuration.schema ~> | ** | {}, 'title' |\n        }\n    )",
                "raw": true
              }
            },
            {
              "id": "input-1",
              "type": "input",
              "configuration": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "item": {
                      "title": "board",
                      "behavior": [
                        "board"
                      ],
                      "description": "The board to curry. Can be a BoardCapability, a graph or a URL",
                      "type": "string"
                    }
                  },
                  "required": [
                    "item"
                  ]
                }
              }
            },
            {
              "id": "curry-3",
              "type": "curry",
              "configuration": {}
            }
          ],
          "graphs": {}
        }
      }
    },
    "toolWorker": {
      "title": "Tool Worker",
      "description": "A worker that can use tools to accomplish tasks.",
      "version": "0.0.1",
      "metadata": {
        "deprecated": true
      },
      "edges": [
        {
          "from": "fn-3",
          "to": "output-2",
          "out": "context",
          "in": "context"
        },
        {
          "from": "router",
          "to": "assembleBoardInvoke",
          "out": "context",
          "in": "context"
        },
        {
          "from": "router",
          "to": "assembleBoardInvoke",
          "out": "functionCall",
          "in": "functionCall"
        },
        {
          "from": "router",
          "to": "formatFunctionResponse",
          "out": "context",
          "in": "generated"
        },
        {
          "from": "router",
          "to": "formatFunctionResponse",
          "out": "functionCall",
          "in": "functionCall"
        },
        {
          "from": "router",
          "to": "fn-3",
          "out": "context",
          "in": "generated"
        },
        {
          "from": "router",
          "to": "output-2",
          "out": "text",
          "in": "text"
        },
        {
          "from": "buildContext",
          "to": "doWork",
          "out": "context",
          "in": "context"
        },
        {
          "from": "buildContext",
          "to": "formatFunctionResponse",
          "out": "context",
          "in": "context"
        },
        {
          "from": "buildContext",
          "to": "fn-3",
          "out": "context",
          "in": "context"
        },
        {
          "from": "doWork",
          "to": "router",
          "out": "context",
          "in": "context"
        },
        {
          "from": "assembleBoardInvoke",
          "to": "invokeBoard",
          "out": "*",
          "in": ""
        },
        {
          "from": "formatFunctionResponse",
          "to": "replyToFunction",
          "out": "context",
          "in": "context"
        },
        {
          "from": "formatFunctionResponse",
          "to": "assembleContext",
          "out": "context",
          "in": "context"
        },
        {
          "from": "input-1",
          "to": "buildContext",
          "out": "context",
          "in": "context"
        },
        {
          "from": "input-1",
          "to": "buildContext",
          "out": "instruction",
          "in": "instruction"
        },
        {
          "from": "input-1",
          "to": "turnBoardsToFunctions",
          "out": "tools",
          "in": "list"
        },
        {
          "from": "input-1",
          "to": "doWork",
          "out": "instruction",
          "in": "systemInstruction"
        },
        {
          "from": "input-1",
          "to": "replyToFunction",
          "out": "retry",
          "in": "retry"
        },
        {
          "from": "formatFunctionDeclarations",
          "to": "doWork",
          "out": "tools",
          "in": "tools"
        },
        {
          "from": "formatFunctionDeclarations",
          "to": "assembleBoardInvoke",
          "out": "urlMap",
          "in": "urlMap"
        },
        {
          "from": "formatFunctionDeclarations",
          "to": "replyToFunction",
          "out": "tools",
          "in": "tools"
        },
        {
          "from": "invokeBoard",
          "to": "extractBoardResponse",
          "out": "*",
          "in": ""
        },
        {
          "from": "extractBoardResponse",
          "to": "formatFunctionResponse",
          "out": "response",
          "in": "response"
        },
        {
          "from": "replyToFunction",
          "to": "assembleContext",
          "out": "context",
          "in": "generated"
        },
        {
          "from": "replyToFunction",
          "to": "functionOutput",
          "out": "text",
          "in": "text"
        },
        {
          "from": "assembleContext",
          "to": "functionOutput",
          "out": "context",
          "in": "context"
        },
        {
          "from": "turnBoardsToFunctions",
          "to": "formatFunctionDeclarations",
          "out": "list",
          "in": "list"
        }
      ],
      "nodes": [
        {
          "id": "output-2",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "context": {
                  "type": "string",
                  "title": "context"
                },
                "text": {
                  "type": "string",
                  "title": "text"
                }
              }
            }
          }
        },
        {
          "id": "fn-3",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_3 = ({context,generated})=>{if(!context)throw new Error(\"Context is required\");return{context:[...context,generated]}};",
            "name": "fn_3",
            "raw": true
          },
          "metadata": {
            "title": "Assemble Non-function call Context",
            "description": "Assembling the final context for the output"
          }
        },
        {
          "id": "router",
          "type": "runJavascript",
          "configuration": {
            "code": "const router = ({context})=>{if(!context)throw new Error(\"Context is a required input\");const item=context;const functionCallPart=item.parts.find(part=>\"functionCall\"in part);if(!functionCallPart){const textPart=item.parts.find(part=>\"text\"in part);if(!textPart)throw new Error(\"No text or function call found in context\");return{context,text:textPart.text}}return{context,functionCall:functionCallPart.functionCall}};",
            "name": "router",
            "raw": true
          },
          "metadata": {
            "title": "Router",
            "description": "Routing to either function call invocation or text reply"
          }
        },
        {
          "id": "buildContext",
          "type": "runJavascript",
          "configuration": {
            "code": "const buildContext = ({context})=>{if(typeof context===\"string\"){context=[{role:\"user\",parts:[{text:context}]}]}const list=context||[];return{context:list}};",
            "name": "buildContext",
            "raw": true
          },
          "metadata": {
            "title": "Build Context",
            "description": "Combining the context and instruction into a single context"
          }
        },
        {
          "id": "doWork",
          "type": "text",
          "configuration": {},
          "metadata": {
            "title": "Do Work",
            "description": "Using Gemini to do the work"
          }
        },
        {
          "id": "assembleBoardInvoke",
          "type": "runJavascript",
          "configuration": {
            "code": "const assembleBoardInvoke = ({functionCall,urlMap})=>{if(!functionCall)throw new Error(\"Function call is a required input\");if(!urlMap)throw new Error(\"URL map is a required input\");const call=functionCall;const $board=urlMap[call.name];const generator=\"https://raw.githubusercontent.com/breadboard-ai/breadboard/05136f811e443dd931a2a2a40ff5a3f388d5ce75/packages/breadboard-web/public/graphs/gemini-generator.json\";return{$board,generator,...call.args}};",
            "name": "assembleBoardInvoke",
            "raw": true
          },
          "metadata": {
            "title": "Assemble Board Invoke",
            "description": "Assembling the board invocation based on Gemini response"
          }
        },
        {
          "id": "formatFunctionResponse",
          "type": "runJavascript",
          "configuration": {
            "code": "const formatFunctionResponse = ({context,generated,functionCall,response})=>{const call=functionCall;return{context:[...context,generated,{role:\"function\",parts:[{functionResponse:{name:call.name,response}}]}]}};",
            "name": "formatFunctionResponse",
            "raw": true
          },
          "metadata": {
            "title": "Format Function Response",
            "description": "Formatting the function response"
          }
        },
        {
          "id": "input-1",
          "type": "input",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "context": {
                  "title": "Context In",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "behavior": [
                      "llm-content"
                    ]
                  },
                  "default": "What is the square root of e?"
                },
                "instruction": {
                  "type": "string",
                  "title": "Instruction",
                  "description": "Describe the worker persona and the task given: the skills and various capabilities, the mindset, the thinking process, etc. The ideal task is a call to action with the necessary details on how to best complete this action.",
                  "default": "",
                  "examples": [
                    "You are a hip, fun-loving mathematician who loves to help solve problems and chat about math. You also love finding answers to questions using Search. Use the right tool for solving the problems and reply without engaging tools otherwise. After using the tool, make sure to summarize and expand the answer in a hip, humorous way to help the user enjoy the beauty of math.\n\nIn situations where the tool use is not necessary, just carry the conversation with the user."
                  ],
                  "format": "multiline"
                },
                "tools": {
                  "title": "Tools",
                  "type": "array",
                  "description": "The boards to use as tools",
                  "items": {
                    "type": "object",
                    "behavior": [
                      "board"
                    ]
                  },
                  "examples": [
                    "[\"https://raw.githubusercontent.com/breadboard-ai/breadboard/b5577943bdd0956bed3874244b34ea80f1589eaa/packages/breadboard-web/public/graphs/search-summarize.json\",{\"title\":\"The Calculator Board\",\"description\":\"A simple AI pattern that leans on the power of the LLMs to generate language to solve math problems.\",\"version\":\"0.0.2\",\"edges\":[{\"from\":\"compute\",\"to\":\"answer\",\"out\":\"*\",\"in\":\"\"},{\"from\":\"generator\",\"to\":\"compute\",\"out\":\"text\",\"in\":\"code\"},{\"from\":\"math-question\",\"to\":\"math-function\",\"out\":\"question\",\"in\":\"question\"},{\"from\":\"math-question\",\"to\":\"generator\",\"out\":\"generator\",\"in\":\"path\"},{\"from\":\"math-function\",\"to\":\"generator\",\"out\":\"prompt\",\"in\":\"text\"}],\"nodes\":[{\"id\":\"answer\",\"type\":\"output\",\"configuration\":{\"schema\":{\"type\":\"object\",\"properties\":{\"result\":{\"type\":\"string\",\"title\":\"Answer\",\"description\":\"The answer to the math problem\"}},\"required\":[\"text\"]}}},{\"id\":\"compute\",\"type\":\"runJavascript\",\"configuration\":{\"name\":\"compute\"}},{\"id\":\"generator\",\"type\":\"invoke\",\"configuration\":{}},{\"id\":\"math-question\",\"type\":\"input\",\"configuration\":{\"schema\":{\"type\":\"object\",\"properties\":{\"question\":{\"type\":\"string\",\"title\":\"Math problem\",\"description\":\"Ask a math question\",\"examples\":[\"What is the square root of pi?\"]},\"generator\":{\"type\":\"string\",\"title\":\"Generator\",\"description\":\"The URL of the generator to call\",\"default\":\"text-generator.json\"}},\"required\":[\"text\"]}}},{\"id\":\"math-function\",\"type\":\"promptTemplate\",\"configuration\":{\"template\":\"Translate the math problem below into a self-contained,\\nzero-argument JavaScript function named `compute` that can be executed\\nto provide the answer to the problem.\\n\\nDo not use any dependencies or libraries.\\n\\nMath Problem: {{question}}\\n\\nSolution:\"}}],\"graphs\":{}}]"
                  ],
                  "default": "[]"
                },
                "retry": {
                  "type": "number",
                  "title": "Retry Count",
                  "description": "How many times to retry in case of LLM error",
                  "default": "5"
                }
              },
              "required": [
                "instruction"
              ]
            }
          }
        },
        {
          "id": "formatFunctionDeclarations",
          "type": "runJavascript",
          "configuration": {
            "code": "const formatFunctionDeclarations = ({list})=>{const tools=[];const urlMap={};list.forEach(item=>{tools.push(item.function);urlMap[item.function.name]=item.boardURL});return{tools,urlMap}};",
            "name": "formatFunctionDeclarations",
            "raw": true
          },
          "metadata": {
            "title": "Format Function Declarations",
            "description": "Formatting the function declarations"
          }
        },
        {
          "id": "invokeBoard",
          "type": "invoke",
          "configuration": {},
          "metadata": {
            "title": "Invoke Board",
            "description": "Invoking the board"
          }
        },
        {
          "id": "extractBoardResponse",
          "type": "runJavascript",
          "configuration": {
            "code": "const extractBoardResponse = inputs=>{const{schema,...response}=inputs;schema;return{response}};",
            "name": "extractBoardResponse",
            "raw": true
          },
          "metadata": {
            "title": "Format Board Response",
            "description": "Extracting the board response from the invocation"
          }
        },
        {
          "id": "replyToFunction",
          "type": "text",
          "configuration": {},
          "metadata": {
            "title": "Reply to Function",
            "description": "Using Gemini to reply to function results"
          }
        },
        {
          "id": "assembleContext",
          "type": "runJavascript",
          "configuration": {
            "code": "const assembleContext = ({context,generated})=>{if(!context)throw new Error(\"Context is required\");return{context:[...context,generated]}};",
            "name": "assembleContext",
            "raw": true
          },
          "metadata": {
            "title": "Assemble Context",
            "description": "Assembling the final context for the output"
          }
        },
        {
          "id": "turnBoardsToFunctions",
          "type": "map",
          "configuration": {
            "board": "#boardToFunction"
          },
          "metadata": {
            "title": "Turn Boards into Functions",
            "description": "Turning provided boards into functions"
          }
        },
        {
          "id": "functionOutput",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "context": {
                  "type": "string",
                  "title": "context"
                },
                "text": {
                  "type": "string",
                  "title": "Text",
                  "description": "The generated text"
                }
              }
            }
          },
          "metadata": {
            "title": "Function Call Output",
            "description": "Outputting the function call results"
          }
        }
      ],
      "graphs": {
        "boardToFunction": {
          "title": "Board to functions",
          "description": "Use this board to convert specified boards into function-calling signatures",
          "edges": [
            {
              "from": "getFunctionSignature",
              "to": "output-2",
              "out": "function",
              "in": "function"
            },
            {
              "from": "input-1",
              "to": "curry-3",
              "out": "item",
              "in": "$board"
            },
            {
              "from": "input-1",
              "to": "output-2",
              "out": "item",
              "in": "boardURL"
            },
            {
              "from": "curry-3",
              "to": "getFunctionSignature",
              "out": "board",
              "in": "json"
            }
          ],
          "nodes": [
            {
              "id": "output-2",
              "type": "output",
              "configuration": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "function": {
                      "type": [
                        "array",
                        "boolean",
                        "null",
                        "number",
                        "object",
                        "string"
                      ],
                      "title": "function"
                    },
                    "boardURL": {
                      "type": "string",
                      "title": "boardURL"
                    }
                  }
                }
              }
            },
            {
              "id": "getFunctionSignature",
              "type": "jsonata",
              "configuration": {
                "expression": "\n      (\n        $adjustType := function ($type) {\n            $type = \"object\" or $type = \"array\" ? \"string\" : $type\n        };\n\n        {\n        \"function\": {\n            \"name\": $replace(title, /\\W/, \"_\"),\n            \"description\": description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": nodes[type=\"input\"][0].configuration.schema.properties ~> $each(function($v, $k) {\n                { $k: {\n                    \"type\": $v.type ~> $adjustType,\n                    \"description\": $v.description\n                } }\n                }) ~> $merge\n            }\n        },\n        \"returns\": nodes[type=\"output\"][0].configuration.schema ~> | ** | {}, 'title' |\n        }\n    )",
                "raw": true
              }
            },
            {
              "id": "input-1",
              "type": "input",
              "configuration": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "item": {
                      "title": "board",
                      "behavior": [
                        "board"
                      ],
                      "description": "The board to curry. Can be a BoardCapability, a graph or a URL",
                      "type": "string"
                    }
                  },
                  "required": [
                    "item"
                  ]
                }
              }
            },
            {
              "id": "curry-3",
              "type": "curry",
              "configuration": {}
            }
          ],
          "graphs": {}
        }
      }
    },
    "worker": {
      "title": "Worker",
      "description": "The essential Agent building block",
      "version": "0.0.1",
      "edges": [
        {
          "from": "assembleContext",
          "to": "output-2",
          "out": "context",
          "in": "context"
        },
        {
          "from": "generate",
          "to": "assembleContext",
          "out": "context",
          "in": "generated"
        },
        {
          "from": "generate",
          "to": "output-2",
          "out": "text",
          "in": "text"
        },
        {
          "from": "buildContext",
          "to": "generate",
          "out": "context",
          "in": "context"
        },
        {
          "from": "buildContext",
          "to": "assembleContext",
          "out": "context",
          "in": "context"
        },
        {
          "from": "input-1",
          "to": "buildContext",
          "out": "context",
          "in": "context"
        },
        {
          "from": "input-1",
          "to": "buildContext",
          "out": "instruction",
          "in": "instruction"
        },
        {
          "from": "input-1",
          "to": "generate",
          "out": "stopSequences",
          "in": "stopSequences"
        }
      ],
      "nodes": [
        {
          "id": "output-2",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "context": {
                  "type": "string",
                  "title": "context"
                },
                "text": {
                  "type": "string",
                  "title": "Output",
                  "description": "Agent's output"
                }
              }
            }
          }
        },
        {
          "id": "assembleContext",
          "type": "runJavascript",
          "configuration": {
            "code": "const assembleContext = ({context,generated})=>{if(!context)throw new Error(\"Context is required\");return{context:[...context,generated]}};",
            "name": "assembleContext",
            "raw": true
          },
          "metadata": {
            "title": "Assemble Context",
            "description": "Assembling the context after generation"
          }
        },
        {
          "id": "generate",
          "type": "text",
          "configuration": {
            "text": "unused"
          },
          "metadata": {
            "title": "Generate",
            "description": "Using Gemini to generate worker output"
          }
        },
        {
          "id": "buildContext",
          "type": "runJavascript",
          "configuration": {
            "code": "const buildContext = ({context,instruction})=>{if(typeof context===\"string\"){context=[{role:\"user\",parts:[{text:context}]}]}const list=context||[];if(list.length>0){const last=list[list.length-1];if(last.role===\"user\"){last.parts.unshift({text:instruction});return{context:list}}}return{context:[...list,{role:\"user\",parts:[{text:instruction}]}]}};",
            "name": "buildContext",
            "raw": true
          },
          "metadata": {
            "title": "Build Context",
            "description": "Building the context for the worker"
          }
        },
        {
          "id": "input-1",
          "type": "input",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "context": {
                  "title": "Context",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "behavior": [
                      "llm-content"
                    ]
                  },
                  "examples": [
                    "the universe within us"
                  ]
                },
                "instruction": {
                  "title": "Instruction",
                  "format": "multiline",
                  "behavior": [
                    "config"
                  ],
                  "examples": [
                    "You are a brilliant poet who specializes in two-line rhyming poems.\nGiven any topic, you can quickly whip up a two-line rhyming poem about it.\nLook at the topic below and do your magic"
                  ],
                  "type": "string"
                },
                "stopSequences": {
                  "type": "array",
                  "title": "Stop Sequences",
                  "description": "An array of strings that will stop the output",
                  "default": "[]",
                  "items": {
                    "type": "object",
                    "behavior": [
                      "config"
                    ]
                  }
                }
              },
              "required": [
                "context",
                "instruction"
              ]
            }
          }
        }
      ],
      "graphs": {}
    },
    "looper": {
      "title": "Looper",
      "metadata": {
        "icon": "laps"
      },
      "description": "A worker whose job it is to repeat the same thing over and over, until some condition is met or the max count of repetitions is reached.",
      "version": "0.0.1",
      "edges": [
        {
          "from": "fn-7",
          "to": "fn-8",
          "out": "done",
          "in": "context"
        },
        {
          "from": "fn-7",
          "to": "output-2",
          "out": "context",
          "in": "loop"
        },
        {
          "from": "input-1",
          "to": "fn-3",
          "out": "context",
          "in": "context"
        },
        {
          "from": "input-1",
          "to": "fn-4",
          "out": "task",
          "in": "toAdd"
        },
        {
          "from": "input-1",
          "to": "fn-7",
          "out": "context",
          "in": "context"
        },
        {
          "from": "fn-3",
          "to": "fn-4",
          "out": "context",
          "in": "context"
        },
        {
          "from": "fn-3",
          "to": "fn-7",
          "out": "progress",
          "in": "progress"
        },
        {
          "from": "validateJson-6",
          "to": "fn-7",
          "out": "json",
          "in": "progress"
        },
        {
          "from": "fn-8",
          "to": "output-9",
          "out": "context",
          "in": "done"
        },
        {
          "from": "fn-4",
          "to": "text-5",
          "out": "context",
          "in": "context"
        },
        {
          "from": "text-5",
          "to": "validateJson-6",
          "out": "text",
          "in": "json"
        }
      ],
      "nodes": [
        {
          "id": "output-2",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "loop": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "behavior": [
                      "llm-content"
                    ]
                  },
                  "title": "Loop"
                }
              }
            }
          }
        },
        {
          "id": "fn-7",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_7 = ({context,progress})=>{const plans=Array.isArray(progress)?progress:[progress];const existing=Array.isArray(context)?context:[context];if(!plans||!plans.length){throw new Error(\"Plan is required for Looper to function.\")}try{const current=plans[0];if(current.done){return{done:existing}}const originalPlan=plans[plans.length-1];let max=originalPlan.max;const doneMarker=originalPlan.doneMarker;if(!max){const planItems=originalPlan.todo?.length;if(planItems){max=planItems+1}else{max=Infinity}}const contents=structuredClone(existing);const count=plans.length;if(count>=max){return{done:existing}}if(current.todo&&Array.isArray(current.todo)){const next=current.todo?.shift();if(!next){return{done:existing}}delete current.doneMarker;contents.push({role:\"$metadata\",data:{...current,next:next.task}});return{context:contents}}else if(doneMarker){contents.push({role:\"$metadata\",data:{type:\"looper\",doneMarker}});return{context:contents}}else if(max){const count2=plans.length;if(count2>=max){return{done:existing}}contents.push({role:\"$metadata\",data:{type:\"looper\",max}});return{context:contents}}return{done:existing}}catch(e){const error=e;throw new Error(`Invalid plan, unable to proceed: ${error.message}`)}};",
            "name": "fn_7",
            "raw": true
          },
          "metadata": {
            "title": "Read Plan"
          }
        },
        {
          "id": "input-1",
          "type": "input",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "context": {
                  "title": "Context in",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "behavior": [
                      "llm-content"
                    ]
                  },
                  "default": "[]",
                  "examples": [
                    "{\"parts\":[{\"text\":\"test\"}],\"role\":\"user\"}"
                  ],
                  "description": "Incoming conversation context"
                },
                "task": {
                  "title": "Task",
                  "default": "{}",
                  "description": "The task to be used for loop planning",
                  "type": "object",
                  "behavior": [
                    "llm-content",
                    "config"
                  ]
                }
              },
              "required": []
            }
          }
        },
        {
          "id": "fn-3",
          "type": "runJavascript",
          "configuration": {
            "forkOutputs": true,
            "code": "const fn_3 = ({context,forkOutputs})=>{const fork=forkOutputs;const existing=Array.isArray(context)?context:[context];const progress=[];for(let i=existing.length-1;i>=0;i--){const item=existing[i];if(item.role===\"$metadata\"){progress.push(item.data)}}if(fork){if(progress.length){return{progress}}else{return{context}}}else{return{context,progress}}};",
            "name": "fn_3",
            "raw": true
          },
          "metadata": {
            "title": "Read progress so far"
          }
        },
        {
          "id": "validateJson-6",
          "type": "validateJson",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "max": {
                  "type": "number",
                  "description": "Maximum iterations to make, optional. Default is infinity"
                },
                "todo": {
                  "type": "array",
                  "description": "Items in the plan, optional. Use this if the plan contains a definite, concrete list of items",
                  "items": {
                    "type": "object",
                    "description": "The object that represent an item in the plan",
                    "properties": {
                      "task": {
                        "type": "string",
                        "description": "The task description. Use action-oriented language, starting with a verb that fits the task"
                      }
                    }
                  }
                },
                "doneMarker": {
                  "type": "string",
                  "description": "The marker that will be used by others to signal completion of the job."
                },
                "error": {
                  "type": "string",
                  "description": "Describe the reason why the plan generation failed"
                }
              }
            }
          },
          "metadata": {
            "title": "Validate Plan",
            "description": "Validating JSON of the Plan"
          }
        },
        {
          "id": "fn-8",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_8 = ({context})=>{if(!context)throw new Error(\"Context is required\");const c=context;const result=c.filter(item=>item.role!==\"$metadata\");return{context:result}};",
            "name": "fn_8",
            "raw": true
          },
          "metadata": {
            "title": "Clean up",
            "description": "Cleaning up the metadata that was used for running loops"
          }
        },
        {
          "id": "fn-4",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_4 = ({context,toAdd})=>{if(!context)throw new Error(\"Context is required\");const existing=Array.isArray(context)?context:[context];const incoming=structuredClone(toAdd);if(!incoming.parts){const containsUserRole=existing.filter(item=>item.role!==\"model\"&&item.role!==\"$metadata\").length>0;if(!containsUserRole){return{context:[...existing,{role:\"user\",parts:[{text:\"Do your magic\"}]}]}}return{context:existing}}if(!incoming.role){incoming.role=\"user\"}const last=existing[existing.length-1];if(!last){return{context:[incoming]}}if(last.role!==incoming.role){return{context:[...existing,incoming]}}else{const result=structuredClone(existing);const index=result.length-1;result[index].parts.push(...incoming.parts);return{context:result}}};",
            "name": "fn_4",
            "raw": true
          },
          "metadata": {
            "title": "Add Task"
          }
        },
        {
          "id": "text-5",
          "type": "text",
          "configuration": {
            "systemInstruction": {
              "parts": [
                {
                  "text": "\nYou are to create a precise plan for a given job. This plan will be executed by others and your responsibility is to produce a plan that reflects the job. \n\nYour output must be a valid JSON of the following format:\n\n```json\n{\n  \"max\": \"number, optional. Specifies how many iterations to make. Useful when the job specifies the upper limit the number of items in the list.\",\n  \"todo\": [{\n    \"task\": \"string, The task description. Use action-oriented language, starting with a verb that fits the task.\"\n  }]\n  \"doneMarker\": \"string, optional. The marker that will be used by others to signal completion.\"\n  \"error\": \"string, optional. A description of why you're unable to create a plan\"\n}\n```\n\nThere are four kinds of jobs that you can make plans for. \n\n1) The indefinite job. These are useful when there is not a definite completion condition, and is usually formulated with words like \"indefinitely\" or \"forever\". In such cases, the plan will look like an object without a \"todo\" property, with \"max\" set to a very large number:\n\n```json\n{\n  \"max\": 100000000\n}\n```\n\n2) The step-by-step job. These are for situations when a distinct, known number of tasks can be discerned from the job. For example, when asked to write chapters of a book following an outline, there's a clear list of tasks that can be discerned (one \"Write <chapter title>\" per chapter). \n\nA plan for this kind of job will look like an object with \"todo\" items:\n\n```json\n{\n  \"todo\": [\n    { \"task\": \"<action-oriented description of task 1\" },\n    { \"task\": \"<action-oriented description of task 2\" },\n    { \"task\": \"<action-oriented description of task 3\" }\n  ]\n}\n```\nIf the job includes a limit on how many tasks to produce, use the \"max\" property to indicate that. For instance, if the job contains three items that can be discerned, but asks to only do two of them:\n\n```json\n{\n  \"max:\" 2,\n  \"todo\": [\n    { \"task\": \"<action-oriented description of task 1\" },\n    { \"task\": \"<action-oriented description of task 2\" },\n    { \"task\": \"<action-oriented description of task 3\" }\n  ]\n}\n```\n\n3) Just repeat the steps job. These jobs do not have a distinct tasks, but rather just a number of steps to repeat. In this case, omit the \"todo\" and just use \"max\" property:\n\n```json\n{\n  \"max\": 4\n}\n```\n\n4) The job where the completion is signaled by others. These are the types of jobs where the number of iterations or the exact steps are unknown, and the\ncompletion signal is issued by those who are executing the individual steps. In such cases, use the \"doneMarker\" property and use the marker specified:\n\n```json\n{\n  \"doneMarker\": \"<the marker that will be used to signal completion>\"\n}\n```\n\nCommon markers are \"##STOP##\" or \"##DONE##\", but could be different depending on a job. This type of the job is mutually exclusive with the step-by-step type, so the \"todo\" and \"doneMarker\" may never be specified together.\n\nWhen you are unable to create plan from the job, reply with:\n\n```json\n{\n  \"error\": \"<description of why you're unable to create a plan>\"\n}\n```\n\n"
                }
              ]
            },
            "responseMimeType": "application/json"
          },
          "metadata": {
            "title": "Generating Plan"
          }
        },
        {
          "id": "output-9",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "done": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "behavior": [
                      "llm-content"
                    ]
                  },
                  "title": "Context out"
                }
              }
            }
          },
          "metadata": {
            "title": "Exit"
          }
        }
      ],
      "graphs": {}
    },
    "joiner": {
      "title": "Joiner",
      "metadata": {
        "icon": "merge-type"
      },
      "description": "Joins two or more worker contexts into one. Great for combining results of multiple workers.",
      "version": "0.0.1",
      "edges": [
        {
          "from": "fn-4",
          "to": "output-5",
          "out": "context",
          "in": "context"
        },
        {
          "from": "input-3",
          "to": "fn-4",
          "out": "*",
          "in": ""
        },
        {
          "from": "input-1",
          "to": "fn-4",
          "out": "merge",
          "in": "merge"
        }
      ],
      "nodes": [
        {
          "id": "output-5",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "context": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "behavior": [
                      "llm-content"
                    ]
                  },
                  "title": "context"
                }
              }
            }
          },
          "metadata": {
            "title": "Output",
            "description": "Returning combined values"
          }
        },
        {
          "id": "fn-4",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_4 = ({merge,...inputs})=>{const entries=Object.entries(inputs).sort();const context=[];if(merge){const parts=[];for(const entry of entries){const input=entry[1];const c=Array.isArray(input)?input:[input];const last=c[c.length-1];if(last){if(last.role===\"$metadata\"){continue}parts.push(...last.parts)}}context.push({parts})}else{for(const entry of entries){const input=entry[1];const c=Array.isArray(input)?input:[input];context.push(...c)}}return{context}};",
            "name": "fn_4",
            "raw": true
          },
          "metadata": {
            "title": "Combine Context",
            "description": "Combining context into one"
          }
        },
        {
          "id": "input-3",
          "type": "input",
          "configuration": {},
          "metadata": {
            "title": "Input",
            "description": "Getting all the data"
          }
        },
        {
          "id": "input-1",
          "type": "input",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "merge": {
                  "type": "boolean",
                  "behavior": [
                    "config"
                  ],
                  "title": "Merge Contexts",
                  "default": "false",
                  "description": "Merge the last items of all incoming conversation into one."
                }
              },
              "required": []
            }
          }
        }
      ],
      "graphs": {}
    }
  }
}