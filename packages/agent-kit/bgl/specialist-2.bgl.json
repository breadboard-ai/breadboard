{
  "title": "Specialist 2",
  "metadata": {
    "icon": "smart-toy",
    "help": {
      "url": "https://breadboard-ai.github.io/breadboard/docs/kits/agents/#specialist"
    },
    "comments": []
  },
  "description": "Given instructions on how to act, performs a single task, optionally invoking tools. Now with {{param}} support.",
  "edges": [
    {
      "from": "fn-15",
      "to": "output-2",
      "in": "out",
      "out": "context"
    },
    {
      "from": "fn-7",
      "to": "fn-8",
      "in": "context",
      "out": "context"
    },
    {
      "from": "fn-7",
      "to": "text-10",
      "in": "context",
      "out": "context"
    },
    {
      "from": "fn-7",
      "to": "fn-15",
      "in": "context",
      "out": "context"
    },
    {
      "from": "router",
      "to": "assembleBoardInvoke",
      "in": "context",
      "out": "context"
    },
    {
      "from": "router",
      "to": "assembleBoardInvoke",
      "in": "functionCalls",
      "out": "functionCalls"
    },
    {
      "from": "router",
      "to": "fn-15",
      "in": "generated",
      "out": "context"
    },
    {
      "from": "router",
      "to": "fn-15",
      "in": "text",
      "out": "text"
    },
    {
      "from": "fn-5",
      "to": "fn-7",
      "in": "context",
      "out": "context"
    },
    {
      "from": "fn-6",
      "to": "fn-7",
      "in": "progress",
      "out": "progress"
    },
    {
      "from": "fn-8",
      "to": "curry-9",
      "in": "context",
      "out": "context"
    },
    {
      "from": "fn-8",
      "to": "fn-12",
      "in": "context",
      "out": "context"
    },
    {
      "from": "text-10",
      "to": "router",
      "in": "context",
      "out": "context"
    },
    {
      "from": "assembleBoardInvoke",
      "to": "map-11",
      "in": "list",
      "out": "list"
    },
    {
      "from": "curry-9",
      "to": "turnBoardsToFunctions",
      "in": "board",
      "out": "board"
    },
    {
      "from": "fn-12",
      "to": "fn-13",
      "in": "",
      "out": "*"
    },
    {
      "from": "formatFunctionDeclarations",
      "to": "text-10",
      "in": "tools",
      "out": "tools"
    },
    {
      "from": "formatFunctionDeclarations",
      "to": "assembleBoardInvoke",
      "in": "urlMap",
      "out": "urlMap"
    },
    {
      "from": "input-4",
      "to": "text-10",
      "in": "model",
      "out": "model"
    },
    {
      "from": "map-11",
      "to": "fn-12",
      "in": "response",
      "out": "list"
    },
    {
      "from": "turnBoardsToFunctions",
      "to": "formatFunctionDeclarations",
      "in": "list",
      "out": "list"
    },
    {
      "from": "fn-13",
      "to": "output-14",
      "in": "out",
      "out": "context"
    },
    {
      "from": "input-3",
      "to": "turnBoardsToFunctions",
      "in": "list",
      "out": "tools"
    },
    {
      "from": "runJavascript-4e04e982",
      "to": "output-acc3ef03",
      "in": "inputSchema",
      "out": "inputSchema"
    },
    {
      "from": "runJavascript-4e04e982",
      "to": "output-acc3ef03",
      "in": "outputSchema",
      "out": "outputSchema"
    },
    {
      "from": "input-58c1588f",
      "to": "runJavascript-4e04e982",
      "in": "",
      "out": "*"
    },
    {
      "from": "input-1",
      "to": "runJavascript-f4247fc6",
      "out": "*",
      "in": ""
    },
    {
      "from": "runJavascript-f4247fc6",
      "to": "fn-5",
      "out": "in",
      "in": "context"
    },
    {
      "from": "runJavascript-f4247fc6",
      "to": "fn-5",
      "out": "task",
      "in": "toadd"
    },
    {
      "from": "runJavascript-f4247fc6",
      "to": "fn-6",
      "out": "in",
      "in": "context"
    },
    {
      "from": "runJavascript-f4247fc6",
      "to": "text-10",
      "out": "persona",
      "in": "systemInstruction"
    }
  ],
  "nodes": [
    {
      "id": "output-2",
      "type": "output",
      "configuration": {
        "schema": {
          "type": "object",
          "properties": {
            "out": {
              "title": "Context out",
              "type": "array",
              "items": {
                "type": "object",
                "behavior": ["llm-content"]
              }
            }
          }
        }
      },
      "metadata": {
        "visual": {
          "x": 6003.000000000002,
          "y": -669.0000000000002,
          "collapsed": "expanded"
        },
        "title": "Text Output",
        "logLevel": "debug"
      }
    },
    {
      "id": "fn-15",
      "type": "runJavascript",
      "configuration": {
        "code": "const fn_15 = ({ context, generated }) => {\n  if (!context) throw new Error(\"Context is required\");\n  if (!generated) throw new Error(\"Generated is required\");\n  const c = context;\n  const g = generated;\n  let doneMarker = null;\n  for (let i = 0; i < c.length; ++i) {\n    const item = c[i];\n    if (item.role === \"$metadata\" && item.type === \"looper\") {\n      const plan = item.data;\n      if (plan.doneMarker) {\n        doneMarker = plan.doneMarker;\n        break;\n      }\n    }\n  }\n  if (!doneMarker) {\n    return { context: [...c, g] };\n  }\n  let containsMarkers = false;\n  for (let i = 0; i < g.parts.length; ++i) {\n    const part = g.parts[i];\n    if (\"text\" in part && part.text.includes(doneMarker)) {\n      containsMarkers = true;\n      part.text = part.text.replaceAll(doneMarker, \"\").trim();\n      break;\n    }\n  }\n  if (!containsMarkers) {\n    return { context: [...c, g] };\n  }\n  const metadata = { role: \"$metadata\", type: \"looper\", data: { done: true } };\n  return { context: [...c, g, metadata] };\n};\n",
        "name": "fn_15",
        "raw": true
      },
      "metadata": {
        "title": "Done Check",
        "description": "Checking for the 'Done' marker",
        "visual": {
          "x": 5595,
          "y": -667.0000000000005,
          "collapsed": "expanded"
        }
      }
    },
    {
      "id": "fn-7",
      "type": "runJavascript",
      "configuration": {
        "code": "const fn_7 = ({ context, progress }) => {\n  const contents = Array.isArray(context) ? context : [context];\n  const plans = Array.isArray(progress) ? progress : [progress];\n  const last = plans[0];\n  if (!last || !last.next) {\n    return { context };\n  }\n  const lastLooperMarker = contents.findLastIndex(\n    (item) => item.role === \"$metadata\" && item.type === \"looper\"\n  );\n  if (lastLooperMarker >= 0) {\n    const pastLooper = contents.slice(lastLooperMarker);\n    const hasModel = pastLooper.some((item) => item.role === \"model\");\n    if (hasModel) {\n      return { context: contents };\n    }\n  }\n  contents.push({ role: \"user\", parts: [{ text: last.next }] });\n  return { context: contents };\n};\n",
        "name": "fn_7",
        "raw": true
      },
      "metadata": {
        "title": "Add Looper Task",
        "description": "If there is a pending Looper task, add it.",
        "visual": {
          "x": 2773.9999999999995,
          "y": -536.0000000000002,
          "collapsed": "expanded"
        }
      }
    },
    {
      "id": "router",
      "type": "runJavascript",
      "configuration": {
        "code": "const router = ({ context }) => {\n  if (!context) throw new Error(\"Context is a required input\");\n  const item = context;\n  const functionCallParts = item.parts\n    .filter((part) => \"functionCall\" in part)\n    .map((part) => part.functionCall);\n  if (functionCallParts.length === 0) {\n    const textPart = item.parts.find((part) => \"text\" in part);\n    if (!textPart) throw new Error(\"No text or function call found in context\");\n    return { context, text: textPart.text };\n  }\n  return { context, functionCalls: functionCallParts };\n};\n",
        "name": "router",
        "raw": true
      },
      "metadata": {
        "title": "Router",
        "description": "Routing to either function call invocation or text reply",
        "visual": {
          "x": 5078,
          "y": -279.9999999999999,
          "collapsed": "expanded"
        }
      }
    },
    {
      "id": "fn-5",
      "type": "runJavascript",
      "configuration": {
        "code": "const fn_5 = ({ context, toadd: toAdd }) => {\n  if (!context) throw new Error(\"Context is required\");\n  const existing = Array.isArray(context) ? context : [context];\n  const incoming = toAdd;\n  if (!incoming.parts) {\n    const containsUserRole =\n      existing.filter(\n        (item) => item.role !== \"model\" && item.role !== \"$metadata\"\n      ).length > 0;\n    if (!containsUserRole) {\n      return {\n        context: [\n          ...existing,\n          { role: \"user\", parts: [{ text: \"Do your magic\" }] },\n        ],\n      };\n    }\n    return { context: existing };\n  }\n  if (!incoming.role) {\n    incoming.role = \"user\";\n  }\n  const last = existing[existing.length - 1];\n  if (!last) {\n    return { context: [incoming] };\n  }\n  if (last.role !== incoming.role) {\n    return { context: [...existing, incoming] };\n  } else {\n    const result = structuredClone(existing);\n    const index = result.length - 1;\n    result[index].parts.push(...incoming.parts);\n    return { context: result };\n  }\n};\n",
        "name": "fn_5",
        "raw": true
      },
      "metadata": {
        "title": "Add Task",
        "description": "Adding task to the prompt.",
        "visual": {
          "x": 2313.000000000001,
          "y": -508.00000000000006,
          "collapsed": "expanded"
        }
      }
    },
    {
      "id": "fn-6",
      "type": "runJavascript",
      "configuration": {
        "code": "const fn_6 = ({ context, forkOutputs }) => {\n  const fork = forkOutputs;\n  const existing = Array.isArray(context) ? context : [context];\n  const progress = [];\n  for (let i = existing.length - 1; i >= 0; i--) {\n    const item = existing[i];\n    if (item.role === \"$metadata\" && item.type === \"looper\") {\n      progress.push(item.data);\n    }\n  }\n  if (fork) {\n    if (progress.length) {\n      return { progress };\n    } else {\n      return { context };\n    }\n  } else {\n    return { context, progress };\n  }\n};\n",
        "name": "fn_6",
        "raw": true
      },
      "metadata": {
        "title": "Read Progress so far",
        "visual": {
          "x": 2290,
          "y": -90,
          "collapsed": "expanded"
        }
      }
    },
    {
      "id": "fn-8",
      "type": "runJavascript",
      "configuration": {
        "code": "const fn_8 = ({ context }) => {\n  if (!context) throw new Error(\"Context is required\");\n  const c = context;\n  const id = Math.random().toString(36).substring(7);\n  const metadata = {\n    role: \"$metadata\",\n    type: \"split\",\n    data: { type: \"start\", id },\n  };\n  return { context: [...c, metadata], id };\n};\n",
        "name": "fn_8",
        "raw": true
      },
      "metadata": {
        "title": "Add Split Start",
        "description": "Marking the start of parallel processing in the context",
        "visual": {
          "x": 3235,
          "y": -417.99999999999994,
          "collapsed": "expanded"
        }
      }
    },
    {
      "id": "text-10",
      "type": "text",
      "configuration": {},
      "metadata": {
        "title": "Gemini API Call",
        "description": "Applying Gemini to do work",
        "visual": {
          "x": 4691.000000000002,
          "y": -264.0000000000001,
          "collapsed": "expanded"
        }
      }
    },
    {
      "id": "assembleBoardInvoke",
      "type": "runJavascript",
      "configuration": {
        "code": "const assembleBoardInvoke = ({ functionCalls, urlMap }) => {\n  if (!functionCalls) {\n    throw new Error(\"Function call array is a required input\");\n  }\n  if (!urlMap) {\n    throw new Error(\"URL map is a required input\");\n  }\n  const calls = functionCalls;\n  if (calls.length === 0) {\n    throw new Error(\"Function call array must not be empty.\");\n  }\n  const list = [];\n  for (const call of calls) {\n    const item = urlMap[call.name];\n    const $board = item.url;\n    const $flags = item.flags;\n    const llmContentProperty =\n      $flags.inputLLMContent || $flags.inputLLMContentArray;\n    const invokeArgs = { $board, $flags, ...call.args };\n    if (llmContentProperty) {\n      const args = call.args;\n      const text = args[llmContentProperty];\n      const parts = [{ text }];\n      const llmContent = { parts, role: \"user\" };\n      if ($flags.inputLLMContentArray) {\n        invokeArgs[llmContentProperty] = [llmContent];\n      } else {\n        invokeArgs[llmContentProperty] = llmContent;\n      }\n    }\n    list.push(invokeArgs);\n  }\n  return { list };\n};\n",
        "name": "assembleBoardInvoke",
        "raw": true
      },
      "metadata": {
        "title": "Assemble Tool Invoke",
        "description": "Assembling the tool invocation based on Gemini response",
        "visual": {
          "x": 5605,
          "y": -265.00000000000006,
          "collapsed": "expanded"
        }
      }
    },
    {
      "id": "input-1",
      "type": "input",
      "configuration": {
        "schema": {
          "type": "object",
          "properties": {
            "in": {
              "title": "Context in",
              "description": "Incoming conversation context",
              "type": "array",
              "items": {
                "type": "object",
                "behavior": ["llm-content"]
              },
              "examples": []
            },
            "task": {
              "title": "Task",
              "description": "(Optional) Provide a specific task with clear instructions for the worker to complete using the conversation context",
              "type": "object",
              "default": "{\"role\":\"user\",\"parts\":[{\"text\":\"\"}]}",
              "behavior": ["llm-content", "config"],
              "examples": []
            },
            "persona": {
              "type": "object",
              "behavior": ["llm-content", "config"],
              "title": "Persona",
              "description": "Describe the worker's skills, capabilities, mindset, and thinking process",
              "default": "{\"role\":\"user\",\"parts\":[{\"text\":\"\"}]}",
              "examples": []
            }
          },
          "required": []
        }
      },
      "metadata": {
        "visual": {
          "x": 1552,
          "y": -243,
          "collapsed": "advanced"
        },
        "title": "Context Input",
        "logLevel": "debug",
        "tags": ["start"]
      }
    },
    {
      "id": "curry-9",
      "type": "curry",
      "configuration": {
        "$board": "#boardToFunction"
      },
      "metadata": {
        "title": "Add Context",
        "description": "Adding context to the board to function converter",
        "visual": {
          "x": 3672.0000000000014,
          "y": -297.99999999999994,
          "collapsed": "expanded"
        }
      }
    },
    {
      "id": "fn-12",
      "type": "runJavascript",
      "configuration": {
        "code": "const fn_12 = ({ response, context }) => {\n  const r = response;\n  const c = context;\n  const result = Object.fromEntries(\n    r.map((item, i) => [`context-${i + 1}`, item.item])\n  );\n  if (c) {\n    result[\"context-0\"] = c;\n  }\n  return result;\n};\n",
        "name": "fn_12",
        "raw": true
      },
      "metadata": {
        "title": "Format Tool Response",
        "description": "Formatting tool response",
        "visual": {
          "x": 6379,
          "y": -548,
          "collapsed": "expanded"
        }
      }
    },
    {
      "id": "formatFunctionDeclarations",
      "type": "runJavascript",
      "configuration": {
        "code": "const formatFunctionDeclarations = ({ list }) => {\n  const tools = [];\n  const urlMap = {};\n  list.forEach((item) => {\n    tools.push(item.function);\n    const flags = item.flags;\n    urlMap[item.function.name] = { url: item.boardURL, flags };\n  });\n  return { tools, urlMap };\n};\n",
        "name": "formatFunctionDeclarations",
        "raw": true
      },
      "metadata": {
        "title": "Format Function Declarations",
        "description": "Formatting the function declarations",
        "visual": {
          "x": 4291,
          "y": -45.00000000000001,
          "collapsed": "expanded"
        }
      }
    },
    {
      "id": "input-4",
      "type": "input",
      "configuration": {
        "schema": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string",
              "title": "Model",
              "description": "Choose the model to use for this specialist.",
              "enum": [
                "gemini-1.5-flash-latest",
                "gemini-1.5-pro-latest",
                "gemini-1.5-pro-exp-0801",
                "gemini-1.5-pro-exp-0827",
                "gemini-1.5-flash-8b-exp-0827",
                "gemini-1.5-pro-exp-0827"
              ],
              "default": "gemini-1.5-flash-latest",
              "examples": ["gemini-1.5-flash-latest"],
              "behavior": ["config"]
            }
          }
        }
      },
      "metadata": {
        "title": "Model Input",
        "description": "Ask which model to use",
        "visual": {
          "x": 4379,
          "y": -186.99999999999994,
          "collapsed": "expanded"
        },
        "tags": ["start"]
      }
    },
    {
      "id": "map-11",
      "type": "map",
      "configuration": {
        "board": "#invokeBoardWithArgs"
      },
      "metadata": {
        "title": "Invoke Tools in Parallel",
        "description": "Invoking tools in parallel",
        "visual": {
          "x": 5992.000000000002,
          "y": -254.00000000000009,
          "collapsed": "expanded"
        }
      }
    },
    {
      "id": "turnBoardsToFunctions",
      "type": "map",
      "configuration": {},
      "metadata": {
        "title": "Turn Boards into Functions",
        "description": "Turning provided boards into functions",
        "visual": {
          "x": 3958.0000000000005,
          "y": 186,
          "collapsed": "expanded"
        }
      }
    },
    {
      "id": "fn-13",
      "type": "runJavascript",
      "configuration": {
        "code": "const fn_13 = ({ merge, ...inputs }) => {\n  const entries = Object.entries(inputs).sort();\n  if (merge) {\n    const context = [];\n    const parts = [];\n    for (const [, input] of entries) {\n      const c = asContextArray(input);\n      let lastIndex = c.length - 1;\n      let last;\n      do {\n        last = c[lastIndex--];\n      } while (lastIndex >= 0 && last.role === \"$metadata\");\n      if (last) {\n        parts.push(...last.parts);\n      }\n    }\n    context.push({ parts, role: \"user\" });\n    return { context };\n  } else {\n    let mode;\n    const [f, ...rest] = entries;\n    if (!f) {\n      return { context: [] };\n    }\n    const first = asContextArray(f[1]);\n    const firstOpenSplits = scanForSplits(first);\n    const preambleIndices = [];\n    for (const [, input] of rest) {\n      const c = asContextArray(input);\n      const hasOpenSplits = scanForSplits(c);\n      if (hasOpenSplits) {\n        preambleIndices.push(hasOpenSplits[1]);\n      }\n    }\n    if (!firstOpenSplits) {\n      if (preambleIndices.length === 0) {\n        mode = \"simple\";\n      } else {\n        mode = \"adhoc\";\n      }\n    } else {\n      const preamblesMatch =\n        preambleIndices.length > 0 &&\n        preambleIndices.every((value) => value === firstOpenSplits[1]);\n      if (preamblesMatch) {\n        mode = \"preamble\";\n      } else {\n        if (firstOpenSplits[1] === first.length - 1) {\n          mode = \"single\";\n        } else {\n          mode = \"adhoc\";\n        }\n      }\n    }\n    const context = [];\n    if (mode === \"adhoc\") {\n      for (const [, input] of entries) {\n        const c = asContextArray(input);\n        context.push(...c);\n      }\n      return { context };\n    } else if (mode === \"simple\") {\n      const splitId = Math.random().toString(36).substring(7);\n      context.push({\n        role: \"$metadata\",\n        type: \"split\",\n        data: { type: \"start\", id: splitId },\n      });\n      for (const [, input] of entries) {\n        const c = asContextArray(input);\n        context.push(...c);\n        context.push({\n          role: \"$metadata\",\n          type: \"split\",\n          data: { type: \"next\", id: splitId },\n        });\n      }\n    } else if (mode === \"preamble\") {\n      const preambleIndex = firstOpenSplits?.[1] || 0;\n      const preamble = entries[0][1].slice(0, preambleIndex + 1);\n      context.push(...preamble);\n      const splitId = preamble[preamble.length - 1].data.id;\n      for (const [, input] of entries) {\n        let c = asContextArray(input);\n        if (preambleIndex >= 0) {\n          c = c.slice(preambleIndex + 1);\n        }\n        if (c.length) {\n          context.push(...c);\n          context.push({\n            role: \"$metadata\",\n            type: \"split\",\n            data: { type: \"next\", id: splitId },\n          });\n        }\n      }\n    } else if (mode === \"single\") {\n      const splitId = first[first.length - 1].data.id;\n      context.push(...first);\n      for (const [, input] of rest) {\n        const c = asContextArray(input);\n        context.push(...c);\n        context.push({\n          role: \"$metadata\",\n          type: \"split\",\n          data: { type: \"next\", id: splitId },\n        });\n      }\n    }\n    const last = context[context.length - 1];\n    last.data.type = \"end\";\n    return { context };\n  }\n  function asContextArray(input) {\n    return Array.isArray(input) ? input : [input];\n  }\n  __name(asContextArray, \"asContextArray\");\n  function scanForSplits(c) {\n    const stack = [];\n    for (const [i, item] of c.entries()) {\n      if (item.role !== \"$metadata\") continue;\n      if (item.type !== \"split\") continue;\n      if (item.data.type === \"start\") {\n        stack.push([item.data.id, i]);\n      }\n      if (item.data.type === \"end\") {\n        const [id] = stack.pop() || [];\n        if (id !== item.data.id) {\n          console.warn(\n            \"Split integrity error: mismatched split start/end markers. Start:\",\n            id,\n            \"End:\",\n            item.data.id\n          );\n          return null;\n        }\n      }\n    }\n    return stack.pop() || null;\n  }\n  __name(scanForSplits, \"scanForSplits\");\n};\n",
        "name": "fn_13",
        "raw": true
      },
      "metadata": {
        "title": "Add Tool Response",
        "description": "Adding tool response to context",
        "visual": {
          "x": 6754.000000000001,
          "y": -534.0000000000002,
          "collapsed": "expanded"
        }
      }
    },
    {
      "id": "input-3",
      "type": "input",
      "configuration": {
        "schema": {
          "type": "object",
          "properties": {
            "tools": {
              "title": "Tools",
              "description": "(Optional) Add tools to this list for the worker to use when needed",
              "type": "array",
              "items": {
                "type": "object",
                "behavior": ["board"]
              },
              "behavior": ["config"],
              "default": "[]"
            }
          }
        }
      },
      "metadata": {
        "title": "Tools Input",
        "description": "Specify the tools to use",
        "visual": {
          "x": 3705.000000000001,
          "y": 202.00000000000023,
          "collapsed": "expanded"
        },
        "tags": ["start"]
      }
    },
    {
      "id": "output-14",
      "type": "output",
      "configuration": {
        "schema": {
          "type": "object",
          "properties": {
            "out": {
              "title": "Context out",
              "type": "array",
              "items": {
                "type": "object",
                "behavior": ["llm-content"]
              }
            }
          }
        }
      },
      "metadata": {
        "title": "Tool Output",
        "description": "Return tool results as output",
        "visual": {
          "x": 7113.999999999999,
          "y": -538,
          "collapsed": "expanded"
        }
      }
    },
    {
      "id": "input-58c1588f",
      "type": "input",
      "metadata": {
        "visual": {
          "x": 2366.000000000001,
          "y": 222,
          "collapsed": "expanded"
        },
        "tags": [
          {
            "type": "start",
            "label": "describe"
          }
        ],
        "title": "Describe",
        "logLevel": "debug"
      },
      "configuration": {
        "schema": {
          "properties": {},
          "type": "object",
          "required": []
        }
      }
    },
    {
      "id": "runJavascript-4e04e982",
      "type": "runJavascript",
      "metadata": {
        "visual": {
          "x": 2608.9999999999995,
          "y": 195,
          "collapsed": "expanded"
        },
        "title": "Schema from Inputs",
        "logLevel": "debug"
      },
      "configuration": {
        "outputSchema": {
          "properties": {
            "outputSchema": {
              "type": "object",
              "title": "Output Schema",
              "examples": []
            },
            "inputSchema": {
              "type": "object",
              "title": "Input Schema",
              "examples": []
            }
          },
          "type": "object",
          "required": []
        },
        "code": "function run({ $inputSchema, $outputSchema, persona, task }) {\n  const params = unique([\n    ...collectParams(textFromLLMContent(persona)),\n    ...collectParams(textFromLLMContent(task)),\n  ]);\n\n  const props = Object.fromEntries(\n    params.map((param) => [\n      toId(param),\n      {\n        title: toTitle(param),\n        description: `The value to substitute for the parameter \"${param}\"`,\n        type: \"string\",\n      },\n    ]),\n  );\n\n  const required = params.map(toId);\n\n  return {\n    inputSchema: {\n      ...$inputSchema,\n      properties: {\n        ...$inputSchema.properties,\n        ...props,\n      },\n      required: [...$inputSchema.required, ...required],\n    },\n    outputSchema: $outputSchema,\n  };\n\n  function toId(param) {\n    return `p-${param}`;\n  }\n\n  function toTitle(id) {\n    const spaced = id?.replace(/[_-]/g, \" \");\n    return (spaced?.at(0)?.toUpperCase() ?? \"\")\n      + (spaced?.slice(1)?.toLowerCase() ?? \"\");\n  }\n\n  function textFromLLMContent(content) {\n    return content?.parts.map((item) => item.text).join(\"\\n\") || \"\";\n  }\n\n  function unique(params) {\n    return Array.from(new Set(params));\n  }\n\n  function collectParams(text) {\n    if (!text) return [];\n    const matches = text.matchAll(/{{(?<name>[\\w-]+)}}/g);\n    return Array.from(matches).map(\n      (match) => match.groups?.name || \"\",\n    );\n  }\n}",
        "name": "run",
        "raw": true
      }
    },
    {
      "id": "output-acc3ef03",
      "type": "output",
      "metadata": {
        "visual": {
          "x": 3044.000000000001,
          "y": 193,
          "collapsed": "expanded"
        },
        "title": "Schemas",
        "logLevel": "debug"
      },
      "configuration": {
        "schema": {
          "properties": {
            "inputSchema": {
              "type": "object",
              "title": "Input Schema",
              "examples": []
            },
            "outputSchema": {
              "type": "object",
              "title": "Output Schema",
              "examples": []
            }
          },
          "type": "object",
          "required": []
        }
      }
    },
    {
      "id": "runJavascript-f4247fc6",
      "type": "runJavascript",
      "metadata": {
        "visual": {
          "x": 1796,
          "y": -251.99999999999997,
          "collapsed": "advanced"
        },
        "title": "Substitute Params",
        "logLevel": "debug"
      },
      "configuration": {
        "outputSchema": {
          "properties": {
            "in": {
              "type": "array",
              "title": "Context in",
              "examples": [],
              "items": {
                "type": "object",
                "behavior": ["llm-content"]
              }
            },
            "persona": {
              "type": "object",
              "behavior": ["llm-content"],
              "title": "Persona",
              "examples": [],
              "default": "null"
            },
            "task": {
              "type": "object",
              "behavior": ["llm-content"],
              "title": "Task",
              "examples": [],
              "default": "null"
            }
          },
          "type": "object",
          "required": []
        },
        "code": "function substitute({ in: context, persona, task, ...inputs }) {\n  const params = mergeParams(findParams(persona), findParams(task));\n\n  // Make sure that all params are present in the values and collect\n  // them into a single object.\n  const values = collectValues(params, inputs);\n\n  return {\n    in: context,\n    persona: subContent(persona, values),\n    task: subContent(task, values),\n  };\n\n  function unique(params) {\n    return Array.from(new Set(params));\n  }\n\n  function toId(param) {\n    return `p-${param}`;\n  }\n\n  function findParams(content) {\n    const parts = content?.parts;\n    if (!parts) return [];\n    const results = parts.flatMap((part) => {\n      const matches = part.text.matchAll(/{{(?<name>[\\w-]+)}}/g);\n      return unique(Array.from(matches))\n        .map((match) => {\n          const name = match.groups?.name || \"\";\n          if (!name) return null;\n          return { name, locations: [{ part, parts }] };\n        })\n        .filter(Boolean);\n    });\n    return results;\n  }\n\n  function mergeParams(...paramList) {\n    return paramList.reduce((acc, params) => {\n      for (const param of params) {\n        const { name, locations } = param;\n        const existing = acc[name];\n        if (existing) {\n          existing.push(...locations);\n        } else {\n          acc[name] = locations;\n        }\n      }\n      return acc;\n    }, {});\n  }\n\n  function subContent(content, values) {\n    if (Array.isArray(content)) {\n      content = content.at(-1);\n    }\n    if (!content) return null;\n    return {\n      role: content.role || \"user\",\n      parts: mergeTextParts(\n        splitToTemplateParts(content).flatMap((part) => {\n          if (part.param) {\n            const value = values[part.param];\n            if (typeof value === \"string\") {\n              return { text: value };\n            } else if (isLLMContent(value)) {\n              return value.parts;\n            } else if (isLLMContentArray(value)) {\n              const last = value.at(-1);\n              return last.parts;\n            } else {\n              return { text: JSON.stringify(value) };\n            }\n          } else {\n            return part;\n          }\n        })\n      ),\n    };\n  }\n\n  function mergeTextParts(parts) {\n    const merged = [];\n    for (const part of parts) {\n      if (part.text) {\n        const last = merged[merged.length - 1];\n        if (last?.text) {\n          last.text += part.text;\n        } else {\n          merged.push(part);\n        }\n      } else {\n        merged.push(part);\n      }\n    }\n    return merged;\n  }\n\n  function toTitle(id) {\n    const spaced = id?.replace(/[_-]/g, \" \");\n    return (\n      (spaced?.at(0)?.toUpperCase() ?? \"\") +\n      (spaced?.slice(1)?.toLowerCase() ?? \"\")\n    );\n  }\n\n  /**\n   * Takes an LLM Content and splits it further into parts where\n   * each {{param}} substitution is a separate part.\n   */\n  function splitToTemplateParts(content) {\n    const parts = [];\n    for (const part of content.parts) {\n      const matches = part.text.matchAll(/{{(?<name>[\\w-]+)}}/g);\n      let start = 0;\n      for (const match of matches) {\n        const name = match.groups?.name || \"\";\n        const end = match.index;\n        if (end > start) {\n          parts.push({ text: part.text.slice(start, end) });\n        }\n        parts.push({ param: name });\n        start = end + match[0].length;\n      }\n      if (start < part.text.length) {\n        parts.push({ text: part.text.slice(start) });\n      }\n    }\n    return parts;\n  }\n\n  function collectValues(params, inputs) {\n    const values = {};\n    for (const param in params) {\n      const id = toId(param);\n      const value = inputs[id];\n      if (!value) {\n        const title = toTitle(param);\n        throw new Error(`Missing required parameter: ${title}`);\n      }\n      values[param] = value;\n    }\n    return values;\n  }\n\n  /**\n   * Copied from @google-labs/breadboard\n   */\n  function isLLMContent(nodeValue) {\n    if (typeof nodeValue !== \"object\" || !nodeValue) return false;\n    if (nodeValue === null || nodeValue === undefined) return false;\n\n    return \"parts\" in nodeValue && Array.isArray(nodeValue.parts);\n  }\n\n  function isLLMContentArray(nodeValue) {\n    if (!Array.isArray(nodeValue)) return false;\n    if (nodeValue.length === 0) return true;\n    return isLLMContent(nodeValue.at(-1));\n  }\n}",
        "name": "substitute",
        "raw": true
      }
    }
  ],
  "graphs": {
    "boardToFunction": {
      "title": "Board to functions",
      "description": "Use this board to convert specified boards into function-calling signatures",
      "edges": [
        {
          "from": "fn-4",
          "to": "output-2",
          "out": "function",
          "in": "function"
        },
        {
          "from": "fn-4",
          "to": "output-2",
          "out": "board",
          "in": "boardURL"
        },
        {
          "from": "fn-4",
          "to": "output-2",
          "out": "flags",
          "in": "flags"
        },
        {
          "from": "curry-3",
          "to": "fn-4",
          "out": "board",
          "in": "board"
        },
        {
          "from": "input-1",
          "to": "curry-3",
          "out": "item",
          "in": "$board"
        },
        {
          "from": "input-1",
          "to": "curry-3",
          "out": "context",
          "in": "context"
        }
      ],
      "nodes": [
        {
          "id": "output-2",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "function": {
                  "type": "string",
                  "title": "function"
                },
                "boardURL": {
                  "type": "string",
                  "title": "boardURL"
                },
                "flags": {
                  "type": "string",
                  "title": "flags"
                }
              }
            }
          },
          "metadata": {
            "visual": {
              "x": 917,
              "y": 76,
              "collapsed": "expanded"
            },
            "title": "Text Output",
            "logLevel": "debug"
          }
        },
        {
          "id": "fn-4",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_4 = ({board:board2})=>{const b=board2;const inputs=b.nodes.filter(node=>node.type===\"input\")||[];const outputs=b.nodes.filter(node=>node.type===\"output\");if(outputs.length===0){throw new Error(\"No outputs found\")}const inputSchema=inputs[0]?.configuration?.schema||{};const outputSchema=outputs[0].configuration?.schema;if(!outputSchema){throw new Error(\"No output schema found\")}const properties={};const flags={};for(const key in inputSchema.properties){const property=inputSchema.properties[key];const isObject=property.type===\"object\";const isArray=property.type===\"array\";const type=isObject||isArray?\"string\":property.type;if(isObject&&property.behavior?.includes(\"llm-content\")){flags.inputLLMContent=key}else if(isArray&&property.items?.behavior?.includes(\"llm-content\")){flags.inputLLMContentArray=key;continue}const description2=property.description||property.title||\"text\";properties[key]={type,description:description2}}if(flags.inputLLMContentArray){if(flags.inputLLMContentArray!==\"context\"){const c=b.args?.context;if(c){b.args??={};b.args[flags.inputLLMContentArray]=c;delete b.args.context}}}else{delete b.args?.context}for(const key in outputSchema.properties){const property=outputSchema.properties[key];const isObject=property.type===\"object\";const isArray=property.type===\"array\";if(isObject&&property.behavior?.includes(\"llm-content\")){flags.outputLLMContent=key}else if(isArray&&property.items?.behavior?.includes(\"llm-content\")){flags.outputLLMContentArray=key}}const name=b.title?.replace(/\\W/g,\"_\")||\"function\";const description=b.description;const parameters=Object.entries(properties).length>0?{type:\"object\",properties}:void 0;const f={name,description};if(parameters){f.parameters=parameters}return{function:f,returns:outputSchema,flags,board:board2}};",
            "name": "fn_4",
            "raw": true
          },
          "metadata": {
            "title": "Get Function Signature from board",
            "visual": {
              "x": 492,
              "y": 0,
              "collapsed": "expanded"
            }
          }
        },
        {
          "id": "curry-3",
          "type": "curry",
          "configuration": {},
          "metadata": {
            "visual": {
              "x": 252,
              "y": 97,
              "collapsed": "expanded"
            }
          }
        },
        {
          "id": "input-1",
          "type": "input",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "item": {
                  "title": "Board",
                  "behavior": ["board"],
                  "description": "The board to curry. Can be a BoardCapability, a graph or a URL",
                  "type": "string"
                },
                "context": {
                  "type": "string",
                  "title": "context"
                }
              },
              "required": ["item", "context"]
            }
          },
          "metadata": {
            "visual": {
              "x": 0,
              "y": 97,
              "collapsed": "expanded"
            },
            "title": "Context Input",
            "logLevel": "debug",
            "tags": ["start"]
          }
        }
      ],
      "graphs": {},
      "url": "file://fsapi~bgl/specialist-2.bgl.json#boardToFunction"
    },
    "invokeBoardWithArgs": {
      "title": "Invoke Board With Args",
      "description": "Takes one item of `boardInvocationAssembler` output and invokes it as a board with arguments.",
      "version": "0.0.1",
      "edges": [
        {
          "from": "fn-7",
          "to": "output-2",
          "out": "item",
          "in": "item"
        },
        {
          "from": "fn-6",
          "to": "fn-7",
          "out": "result",
          "in": "result"
        },
        {
          "from": "fn-4",
          "to": "fn-7",
          "out": "flags",
          "in": "flags"
        },
        {
          "from": "invoke-5",
          "to": "fn-6",
          "out": "*",
          "in": ""
        },
        {
          "from": "input-1",
          "to": "fn-3",
          "out": "item",
          "in": "item"
        },
        {
          "from": "input-1",
          "to": "fn-4",
          "out": "item",
          "in": "item"
        },
        {
          "from": "fn-3",
          "to": "invoke-5",
          "out": "*",
          "in": ""
        }
      ],
      "nodes": [
        {
          "id": "output-2",
          "type": "output",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "item": {
                  "type": "string",
                  "title": "item"
                }
              }
            }
          },
          "metadata": {
            "visual": {
              "x": 1629,
              "y": 439,
              "collapsed": "expanded"
            },
            "title": "Text Output",
            "logLevel": "debug"
          }
        },
        {
          "id": "fn-7",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_7 = ({result,flags})=>{let contentDetected=false;const inputs=result;const item=[];const f=flags;if(f){if(f.outputLLMContent){const content=inputs[f.outputLLMContent];content.role=\"tool\";item.push(content);contentDetected=true}else if(f.outputLLMContentArray){const contentArray=inputs[f.outputLLMContentArray];contentArray.forEach(content=>{if(content.role!==\"$metadata\"){content.role=\"tool\"}item.push(content)});contentDetected=true}}else{for(const key in inputs){const input=inputs[key];if(input!==null&&typeof input===\"object\"&&\"content\"in input){const content=input.content;if(content.parts&&Array.isArray(content.parts)){content.role=\"tool\";item.push(content);contentDetected=true}}}}if(!contentDetected){const text=JSON.stringify(inputs);item.push({parts:[{text}],role:\"tool\"})}return{item}};",
            "name": "fn_7",
            "raw": true
          },
          "metadata": {
            "title": "Add Looper Task",
            "description": "If there is a pending Looper task, add it.",
            "visual": {
              "x": 1257,
              "y": 340,
              "collapsed": "expanded"
            }
          }
        },
        {
          "id": "fn-6",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_6 = result=>{return{result}};",
            "name": "fn_6",
            "raw": true
          },
          "metadata": {
            "title": "Read Progress so far",
            "description": "Packing results",
            "visual": {
              "x": 885,
              "y": 9,
              "collapsed": "expanded"
            }
          }
        },
        {
          "id": "fn-4",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_4 = ({item})=>{const{$flags}=item;return{flags:$flags}};",
            "name": "fn_4",
            "raw": true
          },
          "metadata": {
            "title": "Get flags",
            "description": "Getting flags for the board invocation",
            "visual": {
              "x": 885,
              "y": 342,
              "collapsed": "expanded"
            }
          }
        },
        {
          "id": "invoke-5",
          "type": "invoke",
          "configuration": {},
          "metadata": {
            "title": "Invoke board",
            "description": "Invoking the board with unpacked arguments",
            "visual": {
              "x": 624,
              "y": 97,
              "collapsed": "expanded"
            }
          }
        },
        {
          "id": "input-1",
          "type": "input",
          "configuration": {
            "schema": {
              "type": "object",
              "properties": {
                "item": {
                  "type": "string",
                  "title": "item"
                }
              },
              "required": ["item"]
            }
          },
          "metadata": {
            "visual": {
              "x": 0,
              "y": 450,
              "collapsed": "expanded"
            },
            "title": "Context Input",
            "logLevel": "debug",
            "tags": ["start"]
          }
        },
        {
          "id": "fn-3",
          "type": "runJavascript",
          "configuration": {
            "code": "const fn_3 = ({item})=>{const{$flags,...result}=item;return result};",
            "name": "fn_3",
            "raw": true
          },
          "metadata": {
            "title": "Unpack args",
            "description": "Unpacking board arguments",
            "visual": {
              "x": 252,
              "y": 0,
              "collapsed": "expanded"
            }
          }
        }
      ],
      "graphs": {}
    }
  },
  "version": "0.0.1"
}
