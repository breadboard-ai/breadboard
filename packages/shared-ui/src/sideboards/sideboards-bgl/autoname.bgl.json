{
  "title": "Autonaming",
  "description": "",
  "version": "0.0.1",
  "nodes": [
    {
      "id": "input",
      "type": "input",
      "metadata": {
        "title": "Input"
      }
    },
    {
      "id": "run-module",
      "type": "runModule",
      "configuration": {
        "$module": "main"
      },
      "metadata": {
        "title": "Autonaming"
      }
    },
    {
      "id": "output",
      "type": "output",
      "metadata": {
        "title": "Output"
      }
    }
  ],
  "edges": [
    {
      "from": "input",
      "to": "run-module",
      "out": "*",
      "in": ""
    },
    {
      "from": "run-module",
      "to": "output",
      "out": "*",
      "in": ""
    }
  ],
  "imports": {
    "a2": {
      "url": "embed://a2/a2.bgl.json"
    }
  },
  "main": "main",
  "modules": {
    "main": {
      "code": "/**\n * @fileoverview Add a description for your module here.\n */\nimport { GeminiPrompt } from \"./a2/gemini-prompt\";\nimport { defaultSafetySettings } from \"./a2/gemini\";\nimport { err, ok, llm } from \"./a2/utils\";\nexport { invoke as default, describe };\nconst NODES_RESULT_SCHEMA = {\n    nodes: {\n        type: \"array\",\n        items: {\n            type: \"object\",\n            properties: {\n                id: {\n                    type: \"string\",\n                    description: \"node id (the value of the 'id' property)\",\n                },\n                currentTitle: {\n                    type: \"string\",\n                    description: \"Current title of the node\",\n                },\n                suggestedTitle: {\n                    type: \"string\",\n                    description: \"Suggested title of the node, verb-first, action oriented\",\n                },\n                suggestedDescription: {\n                    type: \"string\",\n                    description: \"Suggested description of the node\",\n                },\n                reasoning: {\n                    type: \"string\",\n                    description: \"The reasoning behind the suggested change\",\n                },\n                note: {\n                    type: \"string\",\n                    description: \"Additional notes, if any\",\n                },\n            },\n            required: [\n                \"currentTitle\",\n                \"suggestedTitle\",\n                \"suggestedDescription\",\n                \"reasoning\",\n            ],\n        },\n    },\n};\nfunction resultSchema(hasNodes) {\n    return {\n        type: \"object\",\n        properties: {\n            analysis: {\n                type: \"string\",\n                description: \"Overall analysis of the JSON structure\",\n            },\n            suggestions: {\n                type: \"object\",\n                description: \"The naming suggestions and the reasoning behind them\",\n                properties: {\n                    graph: {\n                        type: \"object\",\n                        description: \"Suggestions for the graph title and description\",\n                        properties: {\n                            currentTitle: {\n                                type: \"string\",\n                                description: \"Current title of the graph\",\n                            },\n                            currentTitleAndDescriptionMatch: {\n                                type: \"number\",\n                                description: \"How much the curent title and description match the graph structure\" +\n                                    \"already (0 - no match at all, 100 - perfect match)\",\n                            },\n                            suggestedTitle: {\n                                type: \"string\",\n                                description: \"Suggested title of the graph\",\n                            },\n                            suggestedDescription: {\n                                type: \"string\",\n                                description: \"Suggested description of the graph\",\n                            },\n                            reasoning: {\n                                type: \"string\",\n                                description: \"The reasoning behind the suggested change\",\n                            },\n                            note: {\n                                type: \"string\",\n                                description: \"Additional notes, if any\",\n                            },\n                        },\n                        required: [\"currentTitle\", \"suggestedTitle\", \"reasoning\"],\n                    },\n                    ...(hasNodes ? NODES_RESULT_SCHEMA : {}),\n                    rationaleForChanges: {\n                        type: \"string\",\n                        description: \"The rationale for changes -- how and why do they improve the graph?\",\n                    },\n                    otherConsiderations: {\n                        type: \"string\",\n                        description: \"Other considerations and items of note related to the graph and the suggested changes\",\n                    },\n                },\n                required: [\"graph\", ...(hasNodes ? [\"nodes\"] : [])],\n            },\n        },\n    };\n}\nfunction getArguments(context) {\n    const part = context?.at(-1)?.parts?.at(0);\n    if (!(part && \"json\" in part)) {\n        return err(`Invalid input arguments`);\n    }\n    return part.json;\n}\nconst FOR_NODES = `For node titles and descriptions:\n- Either or both the title and description may be completely stale and no longer relevant. \n  Use what is in \"configuration\" property to suggest new titles/descriptions and not anchor on\n  the title/description current values.\n- When creating a title or description for a node, make sure to only describe what this nodes does\n  and avoid adding context from other nodes, because the other nodes may change over time. We want\n  to ensure that the node's title and description stay independent of other nodes.`;\nasync function invoke({ context }) {\n    // TODO: Make the autonamer aware of \"no-nodes\" renames.\n    const args = getArguments(context);\n    if (!ok(args))\n        return args;\n    console.log(\"ARGS\", args);\n    const { graph, graphId, nodes } = args;\n    // Reset title and description for graph, to reduce the chance of\n    // LLM anchoring on old title.\n    // graph.title = \"Untitled Graph\";\n    // graph.description = \"\";\n    // Remove any intent/instruction bits that might have been in the BGL.\n    if (graph.metadata) {\n        delete graph.metadata.instruction;\n        delete graph.metadata.intent;\n        delete graph.metadata.visual;\n    }\n    // TODO: For subgraphs, add a clause about \"context\" input,\n    // so that the description is useful for the Introducer.\n    let graphTitleInstruction = \"Each title must be short and to the point\";\n    if (graphId) {\n        graph.parameters = {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"string\",\n                },\n            },\n        };\n        graphTitleInstruction =\n            \"Each title must be verb-first, action oriented, short and to the point\";\n    }\n    const nodeMap = new Map(graph.nodes.map((node) => {\n        return [node.id, node];\n    }));\n    const finalNodes = [];\n    for (const id of nodes) {\n        const descriptor = nodeMap.get(id);\n        if (!descriptor ||\n            !descriptor.configuration ||\n            Object.keys(descriptor.configuration).length === 0 ||\n            descriptor.metadata?.userModified) {\n            continue;\n        }\n        finalNodes.push(id);\n        // Reset titles and descriptions of affected nodes to reduce\n        // LLM anchoring on old title.\n        if (!descriptor.metadata)\n            continue;\n        descriptor.metadata.title = \"Untitled Node\";\n        descriptor.metadata.description = \"\";\n    }\n    const hasNodes = finalNodes.length > 0;\n    const alsoNodes = hasNodes\n        ? `, \nand the nodes with these Ids:\n\n${finalNodes.map((id) => {\n            return `- ${id}`;\n        })}\n`\n        : \"\";\n    const naming = await new GeminiPrompt({\n        body: {\n            contents: [\n                llm `\nAnalyze the provided JSON structure below and provide suggestions for titles and descriptions for graph the itself${alsoNodes}\n\nWhen analyzing, make sure to evaluate how much the current title/description match the structure of the graph already,\nwith 0 being no match at all, and 100 being a perfect match.\n\nGraph:\n\n\\`\\`\\`json\n${JSON.stringify(args.graph)}\n\\`\\`\\`\n\nImportant:\n- Both the title and description must be accurate and specific. Avoid making them generic or general-purpose.\n- Either or both the title and description may be completely stale and no longer relevant. When suggesting new graph title/description,\n  rely on the graph structure and contents, not the current title/description values.\n- The descriptions must be detailed, yet concise, suitable for a JSON schema description used in LLM function calls. If provided, use the\n  \"parameters\" property describe the input parameters of the function call.\n- ${graphTitleInstruction}, so that it could be visible even in a small space on mobile UI.\n- The audience who will look at the titles and descriptions will be non-technical, so avoid jargon and \n  don't mention graphs or JSON, etc.\n\n${hasNodes ? FOR_NODES : \"\"}\n\n`.asContent(),\n            ],\n            safetySettings: defaultSafetySettings(),\n            generationConfig: {\n                responseMimeType: \"application/json\",\n                responseSchema: resultSchema(hasNodes),\n            },\n        },\n    }).invoke();\n    if (!ok(naming))\n        return naming;\n    return { context: naming.all };\n}\nasync function describe() {\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context in\",\n                },\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context out\",\n                },\n            },\n        },\n    };\n}\n",
      "metadata": {
        "title": "main",
        "source": {
          "code": "/**\n * @fileoverview Add a description for your module here.\n */\n\nimport { GeminiPrompt } from \"./a2/gemini-prompt\";\nimport { type GeminiSchema, defaultSafetySettings } from \"./a2/gemini\";\nimport { err, ok, llm } from \"./a2/utils\";\n\nexport { invoke as default, describe };\n\nexport type AutonamingResult = {\n  analysis: string;\n  suggestions: {\n    graph: {\n      currentTitle: string;\n      currentTitleAndDescriptionMatch: number;\n      suggestedTitle: string;\n      suggestedDescription: string;\n      reasoning: string;\n      note?: string;\n    };\n    nodes: {\n      id: string;\n      currentTitle: string;\n      suggestedTitle: string;\n      suggestedDescription: string;\n      reasoning: string;\n      note?: string;\n    }[];\n  };\n  rationaleForChanges: string;\n  otherConsiderations?: string;\n};\n\ntype Inputs = {\n  context: LLMContent[];\n};\n\ntype Outputs = {\n  context: LLMContent[];\n};\n\ntype PartialNodeDescriptor = {\n  id: string;\n  configuration: Record<string, object>;\n  metadata?: {\n    title?: string;\n    description?: string;\n    userModified?: boolean;\n  };\n};\n\nconst NODES_RESULT_SCHEMA: GeminiSchema[\"properties\"] = {\n  nodes: {\n    type: \"array\",\n    items: {\n      type: \"object\",\n      properties: {\n        id: {\n          type: \"string\",\n          description: \"node id (the value of the 'id' property)\",\n        },\n        currentTitle: {\n          type: \"string\",\n          description: \"Current title of the node\",\n        },\n        suggestedTitle: {\n          type: \"string\",\n          description:\n            \"Suggested title of the node, verb-first, action oriented\",\n        },\n        suggestedDescription: {\n          type: \"string\",\n          description: \"Suggested description of the node\",\n        },\n        reasoning: {\n          type: \"string\",\n          description: \"The reasoning behind the suggested change\",\n        },\n        note: {\n          type: \"string\",\n          description: \"Additional notes, if any\",\n        },\n      },\n      required: [\n        \"currentTitle\",\n        \"suggestedTitle\",\n        \"suggestedDescription\",\n        \"reasoning\",\n      ],\n    },\n  },\n};\n\nfunction resultSchema(hasNodes: boolean): GeminiSchema {\n  return {\n    type: \"object\",\n    properties: {\n      analysis: {\n        type: \"string\",\n        description: \"Overall analysis of the JSON structure\",\n      },\n      suggestions: {\n        type: \"object\",\n        description: \"The naming suggestions and the reasoning behind them\",\n        properties: {\n          graph: {\n            type: \"object\",\n            description: \"Suggestions for the graph title and description\",\n            properties: {\n              currentTitle: {\n                type: \"string\",\n                description: \"Current title of the graph\",\n              },\n              currentTitleAndDescriptionMatch: {\n                type: \"number\",\n                description:\n                  \"How much the curent title and description match the graph structure\" +\n                  \"already (0 - no match at all, 100 - perfect match)\",\n              },\n              suggestedTitle: {\n                type: \"string\",\n                description: \"Suggested title of the graph\",\n              },\n              suggestedDescription: {\n                type: \"string\",\n                description: \"Suggested description of the graph\",\n              },\n              reasoning: {\n                type: \"string\",\n                description: \"The reasoning behind the suggested change\",\n              },\n              note: {\n                type: \"string\",\n                description: \"Additional notes, if any\",\n              },\n            },\n            required: [\"currentTitle\", \"suggestedTitle\", \"reasoning\"],\n          },\n          ...(hasNodes ? NODES_RESULT_SCHEMA : {}),\n          rationaleForChanges: {\n            type: \"string\",\n            description:\n              \"The rationale for changes -- how and why do they improve the graph?\",\n          },\n          otherConsiderations: {\n            type: \"string\",\n            description:\n              \"Other considerations and items of note related to the graph and the suggested changes\",\n          },\n        },\n        required: [\"graph\", ...(hasNodes ? [\"nodes\"] : [])],\n      },\n    },\n  };\n}\n\n/**\n * Represents an edge in a graph.\n */\nexport type Edge = {\n  /**\n   * The node that the edge is coming from.\n   */\n  from: string;\n\n  /**\n   * The node that the edge is going to.\n   */\n  to: string;\n\n  /**\n   * The input of the `to` node. If this value is undefined, then\n   * the then no data is passed as output of the `from` node.\n   */\n  in?: string;\n\n  /**\n   * The output of the `from` node. If this value is \"*\", then all outputs\n   * of the `from` node are passed to the `to` node. If this value is undefined,\n   * then no data is passed to any inputs of the `to` node.\n   */\n  out?: string;\n\n  /**\n   * If true, this edge is optional: the data that passes through it is not\n   * considered a required input to the node.\n   */\n  optional?: boolean;\n\n  /**\n   * If true, this edge acts as a constant: the data that passes through it\n   * remains available even after the node has consumed it.\n   */\n  constant?: boolean;\n};\n\ntype PartialGraphDescriptor = {\n  title?: string;\n  metadata?: {\n    intent?: string;\n    instruction?: string;\n    userModified?: string;\n    visual?: unknown;\n  };\n  parameters?: {\n    type: \"object\";\n    properties: {\n      context: {\n        type: \"string\";\n      };\n    };\n  };\n  description?: string;\n  nodes: PartialNodeDescriptor[];\n  edges: Edge[];\n};\n\ntype Arguments = {\n  graph: PartialGraphDescriptor;\n  graphId: string;\n  nodes: string[];\n};\n\nfunction getArguments(context?: LLMContent[]): Outcome<Arguments> {\n  const part = context?.at(-1)?.parts?.at(0);\n  if (!(part && \"json\" in part)) {\n    return err(`Invalid input arguments`);\n  }\n  return part.json as Arguments;\n}\n\nconst FOR_NODES = `For node titles and descriptions:\n- Either or both the title and description may be completely stale and no longer relevant. \n  Use what is in \"configuration\" property to suggest new titles/descriptions and not anchor on\n  the title/description current values.\n- When creating a title or description for a node, make sure to only describe what this nodes does\n  and avoid adding context from other nodes, because the other nodes may change over time. We want\n  to ensure that the node's title and description stay independent of other nodes.`;\n\nasync function invoke({ context }: Inputs): Promise<Outcome<Outputs>> {\n  // TODO: Make the autonamer aware of \"no-nodes\" renames.\n\n  const args = getArguments(context);\n  if (!ok(args)) return args;\n  console.log(\"ARGS\", args);\n  const { graph, graphId, nodes } = args;\n\n  // Reset title and description for graph, to reduce the chance of\n  // LLM anchoring on old title.\n  // graph.title = \"Untitled Graph\";\n  // graph.description = \"\";\n\n  // Remove any intent/instruction bits that might have been in the BGL.\n  if (graph.metadata) {\n    delete graph.metadata.instruction;\n    delete graph.metadata.intent;\n    delete graph.metadata.visual;\n  }\n\n  // TODO: For subgraphs, add a clause about \"context\" input,\n  // so that the description is useful for the Introducer.\n\n  let graphTitleInstruction = \"Each title must be short and to the point\";\n\n  if (graphId) {\n    graph.parameters = {\n      type: \"object\",\n      properties: {\n        context: {\n          type: \"string\",\n        },\n      },\n    };\n    graphTitleInstruction =\n      \"Each title must be verb-first, action oriented, short and to the point\";\n  }\n\n  const nodeMap = new Map(\n    graph.nodes.map((node) => {\n      return [node.id, node];\n    })\n  );\n  const finalNodes: string[] = [];\n  for (const id of nodes) {\n    const descriptor = nodeMap.get(id);\n    if (\n      !descriptor ||\n      !descriptor.configuration ||\n      Object.keys(descriptor.configuration).length === 0 ||\n      descriptor.metadata?.userModified\n    ) {\n      continue;\n    }\n    finalNodes.push(id);\n    // Reset titles and descriptions of affected nodes to reduce\n    // LLM anchoring on old title.\n    if (!descriptor.metadata) continue;\n    descriptor.metadata.title = \"Untitled Node\";\n    descriptor.metadata.description = \"\";\n  }\n\n  const hasNodes = finalNodes.length > 0;\n\n  const alsoNodes = hasNodes\n    ? `, \nand the nodes with these Ids:\n\n${finalNodes.map((id) => {\n  return `- ${id}`;\n})}\n`\n    : \"\";\n\n  const naming = await new GeminiPrompt({\n    body: {\n      contents: [\n        llm`\nAnalyze the provided JSON structure below and provide suggestions for titles and descriptions for graph the itself${alsoNodes}\n\nWhen analyzing, make sure to evaluate how much the current title/description match the structure of the graph already,\nwith 0 being no match at all, and 100 being a perfect match.\n\nGraph:\n\n\\`\\`\\`json\n${JSON.stringify(args.graph)}\n\\`\\`\\`\n\nImportant:\n- Both the title and description must be accurate and specific. Avoid making them generic or general-purpose.\n- Either or both the title and description may be completely stale and no longer relevant. When suggesting new graph title/description,\n  rely on the graph structure and contents, not the current title/description values.\n- The descriptions must be detailed, yet concise, suitable for a JSON schema description used in LLM function calls. If provided, use the\n  \"parameters\" property describe the input parameters of the function call.\n- ${graphTitleInstruction}, so that it could be visible even in a small space on mobile UI.\n- The audience who will look at the titles and descriptions will be non-technical, so avoid jargon and \n  don't mention graphs or JSON, etc.\n\n${hasNodes ? FOR_NODES : \"\"}\n\n`.asContent(),\n      ],\n      safetySettings: defaultSafetySettings(),\n      generationConfig: {\n        responseMimeType: \"application/json\",\n        responseSchema: resultSchema(hasNodes),\n      },\n    },\n  }).invoke();\n  if (!ok(naming)) return naming;\n  return { context: naming.all };\n}\n\nasync function describe() {\n  return {\n    inputSchema: {\n      type: \"object\",\n      properties: {\n        context: {\n          type: \"array\",\n          items: { type: \"object\", behavior: [\"llm-content\"] },\n          title: \"Context in\",\n        },\n      },\n    } satisfies Schema,\n    outputSchema: {\n      type: \"object\",\n      properties: {\n        context: {\n          type: \"array\",\n          items: { type: \"object\", behavior: [\"llm-content\"] },\n          title: \"Context out\",\n        },\n      },\n    } satisfies Schema,\n  };\n}\n",
          "language": "typescript"
        },
        "description": "Add a description for your module here.",
        "runnable": true
      }
    }
  },
  "metadata": {
    "tags": [],
    "visual": {
      "presentation": {
        "themes": {
          "98f67196-378d-4397-ae1b-fe3aead245c5": {
            "themeColors": {
              "primaryColor": "#246db5",
              "secondaryColor": "#5cadff",
              "backgroundColor": "#ffffff",
              "textColor": "#1a1a1a",
              "primaryTextColor": "#ffffff"
            },
            "template": "basic",
            "splashScreen": {
              "storedData": {
                "handle": "/images/app/generic-flow.jpg",
                "mimeType": "image/jpeg"
              }
            }
          }
        },
        "theme": "98f67196-378d-4397-ae1b-fe3aead245c5"
      }
    }
  }
}