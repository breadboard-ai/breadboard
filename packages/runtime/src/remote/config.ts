/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {
  AllowFilterFunction,
  DataStore,
  Kit,
  NodeTypeIdentifier,
} from "@breadboard-ai/types";

/**
 * A detailed specification for ProxyServer and ProxyClient.
 *
 * Example:
 * ```js
 * {
 *   node: "secrets",
 *   protect: {
 *     PALM_KEY: ["palm-generateText", "palm-embedText"],
 *     NODE_SPECIFIC_KEY: "specific-node-type",
 *     PINECONE_KEY: {
 *       receiver: "fetch",
 *       inputs: {
 *        url: /\.pinecone\.io\/,
 *       },
 *     },
 *   }
 * }
 * ```
 */
export type NodeProxySpec = {
  /**
   * The node type to proxy. If specified, this node will be proxied.
   * For ProxyClient, this means that the node will be part of a special kit
   * that will proxy the inputs and outputs of the node to the ProxyServer.
   * For ProxyServer, this means that the server will proxy this node.
   */
  node: NodeTypeIdentifier;
  /**
   * If specified, describes the tunnels the outputs of the
   * node. This is useful for protecting secrets that are generated by the
   * node.
   *
   * This value is only used by the ProxyServer and is ignored by the
   * ProxyClient.
   *
   * The spec is an object where the keys are the output names and the values
   * are either:
   * - A string -- the node type id that has access to the tunneled output.
   * - An array of strings -- same as above, but a list of them.
   * - A VaultMatchOutputs object -- a more detailed specification for
   *  tunneling the output, which includes differentiating by the content of
   * a particular input of the node to which the tunnel leads.
   * For example, if a node has an input called `url` and you want to
   * tunnel only if the url matches a particular regex, you can
   * specify:
   * ```js
   * {
   *  receiver: "fetch",
   *  inputs: {
   *    url: /\.pinecone\.io\/,
   *  },
   * }
   * ```
   * - An array of VaultMatchOutputs objects -- same as above, but a
   * list of them.
   */
  tunnel?: TunnelSpec;
};

export type TunnelConstraints = {
  [inputName: string]: string | TunnelConstraint;
};

export type TunnelConstraint = {
  test(value: string): boolean;
};

export type TunnelDestinations = {
  to: NodeTypeIdentifier;
  when: TunnelConstraints;
};

export type TunnelSpec = {
  [outputName: string]:
    | TunnelDestinations
    | TunnelDestinations[]
    | string[]
    | string;
};

export type NodeProxyConfig = (NodeTypeIdentifier | NodeProxySpec)[];

export type ProxyServerConfig = {
  /**
   * The kits to use to provide the handlers for the nodes that are proxied.
   */
  kits: Kit[];
  /**
   * The proxy configuration. This is an array of node types or node specs.
   * @see NodeProxySpec for more details.
   */
  proxy?: NodeProxyConfig;
  /**
   * The data store to use for storing data.
   */
  store?: DataStore;
  /**
   * Allow filter.
   */
  allowed?: AllowFilterFunction;
};

export const defineConfig = (config: ProxyServerConfig) => config;

export const hasOrigin = (origin: string) => ({
  test: (url: string) => new URL(url).origin === origin,
});
