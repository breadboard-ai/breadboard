/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import type {
  Edge,
  QueuedNodeValuesState,
  NodeIdentifier,
  InputValues,
  OutputValues,
  NodeValue,
  NodeValuesQueuesMap,
} from "@breadboard-ai/types";

export class MachineEdgeState implements QueuedNodeValuesState {
  state: NodeValuesQueuesMap = new Map();
  constants: NodeValuesQueuesMap = new Map();

  #queueOutput(
    map: NodeValuesQueuesMap,
    node: NodeIdentifier,
    key: string,
    value: NodeValue
  ) {
    let queuesMap = map.get(node);
    if (!queuesMap) {
      queuesMap = new Map();
      map.set(node, queuesMap);
    }
    let queue = queuesMap.get(key);
    if (!queue) {
      queue = [];
      queuesMap.set(key, queue);
    }
    queue.push(value);
  }

  /**
   * Processes outputs by wiring them to the destinations according
   * to the supplied edges. Assumes that the outputs were generated by
   * the from node.
   *
   * @param opportunites {Edge[]} Edges to process
   * @param outputs {OutputValues} Outputs to wire
   */
  wireOutputs(opportunites: Edge[], outputs: OutputValues): void {
    // Verify that all edges are from the same node.
    if (
      opportunites.filter(
        (opportunity) => opportunity.from != opportunites[0].from
      ).length !== 0
    )
      throw new Error("All opportunities must be from the same node");

    opportunites.forEach((opportunity) => {
      const to = opportunity.to;
      const out = opportunity.out;
      const queuesMap = opportunity.constant ? this.constants : this.state;
      if (!out) return;
      if (out === "*") {
        for (const key in outputs) {
          const output = outputs[key];
          if (output != null && output != undefined)
            this.#queueOutput(queuesMap, to, key, output);
        }
      } else if (opportunity.in) {
        const output = outputs[out];
        // TODO: Check and document why we don't allow that
        if (output != null && output != undefined)
          this.#queueOutput(queuesMap, to, opportunity.in, output);
      }
    });
  }

  /**
   * Returns the available inputs for a given node.
   *
   * @param nodeId {NodeIdentifier} The node to get the inputs for.
   * @returns {InputValues} The available inputs.
   */
  getAvailableInputs(nodeId: NodeIdentifier): InputValues {
    const result: InputValues = {};

    for (const queuesMap of [
      this.constants.get(nodeId), // Constants are overwritten by state.
      this.state.get(nodeId),
    ]) {
      if (!queuesMap) continue;
      for (const [key, queue] of queuesMap.entries()) {
        if (queue.length === 0) continue;
        result[key] = queue[0];
      }
    }
    return result;
  }

  /**
   * Shifts inputs from the queues. Leaves constants as is.
   *
   * @param nodeId {NodeIdentifier} The node to shift the inputs for.
   * @param inputs {InputValues} The inputs that are used.
   */
  useInputs(nodeId: NodeIdentifier, inputs: InputValues): void {
    const queuesMap = this.state.get(nodeId);
    if (!queuesMap) return;
    for (const key in inputs) {
      const queue = queuesMap.get(key);
      if (!queue) continue;
      queue.shift();
    }
  }
}
