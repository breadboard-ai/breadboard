{
  "title": "Test Template",
  "description": "A blank board. Use it as a starting point for your creations.",
  "version": "0.0.1",
  "main": "main",
  "assets": {
    "my-text": {
      "data": [
        {
          "parts": [
            {
              "text": "Hello world"
            }
          ],
          "role": "user"
        }
      ]
    }
  },
  "modules": {
    "main": {
      "code": "/**\n * @fileoverview Add a description for your module here.\n */\nimport invokeGraph from \"@invoke\";\nimport read from \"@read\";\nimport { expect } from \"./chai\";\nimport { suite, test, runTests } from \"./test\";\nimport { ok } from \"./utils\";\nfunction inlineData(data) {\n    return {\n        inlineData: { data, mimeType: \"text/plain\" },\n    };\n}\nfunction toLLMContent(...text) {\n    const role = \"user\";\n    if (text.length === 0) {\n        return { parts: [{ text: \"\" }], role };\n    }\n    return {\n        parts: text.map((t) => {\n            if (typeof t === \"string\") {\n                return { text: t };\n            }\n            return t;\n        }),\n        role,\n    };\n}\nasync function substitute(content, params) {\n    const invoking = (await invokeGraph({\n        $board: \"file://bgl/a2.bgl.json#module:template\",\n        inputs: { content, params },\n    }));\n    if (!ok(invoking)) {\n        return invoking;\n    }\n    console.log(\"Test Results\", invoking.outputs);\n    return invoking.outputs;\n}\nexport default async function invoke() {\n    suite(\"Template\", () => {\n        test(\"does simple substitution\", async () => {\n            const sub = await substitute(toLLMContent(`You're a {{ in | id: \"character\"}}, {{ in | id: \"name\"}}!`), { character: \"wizard\", name: \"Harry\" });\n            expect(sub).deep.eq(toLLMContent(\"You're a wizard, Harry!\"));\n        });\n        test(\"does simple substitution with whitespaces in params\", async () => {\n            const sub = await substitute(toLLMContent(`You're a {{ in| id:\"character\"}}, {{ in | id: \"name\"   }}!`), { character: \"wizard\", name: \"Harry\" });\n            expect(sub).deep.eq(toLLMContent(\"You're a wizard, Harry!\"));\n        });\n        test(\"does LLM Content object substitution\", async () => {\n            const sub = await substitute(toLLMContent(`You're a {{ in | id: \"character\"}}, {{ in | id: \"name\" }}!`), { character: \"wizard\", name: toLLMContent(\"Harry\") });\n            expect(sub).deep.eq(toLLMContent(\"You're a wizard, Harry!\"));\n            const sub1 = await substitute(toLLMContent(`You're a {{ in | id: \"character\"}}, {{ in | id: \"name\" }}!`), { character: \"wizard\", name: toLLMContent(\"Harry\", \" Potter\") });\n            expect(sub1).deep.eq(toLLMContent(\"You're a wizard, Harry Potter!\"));\n            const sub2 = await substitute(toLLMContent(`You're a {{ in | id: \"character\"}}, {{ in | id: \"name\" }}!`), {\n                character: \"wizard\",\n                name: [toLLMContent(\"Harry\"), toLLMContent(\"Potter\")],\n            });\n            expect(sub2).deep.eq(toLLMContent(\"You're a wizard, Potter!\"));\n        });\n        test(\"does arbitrary object substitution\", async () => {\n            const sub = await substitute(toLLMContent(`You're a {{ in | id: \"character\"}}, {{ in | id: \"name\" }}!`), { character: true, name: 42 });\n            expect(sub).deep.eq(toLLMContent(\"You're a true, 42!\"));\n            const sub1 = await substitute(toLLMContent(`You're a {{ in | id: \"character\"}}, {{ in | id: \"name\" }}!`), { character: { wizard: true }, name: null });\n            expect(sub1).deep.eq(toLLMContent('You\\'re a {\"wizard\":true}, !'));\n        });\n        test(\"does other non-text substitution\", async () => {\n            const sub = await substitute(toLLMContent(`You're a {{ in | id: \"character\"}}, {{ in | id: \"name\" }}!`), { character: \"wizard\", name: toLLMContent(inlineData(\"Harry\")) });\n            expect(sub).deep.eq(toLLMContent(\"You're a wizard, \", inlineData(\"Harry\"), \"!\"));\n        });\n        test(\"does asset substitution\", async () => {\n            const sub = await substitute(toLLMContent(`{{ in | id: \"name\"}} says: {{ asset | path: \"my-text\" }}!`), { name: \"Breadboard\" });\n            expect(sub).deep.eq(toLLMContent(\"Breadboard says: Hello world!\"));\n        });\n        test(\"does tool substitution\", async () => {\n            const sub = await substitute(toLLMContent(`{{ in | id: \"name\"}} says: \"{{ tool | url: \"https://example.com/tool\" }}\"!`), { name: \"Breadboard\" });\n            expect(sub).deep.eq(toLLMContent('Breadboard says: \"https://example.com/tool\"!'));\n        });\n    });\n    await runTests();\n    return {};\n}\n",
      "metadata": {
        "description": "Add a description for your module here.",
        "url": "main.js",
        "source": {
          "code": "/**\n * @fileoverview Add a description for your module here.\n */\nimport invokeGraph from \"@invoke\";\nimport read from \"@read\";\n\nimport { expect } from \"./chai\";\nimport { suite, test, runTests } from \"./test\";\nimport { ok } from \"./utils\";\n\ntype TestOutputs = {\n  outputs: LLMContent;\n};\n\nfunction inlineData(data: string): InlineDataCapabilityPart {\n  return {\n    inlineData: { data, mimeType: \"text/plain\" },\n  };\n}\n\nfunction toLLMContent(\n  ...text: (string | InlineDataCapabilityPart)[]\n): LLMContent {\n  const role = \"user\";\n  if (text.length === 0) {\n    return { parts: [{ text: \"\" }], role };\n  }\n  return {\n    parts: text.map((t) => {\n      if (typeof t === \"string\") {\n        return { text: t };\n      }\n      return t;\n    }),\n    role,\n  };\n}\n\nasync function substitute(\n  content: LLMContent,\n  params: Record<string, unknown>\n): Promise<Outcome<LLMContent>> {\n  const invoking = (await invokeGraph({\n    $board: \"file://bgl/a2.bgl.json#module:template\",\n    inputs: { content, params },\n  })) as TestOutputs;\n  if (!ok(invoking)) {\n    return invoking;\n  }\n  console.log(\"Test Results\", invoking.outputs);\n  return invoking.outputs;\n}\n\nexport default async function invoke() {\n  suite(\"Template\", () => {\n    test(\"does simple substitution\", async () => {\n      const sub = await substitute(\n        toLLMContent(\n          `You're a {{ in | id: \"character\"}}, {{ in | id: \"name\"}}!`\n        ),\n        { character: \"wizard\", name: \"Harry\" }\n      );\n      expect(sub).deep.eq(toLLMContent(\"You're a wizard, Harry!\"));\n    });\n\n    test(\"does simple substitution with whitespaces in params\", async () => {\n      const sub = await substitute(\n        toLLMContent(\n          `You're a {{ in| id:\"character\"}}, {{ in | id: \"name\"   }}!`\n        ),\n        { character: \"wizard\", name: \"Harry\" }\n      );\n      expect(sub).deep.eq(toLLMContent(\"You're a wizard, Harry!\"));\n    });\n\n    test(\"does LLM Content object substitution\", async () => {\n      const sub = await substitute(\n        toLLMContent(\n          `You're a {{ in | id: \"character\"}}, {{ in | id: \"name\" }}!`\n        ),\n        { character: \"wizard\", name: toLLMContent(\"Harry\") }\n      );\n      expect(sub).deep.eq(toLLMContent(\"You're a wizard, Harry!\"));\n\n      const sub1 = await substitute(\n        toLLMContent(\n          `You're a {{ in | id: \"character\"}}, {{ in | id: \"name\" }}!`\n        ),\n        { character: \"wizard\", name: toLLMContent(\"Harry\", \" Potter\") }\n      );\n      expect(sub1).deep.eq(toLLMContent(\"You're a wizard, Harry Potter!\"));\n\n      const sub2 = await substitute(\n        toLLMContent(\n          `You're a {{ in | id: \"character\"}}, {{ in | id: \"name\" }}!`\n        ),\n        {\n          character: \"wizard\",\n          name: [toLLMContent(\"Harry\"), toLLMContent(\"Potter\")],\n        }\n      );\n      expect(sub2).deep.eq(toLLMContent(\"You're a wizard, Potter!\"));\n    });\n\n    test(\"does arbitrary object substitution\", async () => {\n      const sub = await substitute(\n        toLLMContent(\n          `You're a {{ in | id: \"character\"}}, {{ in | id: \"name\" }}!`\n        ),\n        { character: true, name: 42 }\n      );\n      expect(sub).deep.eq(toLLMContent(\"You're a true, 42!\"));\n\n      const sub1 = await substitute(\n        toLLMContent(\n          `You're a {{ in | id: \"character\"}}, {{ in | id: \"name\" }}!`\n        ),\n        { character: { wizard: true }, name: null }\n      );\n      expect(sub1).deep.eq(toLLMContent('You\\'re a {\"wizard\":true}, !'));\n    });\n\n    test(\"does other non-text substitution\", async () => {\n      const sub = await substitute(\n        toLLMContent(\n          `You're a {{ in | id: \"character\"}}, {{ in | id: \"name\" }}!`\n        ),\n        { character: \"wizard\", name: toLLMContent(inlineData(\"Harry\")) }\n      );\n      expect(sub).deep.eq(\n        toLLMContent(\"You're a wizard, \", inlineData(\"Harry\"), \"!\")\n      );\n    });\n\n    test(\"does asset substitution\", async () => {\n      const sub = await substitute(\n        toLLMContent(\n          `{{ in | id: \"name\"}} says: {{ asset | path: \"my-text\" }}!`\n        ),\n        { name: \"Breadboard\" }\n      );\n      expect(sub).deep.eq(toLLMContent(\"Breadboard says: Hello world!\"));\n    });\n\n    test(\"does tool substitution\", async () => {\n      const sub = await substitute(\n        toLLMContent(\n          `{{ in | id: \"name\"}} says: \"{{ tool | url: \"https://example.com/tool\" }}\"!`\n        ),\n        { name: \"Breadboard\" }\n      );\n      expect(sub).deep.eq(\n        toLLMContent('Breadboard says: \"https://example.com/tool\"!')\n      );\n    });\n  });\n\n  await runTests();\n\n  return {};\n}\n",
          "language": "typescript"
        },
        "runnable": true
      }
    },
    "utils": {
      "code": "export { ok, err };\nfunction ok(o) {\n    return !(o && typeof o === \"object\" && \"$error\" in o);\n}\nfunction err($error) {\n    return { $error };\n}\n",
      "metadata": {
        "title": "utils",
        "source": {
          "code": "export { ok, err };\n\nfunction ok<T>(o: Outcome<T>): o is T {\n  return !(o && typeof o === \"object\" && \"$error\" in o);\n}\n\nfunction err($error: string) {\n  return { $error };\n}\n",
          "language": "typescript"
        },
        "description": "",
        "runnable": false
      }
    },
    "chai-bundle": {
      "code": "/* esm.sh - esbuild bundle(@esm-bundle/chai@4.3.4-fix.0) es2022 production */\nvar __global$ = globalThis || (typeof window !== \"undefined\" ? window : self);\nvar se =\n  typeof globalThis < \"u\"\n    ? globalThis\n    : typeof window < \"u\"\n      ? window\n      : typeof __global$ < \"u\"\n        ? __global$\n        : typeof self < \"u\"\n          ? self\n          : {};\nfunction re(l) {\n  throw new Error(\n    'Could not dynamically require \"' +\n      l +\n      '\". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.'\n  );\n}\nvar ie = { exports: {} },\n  Q = (ie.exports = (function () {\n    function l(v, w, d) {\n      function a(e, o) {\n        if (!w[e]) {\n          if (!v[e]) {\n            if (!o && re) return re(e);\n            if (r) return r(e, !0);\n            var t = new Error(\"Cannot find module '\" + e + \"'\");\n            throw ((t.code = \"MODULE_NOT_FOUND\"), t);\n          }\n          var n = (w[e] = { exports: {} });\n          v[e][0].call(\n            n.exports,\n            function (s) {\n              return a(v[e][1][s] || s);\n            },\n            n,\n            n.exports,\n            l,\n            v,\n            w,\n            d\n          );\n        }\n        return w[e].exports;\n      }\n      for (var r = re, h = 0; h < d.length; h++) a(d[h]);\n      return a;\n    }\n    return l;\n  })()(\n    {\n      1: [\n        function (l, v, w) {\n          v.exports = l(\"./lib/chai\");\n        },\n        { \"./lib/chai\": 2 },\n      ],\n      2: [\n        function (l, v, w) {\n          var d = [];\n          (w.version = \"4.3.3\"), (w.AssertionError = l(\"assertion-error\"));\n          var a = l(\"./chai/utils\");\n          (w.use = function (s) {\n            return ~d.indexOf(s) || (s(w, a), d.push(s)), w;\n          }),\n            (w.util = a);\n          var r = l(\"./chai/config\");\n          w.config = r;\n          var h = l(\"./chai/assertion\");\n          w.use(h);\n          var e = l(\"./chai/core/assertions\");\n          w.use(e);\n          var o = l(\"./chai/interface/expect\");\n          w.use(o);\n          var t = l(\"./chai/interface/should\");\n          w.use(t);\n          var n = l(\"./chai/interface/assert\");\n          w.use(n);\n        },\n        {\n          \"./chai/assertion\": 3,\n          \"./chai/config\": 4,\n          \"./chai/core/assertions\": 5,\n          \"./chai/interface/assert\": 6,\n          \"./chai/interface/expect\": 7,\n          \"./chai/interface/should\": 8,\n          \"./chai/utils\": 23,\n          \"assertion-error\": 34,\n        },\n      ],\n      3: [\n        function (l, v, w) {\n          var d = l(\"./config\");\n          v.exports = function (a, r) {\n            var h = a.AssertionError,\n              e = r.flag;\n            function o(t, n, s, f) {\n              return (\n                e(this, \"ssfi\", s || o),\n                e(this, \"lockSsfi\", f),\n                e(this, \"object\", t),\n                e(this, \"message\", n),\n                r.proxify(this)\n              );\n            }\n            (a.Assertion = o),\n              Object.defineProperty(o, \"includeStack\", {\n                get: function () {\n                  return (\n                    console.warn(\n                      \"Assertion.includeStack is deprecated, use chai.config.includeStack instead.\"\n                    ),\n                    d.includeStack\n                  );\n                },\n                set: function (t) {\n                  console.warn(\n                    \"Assertion.includeStack is deprecated, use chai.config.includeStack instead.\"\n                  ),\n                    (d.includeStack = t);\n                },\n              }),\n              Object.defineProperty(o, \"showDiff\", {\n                get: function () {\n                  return (\n                    console.warn(\n                      \"Assertion.showDiff is deprecated, use chai.config.showDiff instead.\"\n                    ),\n                    d.showDiff\n                  );\n                },\n                set: function (t) {\n                  console.warn(\n                    \"Assertion.showDiff is deprecated, use chai.config.showDiff instead.\"\n                  ),\n                    (d.showDiff = t);\n                },\n              }),\n              (o.addProperty = function (t, n) {\n                r.addProperty(this.prototype, t, n);\n              }),\n              (o.addMethod = function (t, n) {\n                r.addMethod(this.prototype, t, n);\n              }),\n              (o.addChainableMethod = function (t, n, s) {\n                r.addChainableMethod(this.prototype, t, n, s);\n              }),\n              (o.overwriteProperty = function (t, n) {\n                r.overwriteProperty(this.prototype, t, n);\n              }),\n              (o.overwriteMethod = function (t, n) {\n                r.overwriteMethod(this.prototype, t, n);\n              }),\n              (o.overwriteChainableMethod = function (t, n, s) {\n                r.overwriteChainableMethod(this.prototype, t, n, s);\n              }),\n              (o.prototype.assert = function (t, n, s, f, b, E) {\n                var T = r.test(this, arguments);\n                if (\n                  (E !== !1 && (E = !0),\n                  f === void 0 && b === void 0 && (E = !1),\n                  d.showDiff !== !0 && (E = !1),\n                  !T)\n                ) {\n                  n = r.getMessage(this, arguments);\n                  var C = {\n                      actual: r.getActual(this, arguments),\n                      expected: f,\n                      showDiff: E,\n                    },\n                    B = r.getOperator(this, arguments);\n                  throw (\n                    (B && (C.operator = B),\n                    new h(n, C, d.includeStack ? this.assert : e(this, \"ssfi\")))\n                  );\n                }\n              }),\n              Object.defineProperty(o.prototype, \"_obj\", {\n                get: function () {\n                  return e(this, \"object\");\n                },\n                set: function (t) {\n                  e(this, \"object\", t);\n                },\n              });\n          };\n        },\n        { \"./config\": 4 },\n      ],\n      4: [\n        function (l, v, w) {\n          v.exports = {\n            includeStack: !1,\n            showDiff: !0,\n            truncateThreshold: 40,\n            useProxy: !0,\n            proxyExcludedKeys: [\"then\", \"catch\", \"inspect\", \"toJSON\"],\n          };\n        },\n        {},\n      ],\n      5: [\n        function (l, v, w) {\n          v.exports = function (d, a) {\n            var r = d.Assertion,\n              h = d.AssertionError,\n              e = a.flag;\n            function o(i, u) {\n              u && e(this, \"message\", u), (i = i.toLowerCase());\n              var y = e(this, \"object\"),\n                p = ~[\"a\", \"e\", \"i\", \"o\", \"u\"].indexOf(i.charAt(0))\n                  ? \"an \"\n                  : \"a \";\n              this.assert(\n                i === a.type(y).toLowerCase(),\n                \"expected #{this} to be \" + p + i,\n                \"expected #{this} not to be \" + p + i\n              );\n            }\n            function t(i, u) {\n              return (a.isNaN(i) && a.isNaN(u)) || i === u;\n            }\n            function n() {\n              e(this, \"contains\", !0);\n            }\n            function s(i, u) {\n              u && e(this, \"message\", u);\n              var y = e(this, \"object\"),\n                p = a.type(y).toLowerCase(),\n                m = e(this, \"message\"),\n                M = e(this, \"negate\"),\n                P = e(this, \"ssfi\"),\n                O = e(this, \"deep\"),\n                j = O ? \"deep \" : \"\";\n              m = m ? m + \": \" : \"\";\n              var A = !1;\n              switch (p) {\n                case \"string\":\n                  A = y.indexOf(i) !== -1;\n                  break;\n                case \"weakset\":\n                  if (O)\n                    throw new h(\n                      m + \"unable to use .deep.include with WeakSet\",\n                      void 0,\n                      P\n                    );\n                  A = y.has(i);\n                  break;\n                case \"map\":\n                  var L = O ? a.eql : t;\n                  y.forEach(function (F) {\n                    A = A || L(F, i);\n                  });\n                  break;\n                case \"set\":\n                  O\n                    ? y.forEach(function (F) {\n                        A = A || a.eql(F, i);\n                      })\n                    : (A = y.has(i));\n                  break;\n                case \"array\":\n                  A = O\n                    ? y.some(function (F) {\n                        return a.eql(F, i);\n                      })\n                    : y.indexOf(i) !== -1;\n                  break;\n                default:\n                  if (i !== Object(i))\n                    throw new h(\n                      m +\n                        \"the given combination of arguments (\" +\n                        p +\n                        \" and \" +\n                        a.type(i).toLowerCase() +\n                        \") is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a \" +\n                        a.type(i).toLowerCase(),\n                      void 0,\n                      P\n                    );\n                  var q = Object.keys(i),\n                    z = null,\n                    V = 0;\n                  if (\n                    (q.forEach(function (F) {\n                      var W = new r(y);\n                      if (\n                        (a.transferFlags(this, W, !0),\n                        e(W, \"lockSsfi\", !0),\n                        M && q.length !== 1)\n                      )\n                        try {\n                          W.property(F, i[F]);\n                        } catch (ne) {\n                          if (!a.checkError.compatibleConstructor(ne, h))\n                            throw ne;\n                          z === null && (z = ne), V++;\n                        }\n                      else W.property(F, i[F]);\n                    }, this),\n                    M && q.length > 1 && V === q.length)\n                  )\n                    throw z;\n                  return;\n              }\n              this.assert(\n                A,\n                \"expected #{this} to \" + j + \"include \" + a.inspect(i),\n                \"expected #{this} to not \" + j + \"include \" + a.inspect(i)\n              );\n            }\n            function f() {\n              var i = e(this, \"object\");\n              this.assert(\n                i != null,\n                \"expected #{this} to exist\",\n                \"expected #{this} to not exist\"\n              );\n            }\n            function b() {\n              var i = e(this, \"object\"),\n                u = a.type(i);\n              this.assert(\n                u === \"Arguments\",\n                \"expected #{this} to be arguments but got \" + u,\n                \"expected #{this} to not be arguments\"\n              );\n            }\n            function E(i, u) {\n              u && e(this, \"message\", u);\n              var y = e(this, \"object\");\n              if (e(this, \"deep\")) {\n                var p = e(this, \"lockSsfi\");\n                e(this, \"lockSsfi\", !0), this.eql(i), e(this, \"lockSsfi\", p);\n              } else\n                this.assert(\n                  i === y,\n                  \"expected #{this} to equal #{exp}\",\n                  \"expected #{this} to not equal #{exp}\",\n                  i,\n                  this._obj,\n                  !0\n                );\n            }\n            function T(i, u) {\n              u && e(this, \"message\", u),\n                this.assert(\n                  a.eql(i, e(this, \"object\")),\n                  \"expected #{this} to deeply equal #{exp}\",\n                  \"expected #{this} to not deeply equal #{exp}\",\n                  i,\n                  this._obj,\n                  !0\n                );\n            }\n            function C(i, u) {\n              u && e(this, \"message\", u);\n              var y,\n                p = e(this, \"object\"),\n                m = e(this, \"doLength\"),\n                M = e(this, \"message\"),\n                P = M ? M + \": \" : \"\",\n                O = e(this, \"ssfi\"),\n                j = a.type(p).toLowerCase(),\n                A = a.type(i).toLowerCase(),\n                L = !0;\n              if (\n                (m &&\n                  j !== \"map\" &&\n                  j !== \"set\" &&\n                  new r(p, M, O, !0).to.have.property(\"length\"),\n                m || j !== \"date\" || A === \"date\"\n                  ? A === \"number\" || (!m && j !== \"number\")\n                    ? m || j === \"date\" || j === \"number\"\n                      ? (L = !1)\n                      : (y =\n                          P +\n                          \"expected \" +\n                          (j === \"string\" ? \"'\" + p + \"'\" : p) +\n                          \" to be a number or a date\")\n                    : (y = P + \"the argument to above must be a number\")\n                  : (y = P + \"the argument to above must be a date\"),\n                L)\n              )\n                throw new h(y, void 0, O);\n              if (m) {\n                var q,\n                  z = \"length\";\n                j === \"map\" || j === \"set\"\n                  ? ((z = \"size\"), (q = p.size))\n                  : (q = p.length),\n                  this.assert(\n                    q > i,\n                    \"expected #{this} to have a \" +\n                      z +\n                      \" above #{exp} but got #{act}\",\n                    \"expected #{this} to not have a \" + z + \" above #{exp}\",\n                    i,\n                    q\n                  );\n              } else\n                this.assert(\n                  p > i,\n                  \"expected #{this} to be above #{exp}\",\n                  \"expected #{this} to be at most #{exp}\",\n                  i\n                );\n            }\n            function B(i, u) {\n              u && e(this, \"message\", u);\n              var y,\n                p = e(this, \"object\"),\n                m = e(this, \"doLength\"),\n                M = e(this, \"message\"),\n                P = M ? M + \": \" : \"\",\n                O = e(this, \"ssfi\"),\n                j = a.type(p).toLowerCase(),\n                A = a.type(i).toLowerCase(),\n                L = !0;\n              if (\n                (m &&\n                  j !== \"map\" &&\n                  j !== \"set\" &&\n                  new r(p, M, O, !0).to.have.property(\"length\"),\n                m || j !== \"date\" || A === \"date\"\n                  ? A === \"number\" || (!m && j !== \"number\")\n                    ? m || j === \"date\" || j === \"number\"\n                      ? (L = !1)\n                      : (y =\n                          P +\n                          \"expected \" +\n                          (j === \"string\" ? \"'\" + p + \"'\" : p) +\n                          \" to be a number or a date\")\n                    : (y = P + \"the argument to least must be a number\")\n                  : (y = P + \"the argument to least must be a date\"),\n                L)\n              )\n                throw new h(y, void 0, O);\n              if (m) {\n                var q,\n                  z = \"length\";\n                j === \"map\" || j === \"set\"\n                  ? ((z = \"size\"), (q = p.size))\n                  : (q = p.length),\n                  this.assert(\n                    q >= i,\n                    \"expected #{this} to have a \" +\n                      z +\n                      \" at least #{exp} but got #{act}\",\n                    \"expected #{this} to have a \" + z + \" below #{exp}\",\n                    i,\n                    q\n                  );\n              } else\n                this.assert(\n                  p >= i,\n                  \"expected #{this} to be at least #{exp}\",\n                  \"expected #{this} to be below #{exp}\",\n                  i\n                );\n            }\n            function _(i, u) {\n              u && e(this, \"message\", u);\n              var y,\n                p = e(this, \"object\"),\n                m = e(this, \"doLength\"),\n                M = e(this, \"message\"),\n                P = M ? M + \": \" : \"\",\n                O = e(this, \"ssfi\"),\n                j = a.type(p).toLowerCase(),\n                A = a.type(i).toLowerCase(),\n                L = !0;\n              if (\n                (m &&\n                  j !== \"map\" &&\n                  j !== \"set\" &&\n                  new r(p, M, O, !0).to.have.property(\"length\"),\n                m || j !== \"date\" || A === \"date\"\n                  ? A === \"number\" || (!m && j !== \"number\")\n                    ? m || j === \"date\" || j === \"number\"\n                      ? (L = !1)\n                      : (y =\n                          P +\n                          \"expected \" +\n                          (j === \"string\" ? \"'\" + p + \"'\" : p) +\n                          \" to be a number or a date\")\n                    : (y = P + \"the argument to below must be a number\")\n                  : (y = P + \"the argument to below must be a date\"),\n                L)\n              )\n                throw new h(y, void 0, O);\n              if (m) {\n                var q,\n                  z = \"length\";\n                j === \"map\" || j === \"set\"\n                  ? ((z = \"size\"), (q = p.size))\n                  : (q = p.length),\n                  this.assert(\n                    q < i,\n                    \"expected #{this} to have a \" +\n                      z +\n                      \" below #{exp} but got #{act}\",\n                    \"expected #{this} to not have a \" + z + \" below #{exp}\",\n                    i,\n                    q\n                  );\n              } else\n                this.assert(\n                  p < i,\n                  \"expected #{this} to be below #{exp}\",\n                  \"expected #{this} to be at least #{exp}\",\n                  i\n                );\n            }\n            function H(i, u) {\n              u && e(this, \"message\", u);\n              var y,\n                p = e(this, \"object\"),\n                m = e(this, \"doLength\"),\n                M = e(this, \"message\"),\n                P = M ? M + \": \" : \"\",\n                O = e(this, \"ssfi\"),\n                j = a.type(p).toLowerCase(),\n                A = a.type(i).toLowerCase(),\n                L = !0;\n              if (\n                (m &&\n                  j !== \"map\" &&\n                  j !== \"set\" &&\n                  new r(p, M, O, !0).to.have.property(\"length\"),\n                m || j !== \"date\" || A === \"date\"\n                  ? A === \"number\" || (!m && j !== \"number\")\n                    ? m || j === \"date\" || j === \"number\"\n                      ? (L = !1)\n                      : (y =\n                          P +\n                          \"expected \" +\n                          (j === \"string\" ? \"'\" + p + \"'\" : p) +\n                          \" to be a number or a date\")\n                    : (y = P + \"the argument to most must be a number\")\n                  : (y = P + \"the argument to most must be a date\"),\n                L)\n              )\n                throw new h(y, void 0, O);\n              if (m) {\n                var q,\n                  z = \"length\";\n                j === \"map\" || j === \"set\"\n                  ? ((z = \"size\"), (q = p.size))\n                  : (q = p.length),\n                  this.assert(\n                    q <= i,\n                    \"expected #{this} to have a \" +\n                      z +\n                      \" at most #{exp} but got #{act}\",\n                    \"expected #{this} to have a \" + z + \" above #{exp}\",\n                    i,\n                    q\n                  );\n              } else\n                this.assert(\n                  p <= i,\n                  \"expected #{this} to be at most #{exp}\",\n                  \"expected #{this} to be above #{exp}\",\n                  i\n                );\n            }\n            function U(i, u) {\n              u && e(this, \"message\", u);\n              var y = e(this, \"object\"),\n                p = e(this, \"ssfi\"),\n                m = e(this, \"message\");\n              try {\n                var M = y instanceof i;\n              } catch (O) {\n                throw O instanceof TypeError\n                  ? new h(\n                      (m = m ? m + \": \" : \"\") +\n                        \"The instanceof assertion needs a constructor but \" +\n                        a.type(i) +\n                        \" was given.\",\n                      void 0,\n                      p\n                    )\n                  : O;\n              }\n              var P = a.getName(i);\n              P === null && (P = \"an unnamed constructor\"),\n                this.assert(\n                  M,\n                  \"expected #{this} to be an instance of \" + P,\n                  \"expected #{this} to not be an instance of \" + P\n                );\n            }\n            function R(i, u, y) {\n              y && e(this, \"message\", y);\n              var p = e(this, \"nested\"),\n                m = e(this, \"own\"),\n                M = e(this, \"message\"),\n                P = e(this, \"object\"),\n                O = e(this, \"ssfi\"),\n                j = typeof i;\n              if (((M = M ? M + \": \" : \"\"), p)) {\n                if (j !== \"string\")\n                  throw new h(\n                    M +\n                      \"the argument to property must be a string when using nested syntax\",\n                    void 0,\n                    O\n                  );\n              } else if (j !== \"string\" && j !== \"number\" && j !== \"symbol\")\n                throw new h(\n                  M +\n                    \"the argument to property must be a string, number, or symbol\",\n                  void 0,\n                  O\n                );\n              if (p && m)\n                throw new h(\n                  M + 'The \"nested\" and \"own\" flags cannot be combined.',\n                  void 0,\n                  O\n                );\n              if (P == null)\n                throw new h(\n                  M + \"Target cannot be null or undefined.\",\n                  void 0,\n                  O\n                );\n              var A,\n                L = e(this, \"deep\"),\n                q = e(this, \"negate\"),\n                z = p ? a.getPathInfo(P, i) : null,\n                V = p ? z.value : P[i],\n                F = \"\";\n              L && (F += \"deep \"),\n                m && (F += \"own \"),\n                p && (F += \"nested \"),\n                (F += \"property \"),\n                (A = m\n                  ? Object.prototype.hasOwnProperty.call(P, i)\n                  : p\n                    ? z.exists\n                    : a.hasProperty(P, i)),\n                (q && arguments.length !== 1) ||\n                  this.assert(\n                    A,\n                    \"expected #{this} to have \" + F + a.inspect(i),\n                    \"expected #{this} to not have \" + F + a.inspect(i)\n                  ),\n                arguments.length > 1 &&\n                  this.assert(\n                    A && (L ? a.eql(u, V) : u === V),\n                    \"expected #{this} to have \" +\n                      F +\n                      a.inspect(i) +\n                      \" of #{exp}, but got #{act}\",\n                    \"expected #{this} to not have \" +\n                      F +\n                      a.inspect(i) +\n                      \" of #{act}\",\n                    u,\n                    V\n                  ),\n                e(this, \"object\", V);\n            }\n            function x(i, u, y) {\n              e(this, \"own\", !0), R.apply(this, arguments);\n            }\n            function c(i, u, y) {\n              typeof u == \"string\" && ((y = u), (u = null)),\n                y && e(this, \"message\", y);\n              var p = e(this, \"object\"),\n                m = Object.getOwnPropertyDescriptor(Object(p), i);\n              m && u\n                ? this.assert(\n                    a.eql(u, m),\n                    \"expected the own property descriptor for \" +\n                      a.inspect(i) +\n                      \" on #{this} to match \" +\n                      a.inspect(u) +\n                      \", got \" +\n                      a.inspect(m),\n                    \"expected the own property descriptor for \" +\n                      a.inspect(i) +\n                      \" on #{this} to not match \" +\n                      a.inspect(u),\n                    u,\n                    m,\n                    !0\n                  )\n                : this.assert(\n                    m,\n                    \"expected #{this} to have an own property descriptor for \" +\n                      a.inspect(i),\n                    \"expected #{this} to not have an own property descriptor for \" +\n                      a.inspect(i)\n                  ),\n                e(this, \"object\", m);\n            }\n            function g() {\n              e(this, \"doLength\", !0);\n            }\n            function N(i, u) {\n              u && e(this, \"message\", u);\n              var y,\n                p = e(this, \"object\"),\n                m = a.type(p).toLowerCase(),\n                M = e(this, \"message\"),\n                P = e(this, \"ssfi\"),\n                O = \"length\";\n              switch (m) {\n                case \"map\":\n                case \"set\":\n                  (O = \"size\"), (y = p.size);\n                  break;\n                default:\n                  new r(p, M, P, !0).to.have.property(\"length\"), (y = p.length);\n              }\n              this.assert(\n                y == i,\n                \"expected #{this} to have a \" + O + \" of #{exp} but got #{act}\",\n                \"expected #{this} to not have a \" + O + \" of #{act}\",\n                i,\n                y\n              );\n            }\n            function S(i, u) {\n              u && e(this, \"message\", u);\n              var y = e(this, \"object\");\n              this.assert(\n                i.exec(y),\n                \"expected #{this} to match \" + i,\n                \"expected #{this} not to match \" + i\n              );\n            }\n            function k(i) {\n              var u,\n                y,\n                p = e(this, \"object\"),\n                m = a.type(p),\n                M = a.type(i),\n                P = e(this, \"ssfi\"),\n                O = e(this, \"deep\"),\n                j = \"\",\n                A = !0,\n                L = e(this, \"message\"),\n                q =\n                  (L = L ? L + \": \" : \"\") +\n                  \"when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments\";\n              if (m === \"Map\" || m === \"Set\")\n                (j = O ? \"deeply \" : \"\"),\n                  (y = []),\n                  p.forEach(function ($, ee) {\n                    y.push(ee);\n                  }),\n                  M !== \"Array\" && (i = Array.prototype.slice.call(arguments));\n              else {\n                switch (((y = a.getOwnEnumerableProperties(p)), M)) {\n                  case \"Array\":\n                    if (arguments.length > 1) throw new h(q, void 0, P);\n                    break;\n                  case \"Object\":\n                    if (arguments.length > 1) throw new h(q, void 0, P);\n                    i = Object.keys(i);\n                    break;\n                  default:\n                    i = Array.prototype.slice.call(arguments);\n                }\n                i = i.map(function ($) {\n                  return typeof $ == \"symbol\" ? $ : String($);\n                });\n              }\n              if (!i.length) throw new h(L + \"keys required\", void 0, P);\n              var z = i.length,\n                V = e(this, \"any\"),\n                F = e(this, \"all\"),\n                W = i;\n              if (\n                (V || F || (F = !0),\n                V &&\n                  (A = W.some(function ($) {\n                    return y.some(function (ee) {\n                      return O ? a.eql($, ee) : $ === ee;\n                    });\n                  })),\n                F &&\n                  ((A = W.every(function ($) {\n                    return y.some(function (ee) {\n                      return O ? a.eql($, ee) : $ === ee;\n                    });\n                  })),\n                  e(this, \"contains\") || (A = A && i.length == y.length)),\n                z > 1)\n              ) {\n                var ne = (i = i.map(function ($) {\n                  return a.inspect($);\n                })).pop();\n                F && (u = i.join(\", \") + \", and \" + ne),\n                  V && (u = i.join(\", \") + \", or \" + ne);\n              } else u = a.inspect(i[0]);\n              (u = (z > 1 ? \"keys \" : \"key \") + u),\n                (u = (e(this, \"contains\") ? \"contain \" : \"have \") + u),\n                this.assert(\n                  A,\n                  \"expected #{this} to \" + j + u,\n                  \"expected #{this} to not \" + j + u,\n                  W.slice(0).sort(a.compareByInspect),\n                  y.sort(a.compareByInspect),\n                  !0\n                );\n            }\n            function D(i, u, y) {\n              y && e(this, \"message\", y);\n              var p,\n                m = e(this, \"object\"),\n                M = e(this, \"ssfi\"),\n                P = e(this, \"message\"),\n                O = e(this, \"negate\") || !1;\n              new r(m, P, M, !0).is.a(\"function\"),\n                (i instanceof RegExp || typeof i == \"string\") &&\n                  ((u = i), (i = null));\n              try {\n                m();\n              } catch (F) {\n                p = F;\n              }\n              var j = i === void 0 && u === void 0,\n                A = !!(i && u),\n                L = !1,\n                q = !1;\n              if (j || (!j && !O)) {\n                var z = \"an error\";\n                i instanceof Error\n                  ? (z = \"#{exp}\")\n                  : i && (z = a.checkError.getConstructorName(i)),\n                  this.assert(\n                    p,\n                    \"expected #{this} to throw \" + z,\n                    \"expected #{this} to not throw an error but #{act} was thrown\",\n                    i && i.toString(),\n                    p instanceof Error\n                      ? p.toString()\n                      : typeof p == \"string\"\n                        ? p\n                        : p && a.checkError.getConstructorName(p)\n                  );\n              }\n              if (\n                (i &&\n                  p &&\n                  (i instanceof Error &&\n                    a.checkError.compatibleInstance(p, i) === O &&\n                    (A && O\n                      ? (L = !0)\n                      : this.assert(\n                          O,\n                          \"expected #{this} to throw #{exp} but #{act} was thrown\",\n                          \"expected #{this} to not throw #{exp}\" +\n                            (p && !O ? \" but #{act} was thrown\" : \"\"),\n                          i.toString(),\n                          p.toString()\n                        )),\n                  a.checkError.compatibleConstructor(p, i) === O &&\n                    (A && O\n                      ? (L = !0)\n                      : this.assert(\n                          O,\n                          \"expected #{this} to throw #{exp} but #{act} was thrown\",\n                          \"expected #{this} to not throw #{exp}\" +\n                            (p ? \" but #{act} was thrown\" : \"\"),\n                          i instanceof Error\n                            ? i.toString()\n                            : i && a.checkError.getConstructorName(i),\n                          p instanceof Error\n                            ? p.toString()\n                            : p && a.checkError.getConstructorName(p)\n                        ))),\n                p && u != null)\n              ) {\n                var V = \"including\";\n                u instanceof RegExp && (V = \"matching\"),\n                  a.checkError.compatibleMessage(p, u) === O &&\n                    (A && O\n                      ? (q = !0)\n                      : this.assert(\n                          O,\n                          \"expected #{this} to throw error \" +\n                            V +\n                            \" #{exp} but got #{act}\",\n                          \"expected #{this} to throw error not \" +\n                            V +\n                            \" #{exp}\",\n                          u,\n                          a.checkError.getMessage(p)\n                        ));\n              }\n              L &&\n                q &&\n                this.assert(\n                  O,\n                  \"expected #{this} to throw #{exp} but #{act} was thrown\",\n                  \"expected #{this} to not throw #{exp}\" +\n                    (p ? \" but #{act} was thrown\" : \"\"),\n                  i instanceof Error\n                    ? i.toString()\n                    : i && a.checkError.getConstructorName(i),\n                  p instanceof Error\n                    ? p.toString()\n                    : p && a.checkError.getConstructorName(p)\n                ),\n                e(this, \"object\", p);\n            }\n            function I(i, u) {\n              u && e(this, \"message\", u);\n              var y = e(this, \"object\"),\n                p = e(this, \"itself\"),\n                m = typeof y != \"function\" || p ? y[i] : y.prototype[i];\n              this.assert(\n                typeof m == \"function\",\n                \"expected #{this} to respond to \" + a.inspect(i),\n                \"expected #{this} to not respond to \" + a.inspect(i)\n              );\n            }\n            function K(i, u) {\n              u && e(this, \"message\", u);\n              var y = i(e(this, \"object\"));\n              this.assert(\n                y,\n                \"expected #{this} to satisfy \" + a.objDisplay(i),\n                \"expected #{this} to not satisfy\" + a.objDisplay(i),\n                !e(this, \"negate\"),\n                y\n              );\n            }\n            function G(i, u, y) {\n              y && e(this, \"message\", y);\n              var p = e(this, \"object\"),\n                m = e(this, \"message\"),\n                M = e(this, \"ssfi\");\n              if (\n                (new r(p, m, M, !0).is.a(\"number\"),\n                typeof i != \"number\" || typeof u != \"number\")\n              )\n                throw new h(\n                  (m = m ? m + \": \" : \"\") +\n                    \"the arguments to closeTo or approximately must be numbers\" +\n                    (u === void 0 ? \", and a delta is required\" : \"\"),\n                  void 0,\n                  M\n                );\n              this.assert(\n                Math.abs(p - i) <= u,\n                \"expected #{this} to be close to \" + i + \" +/- \" + u,\n                \"expected #{this} not to be close to \" + i + \" +/- \" + u\n              );\n            }\n            function Z(i, u, y, p, m) {\n              if (!p) {\n                if (i.length !== u.length) return !1;\n                u = u.slice();\n              }\n              return i.every(function (M, P) {\n                if (m) return y ? y(M, u[P]) : M === u[P];\n                if (!y) {\n                  var O = u.indexOf(M);\n                  return O !== -1 && (p || u.splice(O, 1), !0);\n                }\n                return u.some(function (j, A) {\n                  return !!y(M, j) && (p || u.splice(A, 1), !0);\n                });\n              });\n            }\n            function J(i, u) {\n              u && e(this, \"message\", u);\n              var y = e(this, \"object\"),\n                p = e(this, \"message\"),\n                m = e(this, \"ssfi\"),\n                M = e(this, \"contains\"),\n                P = e(this, \"deep\");\n              new r(i, p, m, !0).to.be.an(\"array\"),\n                M\n                  ? this.assert(\n                      i.some(function (O) {\n                        return y.indexOf(O) > -1;\n                      }),\n                      \"expected #{this} to contain one of #{exp}\",\n                      \"expected #{this} to not contain one of #{exp}\",\n                      i,\n                      y\n                    )\n                  : P\n                    ? this.assert(\n                        i.some(function (O) {\n                          return a.eql(y, O);\n                        }),\n                        \"expected #{this} to deeply equal one of #{exp}\",\n                        \"expected #{this} to deeply equal one of #{exp}\",\n                        i,\n                        y\n                      )\n                    : this.assert(\n                        i.indexOf(y) > -1,\n                        \"expected #{this} to be one of #{exp}\",\n                        \"expected #{this} to not be one of #{exp}\",\n                        i,\n                        y\n                      );\n            }\n            function te(i, u, y) {\n              y && e(this, \"message\", y);\n              var p,\n                m = e(this, \"object\"),\n                M = e(this, \"message\"),\n                P = e(this, \"ssfi\");\n              new r(m, M, P, !0).is.a(\"function\"),\n                u\n                  ? (new r(i, M, P, !0).to.have.property(u), (p = i[u]))\n                  : (new r(i, M, P, !0).is.a(\"function\"), (p = i())),\n                m();\n              var O = u == null ? i() : i[u],\n                j = u == null ? p : \".\" + u;\n              e(this, \"deltaMsgObj\", j),\n                e(this, \"initialDeltaValue\", p),\n                e(this, \"finalDeltaValue\", O),\n                e(this, \"deltaBehavior\", \"change\"),\n                e(this, \"realDelta\", O !== p),\n                this.assert(\n                  p !== O,\n                  \"expected \" + j + \" to change\",\n                  \"expected \" + j + \" to not change\"\n                );\n            }\n            function X(i, u, y) {\n              y && e(this, \"message\", y);\n              var p,\n                m = e(this, \"object\"),\n                M = e(this, \"message\"),\n                P = e(this, \"ssfi\");\n              new r(m, M, P, !0).is.a(\"function\"),\n                u\n                  ? (new r(i, M, P, !0).to.have.property(u), (p = i[u]))\n                  : (new r(i, M, P, !0).is.a(\"function\"), (p = i())),\n                new r(p, M, P, !0).is.a(\"number\"),\n                m();\n              var O = u == null ? i() : i[u],\n                j = u == null ? p : \".\" + u;\n              e(this, \"deltaMsgObj\", j),\n                e(this, \"initialDeltaValue\", p),\n                e(this, \"finalDeltaValue\", O),\n                e(this, \"deltaBehavior\", \"increase\"),\n                e(this, \"realDelta\", O - p),\n                this.assert(\n                  O - p > 0,\n                  \"expected \" + j + \" to increase\",\n                  \"expected \" + j + \" to not increase\"\n                );\n            }\n            function Y(i, u, y) {\n              y && e(this, \"message\", y);\n              var p,\n                m = e(this, \"object\"),\n                M = e(this, \"message\"),\n                P = e(this, \"ssfi\");\n              new r(m, M, P, !0).is.a(\"function\"),\n                u\n                  ? (new r(i, M, P, !0).to.have.property(u), (p = i[u]))\n                  : (new r(i, M, P, !0).is.a(\"function\"), (p = i())),\n                new r(p, M, P, !0).is.a(\"number\"),\n                m();\n              var O = u == null ? i() : i[u],\n                j = u == null ? p : \".\" + u;\n              e(this, \"deltaMsgObj\", j),\n                e(this, \"initialDeltaValue\", p),\n                e(this, \"finalDeltaValue\", O),\n                e(this, \"deltaBehavior\", \"decrease\"),\n                e(this, \"realDelta\", p - O),\n                this.assert(\n                  O - p < 0,\n                  \"expected \" + j + \" to decrease\",\n                  \"expected \" + j + \" to not decrease\"\n                );\n            }\n            function oe(i, u) {\n              u && e(this, \"message\", u);\n              var y,\n                p = e(this, \"deltaMsgObj\"),\n                m = e(this, \"initialDeltaValue\"),\n                M = e(this, \"finalDeltaValue\"),\n                P = e(this, \"deltaBehavior\"),\n                O = e(this, \"realDelta\");\n              (y =\n                P === \"change\"\n                  ? Math.abs(M - m) === Math.abs(i)\n                  : O === Math.abs(i)),\n                this.assert(\n                  y,\n                  \"expected \" + p + \" to \" + P + \" by \" + i,\n                  \"expected \" + p + \" to not \" + P + \" by \" + i\n                );\n            }\n            [\n              \"to\",\n              \"be\",\n              \"been\",\n              \"is\",\n              \"and\",\n              \"has\",\n              \"have\",\n              \"with\",\n              \"that\",\n              \"which\",\n              \"at\",\n              \"of\",\n              \"same\",\n              \"but\",\n              \"does\",\n              \"still\",\n              \"also\",\n            ].forEach(function (i) {\n              r.addProperty(i);\n            }),\n              r.addProperty(\"not\", function () {\n                e(this, \"negate\", !0);\n              }),\n              r.addProperty(\"deep\", function () {\n                e(this, \"deep\", !0);\n              }),\n              r.addProperty(\"nested\", function () {\n                e(this, \"nested\", !0);\n              }),\n              r.addProperty(\"own\", function () {\n                e(this, \"own\", !0);\n              }),\n              r.addProperty(\"ordered\", function () {\n                e(this, \"ordered\", !0);\n              }),\n              r.addProperty(\"any\", function () {\n                e(this, \"any\", !0), e(this, \"all\", !1);\n              }),\n              r.addProperty(\"all\", function () {\n                e(this, \"all\", !0), e(this, \"any\", !1);\n              }),\n              r.addChainableMethod(\"an\", o),\n              r.addChainableMethod(\"a\", o),\n              r.addChainableMethod(\"include\", s, n),\n              r.addChainableMethod(\"contain\", s, n),\n              r.addChainableMethod(\"contains\", s, n),\n              r.addChainableMethod(\"includes\", s, n),\n              r.addProperty(\"ok\", function () {\n                this.assert(\n                  e(this, \"object\"),\n                  \"expected #{this} to be truthy\",\n                  \"expected #{this} to be falsy\"\n                );\n              }),\n              r.addProperty(\"true\", function () {\n                this.assert(\n                  e(this, \"object\") === !0,\n                  \"expected #{this} to be true\",\n                  \"expected #{this} to be false\",\n                  !e(this, \"negate\")\n                );\n              }),\n              r.addProperty(\"false\", function () {\n                this.assert(\n                  e(this, \"object\") === !1,\n                  \"expected #{this} to be false\",\n                  \"expected #{this} to be true\",\n                  !!e(this, \"negate\")\n                );\n              }),\n              r.addProperty(\"null\", function () {\n                this.assert(\n                  e(this, \"object\") === null,\n                  \"expected #{this} to be null\",\n                  \"expected #{this} not to be null\"\n                );\n              }),\n              r.addProperty(\"undefined\", function () {\n                this.assert(\n                  e(this, \"object\") === void 0,\n                  \"expected #{this} to be undefined\",\n                  \"expected #{this} not to be undefined\"\n                );\n              }),\n              r.addProperty(\"NaN\", function () {\n                this.assert(\n                  a.isNaN(e(this, \"object\")),\n                  \"expected #{this} to be NaN\",\n                  \"expected #{this} not to be NaN\"\n                );\n              }),\n              r.addProperty(\"exist\", f),\n              r.addProperty(\"exists\", f),\n              r.addProperty(\"empty\", function () {\n                var i,\n                  u = e(this, \"object\"),\n                  y = e(this, \"ssfi\"),\n                  p = e(this, \"message\");\n                switch (((p = p ? p + \": \" : \"\"), a.type(u).toLowerCase())) {\n                  case \"array\":\n                  case \"string\":\n                    i = u.length;\n                    break;\n                  case \"map\":\n                  case \"set\":\n                    i = u.size;\n                    break;\n                  case \"weakmap\":\n                  case \"weakset\":\n                    throw new h(\n                      p + \".empty was passed a weak collection\",\n                      void 0,\n                      y\n                    );\n                  case \"function\":\n                    var m = p + \".empty was passed a function \" + a.getName(u);\n                    throw new h(m.trim(), void 0, y);\n                  default:\n                    if (u !== Object(u))\n                      throw new h(\n                        p +\n                          \".empty was passed non-string primitive \" +\n                          a.inspect(u),\n                        void 0,\n                        y\n                      );\n                    i = Object.keys(u).length;\n                }\n                this.assert(\n                  i === 0,\n                  \"expected #{this} to be empty\",\n                  \"expected #{this} not to be empty\"\n                );\n              }),\n              r.addProperty(\"arguments\", b),\n              r.addProperty(\"Arguments\", b),\n              r.addMethod(\"equal\", E),\n              r.addMethod(\"equals\", E),\n              r.addMethod(\"eq\", E),\n              r.addMethod(\"eql\", T),\n              r.addMethod(\"eqls\", T),\n              r.addMethod(\"above\", C),\n              r.addMethod(\"gt\", C),\n              r.addMethod(\"greaterThan\", C),\n              r.addMethod(\"least\", B),\n              r.addMethod(\"gte\", B),\n              r.addMethod(\"greaterThanOrEqual\", B),\n              r.addMethod(\"below\", _),\n              r.addMethod(\"lt\", _),\n              r.addMethod(\"lessThan\", _),\n              r.addMethod(\"most\", H),\n              r.addMethod(\"lte\", H),\n              r.addMethod(\"lessThanOrEqual\", H),\n              r.addMethod(\"within\", function (i, u, y) {\n                y && e(this, \"message\", y);\n                var p,\n                  m = e(this, \"object\"),\n                  M = e(this, \"doLength\"),\n                  P = e(this, \"message\"),\n                  O = P ? P + \": \" : \"\",\n                  j = e(this, \"ssfi\"),\n                  A = a.type(m).toLowerCase(),\n                  L = a.type(i).toLowerCase(),\n                  q = a.type(u).toLowerCase(),\n                  z = !0,\n                  V =\n                    L === \"date\" && q === \"date\"\n                      ? i.toUTCString() + \"..\" + u.toUTCString()\n                      : i + \"..\" + u;\n                if (\n                  (M &&\n                    A !== \"map\" &&\n                    A !== \"set\" &&\n                    new r(m, P, j, !0).to.have.property(\"length\"),\n                  M || A !== \"date\" || (L === \"date\" && q === \"date\")\n                    ? (L === \"number\" && q === \"number\") ||\n                      (!M && A !== \"number\")\n                      ? M || A === \"date\" || A === \"number\"\n                        ? (z = !1)\n                        : (p =\n                            O +\n                            \"expected \" +\n                            (A === \"string\" ? \"'\" + m + \"'\" : m) +\n                            \" to be a number or a date\")\n                      : (p = O + \"the arguments to within must be numbers\")\n                    : (p = O + \"the arguments to within must be dates\"),\n                  z)\n                )\n                  throw new h(p, void 0, j);\n                if (M) {\n                  var F,\n                    W = \"length\";\n                  A === \"map\" || A === \"set\"\n                    ? ((W = \"size\"), (F = m.size))\n                    : (F = m.length),\n                    this.assert(\n                      F >= i && F <= u,\n                      \"expected #{this} to have a \" + W + \" within \" + V,\n                      \"expected #{this} to not have a \" + W + \" within \" + V\n                    );\n                } else\n                  this.assert(\n                    m >= i && m <= u,\n                    \"expected #{this} to be within \" + V,\n                    \"expected #{this} to not be within \" + V\n                  );\n              }),\n              r.addMethod(\"instanceof\", U),\n              r.addMethod(\"instanceOf\", U),\n              r.addMethod(\"property\", R),\n              r.addMethod(\"ownProperty\", x),\n              r.addMethod(\"haveOwnProperty\", x),\n              r.addMethod(\"ownPropertyDescriptor\", c),\n              r.addMethod(\"haveOwnPropertyDescriptor\", c),\n              r.addChainableMethod(\"length\", N, g),\n              r.addChainableMethod(\"lengthOf\", N, g),\n              r.addMethod(\"match\", S),\n              r.addMethod(\"matches\", S),\n              r.addMethod(\"string\", function (i, u) {\n                u && e(this, \"message\", u);\n                var y = e(this, \"object\"),\n                  p = e(this, \"message\"),\n                  m = e(this, \"ssfi\");\n                new r(y, p, m, !0).is.a(\"string\"),\n                  this.assert(\n                    ~y.indexOf(i),\n                    \"expected #{this} to contain \" + a.inspect(i),\n                    \"expected #{this} to not contain \" + a.inspect(i)\n                  );\n              }),\n              r.addMethod(\"keys\", k),\n              r.addMethod(\"key\", k),\n              r.addMethod(\"throw\", D),\n              r.addMethod(\"throws\", D),\n              r.addMethod(\"Throw\", D),\n              r.addMethod(\"respondTo\", I),\n              r.addMethod(\"respondsTo\", I),\n              r.addProperty(\"itself\", function () {\n                e(this, \"itself\", !0);\n              }),\n              r.addMethod(\"satisfy\", K),\n              r.addMethod(\"satisfies\", K),\n              r.addMethod(\"closeTo\", G),\n              r.addMethod(\"approximately\", G),\n              r.addMethod(\"members\", function (i, u) {\n                u && e(this, \"message\", u);\n                var y = e(this, \"object\"),\n                  p = e(this, \"message\"),\n                  m = e(this, \"ssfi\");\n                new r(y, p, m, !0).to.be.an(\"array\"),\n                  new r(i, p, m, !0).to.be.an(\"array\");\n                var M,\n                  P,\n                  O,\n                  j = e(this, \"contains\"),\n                  A = e(this, \"ordered\");\n                j\n                  ? ((P =\n                      \"expected #{this} to be \" +\n                      (M = A ? \"an ordered superset\" : \"a superset\") +\n                      \" of #{exp}\"),\n                    (O = \"expected #{this} to not be \" + M + \" of #{exp}\"))\n                  : ((P =\n                      \"expected #{this} to have the same \" +\n                      (M = A ? \"ordered members\" : \"members\") +\n                      \" as #{exp}\"),\n                    (O =\n                      \"expected #{this} to not have the same \" +\n                      M +\n                      \" as #{exp}\"));\n                var L = e(this, \"deep\") ? a.eql : void 0;\n                this.assert(Z(i, y, L, j, A), P, O, i, y, !0);\n              }),\n              r.addMethod(\"oneOf\", J),\n              r.addMethod(\"change\", te),\n              r.addMethod(\"changes\", te),\n              r.addMethod(\"increase\", X),\n              r.addMethod(\"increases\", X),\n              r.addMethod(\"decrease\", Y),\n              r.addMethod(\"decreases\", Y),\n              r.addMethod(\"by\", oe),\n              r.addProperty(\"extensible\", function () {\n                var i = e(this, \"object\"),\n                  u = i === Object(i) && Object.isExtensible(i);\n                this.assert(\n                  u,\n                  \"expected #{this} to be extensible\",\n                  \"expected #{this} to not be extensible\"\n                );\n              }),\n              r.addProperty(\"sealed\", function () {\n                var i = e(this, \"object\"),\n                  u = i !== Object(i) || Object.isSealed(i);\n                this.assert(\n                  u,\n                  \"expected #{this} to be sealed\",\n                  \"expected #{this} to not be sealed\"\n                );\n              }),\n              r.addProperty(\"frozen\", function () {\n                var i = e(this, \"object\"),\n                  u = i !== Object(i) || Object.isFrozen(i);\n                this.assert(\n                  u,\n                  \"expected #{this} to be frozen\",\n                  \"expected #{this} to not be frozen\"\n                );\n              }),\n              r.addProperty(\"finite\", function (i) {\n                var u = e(this, \"object\");\n                this.assert(\n                  typeof u == \"number\" && isFinite(u),\n                  \"expected #{this} to be a finite number\",\n                  \"expected #{this} to not be a finite number\"\n                );\n              });\n          };\n        },\n        {},\n      ],\n      6: [\n        function (l, v, w) {\n          v.exports = function (d, a) {\n            var r = d.Assertion,\n              h = a.flag,\n              e = (d.assert = function (o, t) {\n                new r(null, null, d.assert, !0).assert(\n                  o,\n                  t,\n                  \"[ negation message unavailable ]\"\n                );\n              });\n            (e.fail = function (o, t, n, s) {\n              throw (\n                (arguments.length < 2 && ((n = o), (o = void 0)),\n                (n = n || \"assert.fail()\"),\n                new d.AssertionError(\n                  n,\n                  { actual: o, expected: t, operator: s },\n                  e.fail\n                ))\n              );\n            }),\n              (e.isOk = function (o, t) {\n                new r(o, t, e.isOk, !0).is.ok;\n              }),\n              (e.isNotOk = function (o, t) {\n                new r(o, t, e.isNotOk, !0).is.not.ok;\n              }),\n              (e.equal = function (o, t, n) {\n                var s = new r(o, n, e.equal, !0);\n                s.assert(\n                  t == h(s, \"object\"),\n                  \"expected #{this} to equal #{exp}\",\n                  \"expected #{this} to not equal #{act}\",\n                  t,\n                  o,\n                  !0\n                );\n              }),\n              (e.notEqual = function (o, t, n) {\n                var s = new r(o, n, e.notEqual, !0);\n                s.assert(\n                  t != h(s, \"object\"),\n                  \"expected #{this} to not equal #{exp}\",\n                  \"expected #{this} to equal #{act}\",\n                  t,\n                  o,\n                  !0\n                );\n              }),\n              (e.strictEqual = function (o, t, n) {\n                new r(o, n, e.strictEqual, !0).to.equal(t);\n              }),\n              (e.notStrictEqual = function (o, t, n) {\n                new r(o, n, e.notStrictEqual, !0).to.not.equal(t);\n              }),\n              (e.deepEqual = e.deepStrictEqual =\n                function (o, t, n) {\n                  new r(o, n, e.deepEqual, !0).to.eql(t);\n                }),\n              (e.notDeepEqual = function (o, t, n) {\n                new r(o, n, e.notDeepEqual, !0).to.not.eql(t);\n              }),\n              (e.isAbove = function (o, t, n) {\n                new r(o, n, e.isAbove, !0).to.be.above(t);\n              }),\n              (e.isAtLeast = function (o, t, n) {\n                new r(o, n, e.isAtLeast, !0).to.be.least(t);\n              }),\n              (e.isBelow = function (o, t, n) {\n                new r(o, n, e.isBelow, !0).to.be.below(t);\n              }),\n              (e.isAtMost = function (o, t, n) {\n                new r(o, n, e.isAtMost, !0).to.be.most(t);\n              }),\n              (e.isTrue = function (o, t) {\n                new r(o, t, e.isTrue, !0).is.true;\n              }),\n              (e.isNotTrue = function (o, t) {\n                new r(o, t, e.isNotTrue, !0).to.not.equal(!0);\n              }),\n              (e.isFalse = function (o, t) {\n                new r(o, t, e.isFalse, !0).is.false;\n              }),\n              (e.isNotFalse = function (o, t) {\n                new r(o, t, e.isNotFalse, !0).to.not.equal(!1);\n              }),\n              (e.isNull = function (o, t) {\n                new r(o, t, e.isNull, !0).to.equal(null);\n              }),\n              (e.isNotNull = function (o, t) {\n                new r(o, t, e.isNotNull, !0).to.not.equal(null);\n              }),\n              (e.isNaN = function (o, t) {\n                new r(o, t, e.isNaN, !0).to.be.NaN;\n              }),\n              (e.isNotNaN = function (o, t) {\n                new r(o, t, e.isNotNaN, !0).not.to.be.NaN;\n              }),\n              (e.exists = function (o, t) {\n                new r(o, t, e.exists, !0).to.exist;\n              }),\n              (e.notExists = function (o, t) {\n                new r(o, t, e.notExists, !0).to.not.exist;\n              }),\n              (e.isUndefined = function (o, t) {\n                new r(o, t, e.isUndefined, !0).to.equal(void 0);\n              }),\n              (e.isDefined = function (o, t) {\n                new r(o, t, e.isDefined, !0).to.not.equal(void 0);\n              }),\n              (e.isFunction = function (o, t) {\n                new r(o, t, e.isFunction, !0).to.be.a(\"function\");\n              }),\n              (e.isNotFunction = function (o, t) {\n                new r(o, t, e.isNotFunction, !0).to.not.be.a(\"function\");\n              }),\n              (e.isObject = function (o, t) {\n                new r(o, t, e.isObject, !0).to.be.a(\"object\");\n              }),\n              (e.isNotObject = function (o, t) {\n                new r(o, t, e.isNotObject, !0).to.not.be.a(\"object\");\n              }),\n              (e.isArray = function (o, t) {\n                new r(o, t, e.isArray, !0).to.be.an(\"array\");\n              }),\n              (e.isNotArray = function (o, t) {\n                new r(o, t, e.isNotArray, !0).to.not.be.an(\"array\");\n              }),\n              (e.isString = function (o, t) {\n                new r(o, t, e.isString, !0).to.be.a(\"string\");\n              }),\n              (e.isNotString = function (o, t) {\n                new r(o, t, e.isNotString, !0).to.not.be.a(\"string\");\n              }),\n              (e.isNumber = function (o, t) {\n                new r(o, t, e.isNumber, !0).to.be.a(\"number\");\n              }),\n              (e.isNotNumber = function (o, t) {\n                new r(o, t, e.isNotNumber, !0).to.not.be.a(\"number\");\n              }),\n              (e.isFinite = function (o, t) {\n                new r(o, t, e.isFinite, !0).to.be.finite;\n              }),\n              (e.isBoolean = function (o, t) {\n                new r(o, t, e.isBoolean, !0).to.be.a(\"boolean\");\n              }),\n              (e.isNotBoolean = function (o, t) {\n                new r(o, t, e.isNotBoolean, !0).to.not.be.a(\"boolean\");\n              }),\n              (e.typeOf = function (o, t, n) {\n                new r(o, n, e.typeOf, !0).to.be.a(t);\n              }),\n              (e.notTypeOf = function (o, t, n) {\n                new r(o, n, e.notTypeOf, !0).to.not.be.a(t);\n              }),\n              (e.instanceOf = function (o, t, n) {\n                new r(o, n, e.instanceOf, !0).to.be.instanceOf(t);\n              }),\n              (e.notInstanceOf = function (o, t, n) {\n                new r(o, n, e.notInstanceOf, !0).to.not.be.instanceOf(t);\n              }),\n              (e.include = function (o, t, n) {\n                new r(o, n, e.include, !0).include(t);\n              }),\n              (e.notInclude = function (o, t, n) {\n                new r(o, n, e.notInclude, !0).not.include(t);\n              }),\n              (e.deepInclude = function (o, t, n) {\n                new r(o, n, e.deepInclude, !0).deep.include(t);\n              }),\n              (e.notDeepInclude = function (o, t, n) {\n                new r(o, n, e.notDeepInclude, !0).not.deep.include(t);\n              }),\n              (e.nestedInclude = function (o, t, n) {\n                new r(o, n, e.nestedInclude, !0).nested.include(t);\n              }),\n              (e.notNestedInclude = function (o, t, n) {\n                new r(o, n, e.notNestedInclude, !0).not.nested.include(t);\n              }),\n              (e.deepNestedInclude = function (o, t, n) {\n                new r(o, n, e.deepNestedInclude, !0).deep.nested.include(t);\n              }),\n              (e.notDeepNestedInclude = function (o, t, n) {\n                new r(o, n, e.notDeepNestedInclude, !0).not.deep.nested.include(\n                  t\n                );\n              }),\n              (e.ownInclude = function (o, t, n) {\n                new r(o, n, e.ownInclude, !0).own.include(t);\n              }),\n              (e.notOwnInclude = function (o, t, n) {\n                new r(o, n, e.notOwnInclude, !0).not.own.include(t);\n              }),\n              (e.deepOwnInclude = function (o, t, n) {\n                new r(o, n, e.deepOwnInclude, !0).deep.own.include(t);\n              }),\n              (e.notDeepOwnInclude = function (o, t, n) {\n                new r(o, n, e.notDeepOwnInclude, !0).not.deep.own.include(t);\n              }),\n              (e.match = function (o, t, n) {\n                new r(o, n, e.match, !0).to.match(t);\n              }),\n              (e.notMatch = function (o, t, n) {\n                new r(o, n, e.notMatch, !0).to.not.match(t);\n              }),\n              (e.property = function (o, t, n) {\n                new r(o, n, e.property, !0).to.have.property(t);\n              }),\n              (e.notProperty = function (o, t, n) {\n                new r(o, n, e.notProperty, !0).to.not.have.property(t);\n              }),\n              (e.propertyVal = function (o, t, n, s) {\n                new r(o, s, e.propertyVal, !0).to.have.property(t, n);\n              }),\n              (e.notPropertyVal = function (o, t, n, s) {\n                new r(o, s, e.notPropertyVal, !0).to.not.have.property(t, n);\n              }),\n              (e.deepPropertyVal = function (o, t, n, s) {\n                new r(o, s, e.deepPropertyVal, !0).to.have.deep.property(t, n);\n              }),\n              (e.notDeepPropertyVal = function (o, t, n, s) {\n                new r(o, s, e.notDeepPropertyVal, !0).to.not.have.deep.property(\n                  t,\n                  n\n                );\n              }),\n              (e.ownProperty = function (o, t, n) {\n                new r(o, n, e.ownProperty, !0).to.have.own.property(t);\n              }),\n              (e.notOwnProperty = function (o, t, n) {\n                new r(o, n, e.notOwnProperty, !0).to.not.have.own.property(t);\n              }),\n              (e.ownPropertyVal = function (o, t, n, s) {\n                new r(o, s, e.ownPropertyVal, !0).to.have.own.property(t, n);\n              }),\n              (e.notOwnPropertyVal = function (o, t, n, s) {\n                new r(o, s, e.notOwnPropertyVal, !0).to.not.have.own.property(\n                  t,\n                  n\n                );\n              }),\n              (e.deepOwnPropertyVal = function (o, t, n, s) {\n                new r(o, s, e.deepOwnPropertyVal, !0).to.have.deep.own.property(\n                  t,\n                  n\n                );\n              }),\n              (e.notDeepOwnPropertyVal = function (o, t, n, s) {\n                new r(\n                  o,\n                  s,\n                  e.notDeepOwnPropertyVal,\n                  !0\n                ).to.not.have.deep.own.property(t, n);\n              }),\n              (e.nestedProperty = function (o, t, n) {\n                new r(o, n, e.nestedProperty, !0).to.have.nested.property(t);\n              }),\n              (e.notNestedProperty = function (o, t, n) {\n                new r(\n                  o,\n                  n,\n                  e.notNestedProperty,\n                  !0\n                ).to.not.have.nested.property(t);\n              }),\n              (e.nestedPropertyVal = function (o, t, n, s) {\n                new r(o, s, e.nestedPropertyVal, !0).to.have.nested.property(\n                  t,\n                  n\n                );\n              }),\n              (e.notNestedPropertyVal = function (o, t, n, s) {\n                new r(\n                  o,\n                  s,\n                  e.notNestedPropertyVal,\n                  !0\n                ).to.not.have.nested.property(t, n);\n              }),\n              (e.deepNestedPropertyVal = function (o, t, n, s) {\n                new r(\n                  o,\n                  s,\n                  e.deepNestedPropertyVal,\n                  !0\n                ).to.have.deep.nested.property(t, n);\n              }),\n              (e.notDeepNestedPropertyVal = function (o, t, n, s) {\n                new r(\n                  o,\n                  s,\n                  e.notDeepNestedPropertyVal,\n                  !0\n                ).to.not.have.deep.nested.property(t, n);\n              }),\n              (e.lengthOf = function (o, t, n) {\n                new r(o, n, e.lengthOf, !0).to.have.lengthOf(t);\n              }),\n              (e.hasAnyKeys = function (o, t, n) {\n                new r(o, n, e.hasAnyKeys, !0).to.have.any.keys(t);\n              }),\n              (e.hasAllKeys = function (o, t, n) {\n                new r(o, n, e.hasAllKeys, !0).to.have.all.keys(t);\n              }),\n              (e.containsAllKeys = function (o, t, n) {\n                new r(o, n, e.containsAllKeys, !0).to.contain.all.keys(t);\n              }),\n              (e.doesNotHaveAnyKeys = function (o, t, n) {\n                new r(o, n, e.doesNotHaveAnyKeys, !0).to.not.have.any.keys(t);\n              }),\n              (e.doesNotHaveAllKeys = function (o, t, n) {\n                new r(o, n, e.doesNotHaveAllKeys, !0).to.not.have.all.keys(t);\n              }),\n              (e.hasAnyDeepKeys = function (o, t, n) {\n                new r(o, n, e.hasAnyDeepKeys, !0).to.have.any.deep.keys(t);\n              }),\n              (e.hasAllDeepKeys = function (o, t, n) {\n                new r(o, n, e.hasAllDeepKeys, !0).to.have.all.deep.keys(t);\n              }),\n              (e.containsAllDeepKeys = function (o, t, n) {\n                new r(o, n, e.containsAllDeepKeys, !0).to.contain.all.deep.keys(\n                  t\n                );\n              }),\n              (e.doesNotHaveAnyDeepKeys = function (o, t, n) {\n                new r(\n                  o,\n                  n,\n                  e.doesNotHaveAnyDeepKeys,\n                  !0\n                ).to.not.have.any.deep.keys(t);\n              }),\n              (e.doesNotHaveAllDeepKeys = function (o, t, n) {\n                new r(\n                  o,\n                  n,\n                  e.doesNotHaveAllDeepKeys,\n                  !0\n                ).to.not.have.all.deep.keys(t);\n              }),\n              (e.throws = function (o, t, n, s) {\n                (typeof t == \"string\" || t instanceof RegExp) &&\n                  ((n = t), (t = null));\n                var f = new r(o, s, e.throws, !0).to.throw(t, n);\n                return h(f, \"object\");\n              }),\n              (e.doesNotThrow = function (o, t, n, s) {\n                (typeof t == \"string\" || t instanceof RegExp) &&\n                  ((n = t), (t = null)),\n                  new r(o, s, e.doesNotThrow, !0).to.not.throw(t, n);\n              }),\n              (e.operator = function (o, t, n, s) {\n                var f;\n                switch (t) {\n                  case \"==\":\n                    f = o == n;\n                    break;\n                  case \"===\":\n                    f = o === n;\n                    break;\n                  case \">\":\n                    f = o > n;\n                    break;\n                  case \">=\":\n                    f = o >= n;\n                    break;\n                  case \"<\":\n                    f = o < n;\n                    break;\n                  case \"<=\":\n                    f = o <= n;\n                    break;\n                  case \"!=\":\n                    f = o != n;\n                    break;\n                  case \"!==\":\n                    f = o !== n;\n                    break;\n                  default:\n                    throw (\n                      ((s = s && s + \": \"),\n                      new d.AssertionError(\n                        s + 'Invalid operator \"' + t + '\"',\n                        void 0,\n                        e.operator\n                      ))\n                    );\n                }\n                var b = new r(f, s, e.operator, !0);\n                b.assert(\n                  h(b, \"object\") === !0,\n                  \"expected \" +\n                    a.inspect(o) +\n                    \" to be \" +\n                    t +\n                    \" \" +\n                    a.inspect(n),\n                  \"expected \" +\n                    a.inspect(o) +\n                    \" to not be \" +\n                    t +\n                    \" \" +\n                    a.inspect(n)\n                );\n              }),\n              (e.closeTo = function (o, t, n, s) {\n                new r(o, s, e.closeTo, !0).to.be.closeTo(t, n);\n              }),\n              (e.approximately = function (o, t, n, s) {\n                new r(o, s, e.approximately, !0).to.be.approximately(t, n);\n              }),\n              (e.sameMembers = function (o, t, n) {\n                new r(o, n, e.sameMembers, !0).to.have.same.members(t);\n              }),\n              (e.notSameMembers = function (o, t, n) {\n                new r(o, n, e.notSameMembers, !0).to.not.have.same.members(t);\n              }),\n              (e.sameDeepMembers = function (o, t, n) {\n                new r(o, n, e.sameDeepMembers, !0).to.have.same.deep.members(t);\n              }),\n              (e.notSameDeepMembers = function (o, t, n) {\n                new r(\n                  o,\n                  n,\n                  e.notSameDeepMembers,\n                  !0\n                ).to.not.have.same.deep.members(t);\n              }),\n              (e.sameOrderedMembers = function (o, t, n) {\n                new r(\n                  o,\n                  n,\n                  e.sameOrderedMembers,\n                  !0\n                ).to.have.same.ordered.members(t);\n              }),\n              (e.notSameOrderedMembers = function (o, t, n) {\n                new r(\n                  o,\n                  n,\n                  e.notSameOrderedMembers,\n                  !0\n                ).to.not.have.same.ordered.members(t);\n              }),\n              (e.sameDeepOrderedMembers = function (o, t, n) {\n                new r(\n                  o,\n                  n,\n                  e.sameDeepOrderedMembers,\n                  !0\n                ).to.have.same.deep.ordered.members(t);\n              }),\n              (e.notSameDeepOrderedMembers = function (o, t, n) {\n                new r(\n                  o,\n                  n,\n                  e.notSameDeepOrderedMembers,\n                  !0\n                ).to.not.have.same.deep.ordered.members(t);\n              }),\n              (e.includeMembers = function (o, t, n) {\n                new r(o, n, e.includeMembers, !0).to.include.members(t);\n              }),\n              (e.notIncludeMembers = function (o, t, n) {\n                new r(o, n, e.notIncludeMembers, !0).to.not.include.members(t);\n              }),\n              (e.includeDeepMembers = function (o, t, n) {\n                new r(o, n, e.includeDeepMembers, !0).to.include.deep.members(\n                  t\n                );\n              }),\n              (e.notIncludeDeepMembers = function (o, t, n) {\n                new r(\n                  o,\n                  n,\n                  e.notIncludeDeepMembers,\n                  !0\n                ).to.not.include.deep.members(t);\n              }),\n              (e.includeOrderedMembers = function (o, t, n) {\n                new r(\n                  o,\n                  n,\n                  e.includeOrderedMembers,\n                  !0\n                ).to.include.ordered.members(t);\n              }),\n              (e.notIncludeOrderedMembers = function (o, t, n) {\n                new r(\n                  o,\n                  n,\n                  e.notIncludeOrderedMembers,\n                  !0\n                ).to.not.include.ordered.members(t);\n              }),\n              (e.includeDeepOrderedMembers = function (o, t, n) {\n                new r(\n                  o,\n                  n,\n                  e.includeDeepOrderedMembers,\n                  !0\n                ).to.include.deep.ordered.members(t);\n              }),\n              (e.notIncludeDeepOrderedMembers = function (o, t, n) {\n                new r(\n                  o,\n                  n,\n                  e.notIncludeDeepOrderedMembers,\n                  !0\n                ).to.not.include.deep.ordered.members(t);\n              }),\n              (e.oneOf = function (o, t, n) {\n                new r(o, n, e.oneOf, !0).to.be.oneOf(t);\n              }),\n              (e.changes = function (o, t, n, s) {\n                arguments.length === 3 &&\n                  typeof t == \"function\" &&\n                  ((s = n), (n = null)),\n                  new r(o, s, e.changes, !0).to.change(t, n);\n              }),\n              (e.changesBy = function (o, t, n, s, f) {\n                if (arguments.length === 4 && typeof t == \"function\") {\n                  var b = s;\n                  (s = n), (f = b);\n                } else arguments.length === 3 && ((s = n), (n = null));\n                new r(o, f, e.changesBy, !0).to.change(t, n).by(s);\n              }),\n              (e.doesNotChange = function (o, t, n, s) {\n                return (\n                  arguments.length === 3 &&\n                    typeof t == \"function\" &&\n                    ((s = n), (n = null)),\n                  new r(o, s, e.doesNotChange, !0).to.not.change(t, n)\n                );\n              }),\n              (e.changesButNotBy = function (o, t, n, s, f) {\n                if (arguments.length === 4 && typeof t == \"function\") {\n                  var b = s;\n                  (s = n), (f = b);\n                } else arguments.length === 3 && ((s = n), (n = null));\n                new r(o, f, e.changesButNotBy, !0).to\n                  .change(t, n)\n                  .but.not.by(s);\n              }),\n              (e.increases = function (o, t, n, s) {\n                return (\n                  arguments.length === 3 &&\n                    typeof t == \"function\" &&\n                    ((s = n), (n = null)),\n                  new r(o, s, e.increases, !0).to.increase(t, n)\n                );\n              }),\n              (e.increasesBy = function (o, t, n, s, f) {\n                if (arguments.length === 4 && typeof t == \"function\") {\n                  var b = s;\n                  (s = n), (f = b);\n                } else arguments.length === 3 && ((s = n), (n = null));\n                new r(o, f, e.increasesBy, !0).to.increase(t, n).by(s);\n              }),\n              (e.doesNotIncrease = function (o, t, n, s) {\n                return (\n                  arguments.length === 3 &&\n                    typeof t == \"function\" &&\n                    ((s = n), (n = null)),\n                  new r(o, s, e.doesNotIncrease, !0).to.not.increase(t, n)\n                );\n              }),\n              (e.increasesButNotBy = function (o, t, n, s, f) {\n                if (arguments.length === 4 && typeof t == \"function\") {\n                  var b = s;\n                  (s = n), (f = b);\n                } else arguments.length === 3 && ((s = n), (n = null));\n                new r(o, f, e.increasesButNotBy, !0).to\n                  .increase(t, n)\n                  .but.not.by(s);\n              }),\n              (e.decreases = function (o, t, n, s) {\n                return (\n                  arguments.length === 3 &&\n                    typeof t == \"function\" &&\n                    ((s = n), (n = null)),\n                  new r(o, s, e.decreases, !0).to.decrease(t, n)\n                );\n              }),\n              (e.decreasesBy = function (o, t, n, s, f) {\n                if (arguments.length === 4 && typeof t == \"function\") {\n                  var b = s;\n                  (s = n), (f = b);\n                } else arguments.length === 3 && ((s = n), (n = null));\n                new r(o, f, e.decreasesBy, !0).to.decrease(t, n).by(s);\n              }),\n              (e.doesNotDecrease = function (o, t, n, s) {\n                return (\n                  arguments.length === 3 &&\n                    typeof t == \"function\" &&\n                    ((s = n), (n = null)),\n                  new r(o, s, e.doesNotDecrease, !0).to.not.decrease(t, n)\n                );\n              }),\n              (e.doesNotDecreaseBy = function (o, t, n, s, f) {\n                if (arguments.length === 4 && typeof t == \"function\") {\n                  var b = s;\n                  (s = n), (f = b);\n                } else arguments.length === 3 && ((s = n), (n = null));\n                return new r(o, f, e.doesNotDecreaseBy, !0).to.not\n                  .decrease(t, n)\n                  .by(s);\n              }),\n              (e.decreasesButNotBy = function (o, t, n, s, f) {\n                if (arguments.length === 4 && typeof t == \"function\") {\n                  var b = s;\n                  (s = n), (f = b);\n                } else arguments.length === 3 && ((s = n), (n = null));\n                new r(o, f, e.decreasesButNotBy, !0).to\n                  .decrease(t, n)\n                  .but.not.by(s);\n              }),\n              (e.ifError = function (o) {\n                if (o) throw o;\n              }),\n              (e.isExtensible = function (o, t) {\n                new r(o, t, e.isExtensible, !0).to.be.extensible;\n              }),\n              (e.isNotExtensible = function (o, t) {\n                new r(o, t, e.isNotExtensible, !0).to.not.be.extensible;\n              }),\n              (e.isSealed = function (o, t) {\n                new r(o, t, e.isSealed, !0).to.be.sealed;\n              }),\n              (e.isNotSealed = function (o, t) {\n                new r(o, t, e.isNotSealed, !0).to.not.be.sealed;\n              }),\n              (e.isFrozen = function (o, t) {\n                new r(o, t, e.isFrozen, !0).to.be.frozen;\n              }),\n              (e.isNotFrozen = function (o, t) {\n                new r(o, t, e.isNotFrozen, !0).to.not.be.frozen;\n              }),\n              (e.isEmpty = function (o, t) {\n                new r(o, t, e.isEmpty, !0).to.be.empty;\n              }),\n              (e.isNotEmpty = function (o, t) {\n                new r(o, t, e.isNotEmpty, !0).to.not.be.empty;\n              }),\n              (function o(t, n) {\n                return (e[n] = e[t]), o;\n              })(\"isOk\", \"ok\")(\"isNotOk\", \"notOk\")(\"throws\", \"throw\")(\n                \"throws\",\n                \"Throw\"\n              )(\"isExtensible\", \"extensible\")(\n                \"isNotExtensible\",\n                \"notExtensible\"\n              )(\"isSealed\", \"sealed\")(\"isNotSealed\", \"notSealed\")(\n                \"isFrozen\",\n                \"frozen\"\n              )(\"isNotFrozen\", \"notFrozen\")(\"isEmpty\", \"empty\")(\n                \"isNotEmpty\",\n                \"notEmpty\"\n              );\n          };\n        },\n        {},\n      ],\n      7: [\n        function (l, v, w) {\n          v.exports = function (d, a) {\n            (d.expect = function (r, h) {\n              return new d.Assertion(r, h);\n            }),\n              (d.expect.fail = function (r, h, e, o) {\n                throw (\n                  (arguments.length < 2 && ((e = r), (r = void 0)),\n                  (e = e || \"expect.fail()\"),\n                  new d.AssertionError(\n                    e,\n                    { actual: r, expected: h, operator: o },\n                    d.expect.fail\n                  ))\n                );\n              });\n          };\n        },\n        {},\n      ],\n      8: [\n        function (l, v, w) {\n          v.exports = function (d, a) {\n            var r = d.Assertion;\n            function h() {\n              function e() {\n                return this instanceof String ||\n                  this instanceof Number ||\n                  this instanceof Boolean ||\n                  (typeof Symbol == \"function\" && this instanceof Symbol) ||\n                  (typeof BigInt == \"function\" && this instanceof BigInt)\n                  ? new r(this.valueOf(), null, e)\n                  : new r(this, null, e);\n              }\n              function o(n) {\n                Object.defineProperty(this, \"should\", {\n                  value: n,\n                  enumerable: !0,\n                  configurable: !0,\n                  writable: !0,\n                });\n              }\n              Object.defineProperty(Object.prototype, \"should\", {\n                set: o,\n                get: e,\n                configurable: !0,\n              });\n              var t = {\n                fail: function (n, s, f, b) {\n                  throw (\n                    (arguments.length < 2 && ((f = n), (n = void 0)),\n                    (f = f || \"should.fail()\"),\n                    new d.AssertionError(\n                      f,\n                      { actual: n, expected: s, operator: b },\n                      t.fail\n                    ))\n                  );\n                },\n                equal: function (n, s, f) {\n                  new r(n, f).to.equal(s);\n                },\n                Throw: function (n, s, f, b) {\n                  new r(n, b).to.Throw(s, f);\n                },\n                exist: function (n, s) {\n                  new r(n, s).to.exist;\n                },\n                not: {},\n              };\n              return (\n                (t.not.equal = function (n, s, f) {\n                  new r(n, f).to.not.equal(s);\n                }),\n                (t.not.Throw = function (n, s, f, b) {\n                  new r(n, b).to.not.Throw(s, f);\n                }),\n                (t.not.exist = function (n, s) {\n                  new r(n, s).to.not.exist;\n                }),\n                (t.throw = t.Throw),\n                (t.not.throw = t.not.Throw),\n                t\n              );\n            }\n            (d.should = h), (d.Should = h);\n          };\n        },\n        {},\n      ],\n      9: [\n        function (l, v, w) {\n          var d = l(\"./addLengthGuard\"),\n            a = l(\"../../chai\"),\n            r = l(\"./flag\"),\n            h = l(\"./proxify\"),\n            e = l(\"./transferFlags\"),\n            o = typeof Object.setPrototypeOf == \"function\",\n            t = function () {},\n            n = Object.getOwnPropertyNames(t).filter(function (b) {\n              var E = Object.getOwnPropertyDescriptor(t, b);\n              return typeof E != \"object\" || !E.configurable;\n            }),\n            s = Function.prototype.call,\n            f = Function.prototype.apply;\n          v.exports = function (b, E, T, C) {\n            typeof C != \"function\" && (C = function () {});\n            var B = { method: T, chainingBehavior: C };\n            b.__methods || (b.__methods = {}),\n              (b.__methods[E] = B),\n              Object.defineProperty(b, E, {\n                get: function () {\n                  B.chainingBehavior.call(this);\n                  var _ = function () {\n                    r(this, \"lockSsfi\") || r(this, \"ssfi\", _);\n                    var U = B.method.apply(this, arguments);\n                    if (U !== void 0) return U;\n                    var R = new a.Assertion();\n                    return e(this, R), R;\n                  };\n                  if ((d(_, E, !0), o)) {\n                    var H = Object.create(this);\n                    (H.call = s), (H.apply = f), Object.setPrototypeOf(_, H);\n                  } else\n                    Object.getOwnPropertyNames(b).forEach(function (U) {\n                      if (n.indexOf(U) === -1) {\n                        var R = Object.getOwnPropertyDescriptor(b, U);\n                        Object.defineProperty(_, U, R);\n                      }\n                    });\n                  return e(this, _), h(_);\n                },\n                configurable: !0,\n              });\n          };\n        },\n        {\n          \"../../chai\": 2,\n          \"./addLengthGuard\": 10,\n          \"./flag\": 15,\n          \"./proxify\": 31,\n          \"./transferFlags\": 33,\n        },\n      ],\n      10: [\n        function (l, v, w) {\n          var d = Object.getOwnPropertyDescriptor(function () {}, \"length\");\n          v.exports = function (a, r, h) {\n            return (\n              d.configurable &&\n                Object.defineProperty(a, \"length\", {\n                  get: function () {\n                    throw Error(\n                      h\n                        ? \"Invalid Chai property: \" +\n                            r +\n                            '.length. Due to a compatibility issue, \"length\" cannot directly follow \"' +\n                            r +\n                            '\". Use \"' +\n                            r +\n                            '.lengthOf\" instead.'\n                        : \"Invalid Chai property: \" +\n                            r +\n                            '.length. See docs for proper usage of \"' +\n                            r +\n                            '\".'\n                    );\n                  },\n                }),\n              a\n            );\n          };\n        },\n        {},\n      ],\n      11: [\n        function (l, v, w) {\n          var d = l(\"./addLengthGuard\"),\n            a = l(\"../../chai\"),\n            r = l(\"./flag\"),\n            h = l(\"./proxify\"),\n            e = l(\"./transferFlags\");\n          v.exports = function (o, t, n) {\n            var s = function () {\n              r(this, \"lockSsfi\") || r(this, \"ssfi\", s);\n              var f = n.apply(this, arguments);\n              if (f !== void 0) return f;\n              var b = new a.Assertion();\n              return e(this, b), b;\n            };\n            d(s, t, !1), (o[t] = h(s, t));\n          };\n        },\n        {\n          \"../../chai\": 2,\n          \"./addLengthGuard\": 10,\n          \"./flag\": 15,\n          \"./proxify\": 31,\n          \"./transferFlags\": 33,\n        },\n      ],\n      12: [\n        function (l, v, w) {\n          var d = l(\"../../chai\"),\n            a = l(\"./flag\"),\n            r = l(\"./isProxyEnabled\"),\n            h = l(\"./transferFlags\");\n          v.exports = function (e, o, t) {\n            (t = t === void 0 ? function () {} : t),\n              Object.defineProperty(e, o, {\n                get: function n() {\n                  r() || a(this, \"lockSsfi\") || a(this, \"ssfi\", n);\n                  var s = t.call(this);\n                  if (s !== void 0) return s;\n                  var f = new d.Assertion();\n                  return h(this, f), f;\n                },\n                configurable: !0,\n              });\n          };\n        },\n        {\n          \"../../chai\": 2,\n          \"./flag\": 15,\n          \"./isProxyEnabled\": 26,\n          \"./transferFlags\": 33,\n        },\n      ],\n      13: [\n        function (l, v, w) {\n          var d = l(\"./inspect\");\n          v.exports = function (a, r) {\n            return d(a) < d(r) ? -1 : 1;\n          };\n        },\n        { \"./inspect\": 24 },\n      ],\n      14: [\n        function (l, v, w) {\n          var d = l(\"assertion-error\"),\n            a = l(\"./flag\"),\n            r = l(\"type-detect\");\n          v.exports = function (h, e) {\n            var o = a(h, \"message\"),\n              t = a(h, \"ssfi\");\n            (o = o ? o + \": \" : \"\"),\n              (h = a(h, \"object\")),\n              (e = e.map(function (f) {\n                return f.toLowerCase();\n              })).sort();\n            var n = e\n                .map(function (f, b) {\n                  var E = ~[\"a\", \"e\", \"i\", \"o\", \"u\"].indexOf(f.charAt(0))\n                    ? \"an\"\n                    : \"a\";\n                  return (\n                    (e.length > 1 && b === e.length - 1 ? \"or \" : \"\") +\n                    E +\n                    \" \" +\n                    f\n                  );\n                })\n                .join(\", \"),\n              s = r(h).toLowerCase();\n            if (\n              !e.some(function (f) {\n                return s === f;\n              })\n            )\n              throw new d(\n                o + \"object tested must be \" + n + \", but \" + s + \" given\",\n                void 0,\n                t\n              );\n          };\n        },\n        { \"./flag\": 15, \"assertion-error\": 34, \"type-detect\": 39 },\n      ],\n      15: [\n        function (l, v, w) {\n          v.exports = function (d, a, r) {\n            var h = d.__flags || (d.__flags = Object.create(null));\n            if (arguments.length !== 3) return h[a];\n            h[a] = r;\n          };\n        },\n        {},\n      ],\n      16: [\n        function (l, v, w) {\n          v.exports = function (d, a) {\n            return a.length > 4 ? a[4] : d._obj;\n          };\n        },\n        {},\n      ],\n      17: [\n        function (l, v, w) {\n          v.exports = function (d) {\n            var a = [];\n            for (var r in d) a.push(r);\n            return a;\n          };\n        },\n        {},\n      ],\n      18: [\n        function (l, v, w) {\n          var d = l(\"./flag\"),\n            a = l(\"./getActual\"),\n            r = l(\"./objDisplay\");\n          v.exports = function (h, e) {\n            var o = d(h, \"negate\"),\n              t = d(h, \"object\"),\n              n = e[3],\n              s = a(h, e),\n              f = o ? e[2] : e[1],\n              b = d(h, \"message\");\n            return (\n              typeof f == \"function\" && (f = f()),\n              (f = (f = f || \"\")\n                .replace(/#\\{this\\}/g, function () {\n                  return r(t);\n                })\n                .replace(/#\\{act\\}/g, function () {\n                  return r(s);\n                })\n                .replace(/#\\{exp\\}/g, function () {\n                  return r(n);\n                })),\n              b ? b + \": \" + f : f\n            );\n          };\n        },\n        { \"./flag\": 15, \"./getActual\": 16, \"./objDisplay\": 27 },\n      ],\n      19: [\n        function (l, v, w) {\n          var d = l(\"type-detect\"),\n            a = l(\"./flag\");\n          function r(h) {\n            var e = d(h);\n            return [\"Array\", \"Object\", \"function\"].indexOf(e) !== -1;\n          }\n          v.exports = function (h, e) {\n            var o = a(h, \"operator\"),\n              t = a(h, \"negate\"),\n              n = e[3],\n              s = t ? e[2] : e[1];\n            if (o) return o;\n            if (\n              (typeof s == \"function\" && (s = s()),\n              (s = s || \"\") && !/\\shave\\s/.test(s))\n            ) {\n              var f = r(n);\n              return /\\snot\\s/.test(s)\n                ? f\n                  ? \"notDeepStrictEqual\"\n                  : \"notStrictEqual\"\n                : f\n                  ? \"deepStrictEqual\"\n                  : \"strictEqual\";\n            }\n          };\n        },\n        { \"./flag\": 15, \"type-detect\": 39 },\n      ],\n      20: [\n        function (l, v, w) {\n          var d = l(\"./getOwnEnumerablePropertySymbols\");\n          v.exports = function (a) {\n            return Object.keys(a).concat(d(a));\n          };\n        },\n        { \"./getOwnEnumerablePropertySymbols\": 21 },\n      ],\n      21: [\n        function (l, v, w) {\n          v.exports = function (d) {\n            return typeof Object.getOwnPropertySymbols != \"function\"\n              ? []\n              : Object.getOwnPropertySymbols(d).filter(function (a) {\n                  return Object.getOwnPropertyDescriptor(d, a).enumerable;\n                });\n          };\n        },\n        {},\n      ],\n      22: [\n        function (l, v, w) {\n          v.exports = function (d) {\n            var a = Object.getOwnPropertyNames(d);\n            function r(e) {\n              a.indexOf(e) === -1 && a.push(e);\n            }\n            for (var h = Object.getPrototypeOf(d); h !== null; )\n              Object.getOwnPropertyNames(h).forEach(r),\n                (h = Object.getPrototypeOf(h));\n            return a;\n          };\n        },\n        {},\n      ],\n      23: [\n        function (l, v, w) {\n          var d = l(\"pathval\");\n          (w.test = l(\"./test\")),\n            (w.type = l(\"type-detect\")),\n            (w.expectTypes = l(\"./expectTypes\")),\n            (w.getMessage = l(\"./getMessage\")),\n            (w.getActual = l(\"./getActual\")),\n            (w.inspect = l(\"./inspect\")),\n            (w.objDisplay = l(\"./objDisplay\")),\n            (w.flag = l(\"./flag\")),\n            (w.transferFlags = l(\"./transferFlags\")),\n            (w.eql = l(\"deep-eql\")),\n            (w.getPathInfo = d.getPathInfo),\n            (w.hasProperty = d.hasProperty),\n            (w.getName = l(\"get-func-name\")),\n            (w.addProperty = l(\"./addProperty\")),\n            (w.addMethod = l(\"./addMethod\")),\n            (w.overwriteProperty = l(\"./overwriteProperty\")),\n            (w.overwriteMethod = l(\"./overwriteMethod\")),\n            (w.addChainableMethod = l(\"./addChainableMethod\")),\n            (w.overwriteChainableMethod = l(\"./overwriteChainableMethod\")),\n            (w.compareByInspect = l(\"./compareByInspect\")),\n            (w.getOwnEnumerablePropertySymbols = l(\n              \"./getOwnEnumerablePropertySymbols\"\n            )),\n            (w.getOwnEnumerableProperties = l(\"./getOwnEnumerableProperties\")),\n            (w.checkError = l(\"check-error\")),\n            (w.proxify = l(\"./proxify\")),\n            (w.addLengthGuard = l(\"./addLengthGuard\")),\n            (w.isProxyEnabled = l(\"./isProxyEnabled\")),\n            (w.isNaN = l(\"./isNaN\")),\n            (w.getOperator = l(\"./getOperator\"));\n        },\n        {\n          \"./addChainableMethod\": 9,\n          \"./addLengthGuard\": 10,\n          \"./addMethod\": 11,\n          \"./addProperty\": 12,\n          \"./compareByInspect\": 13,\n          \"./expectTypes\": 14,\n          \"./flag\": 15,\n          \"./getActual\": 16,\n          \"./getMessage\": 18,\n          \"./getOperator\": 19,\n          \"./getOwnEnumerableProperties\": 20,\n          \"./getOwnEnumerablePropertySymbols\": 21,\n          \"./inspect\": 24,\n          \"./isNaN\": 25,\n          \"./isProxyEnabled\": 26,\n          \"./objDisplay\": 27,\n          \"./overwriteChainableMethod\": 28,\n          \"./overwriteMethod\": 29,\n          \"./overwriteProperty\": 30,\n          \"./proxify\": 31,\n          \"./test\": 32,\n          \"./transferFlags\": 33,\n          \"check-error\": 35,\n          \"deep-eql\": 36,\n          \"get-func-name\": 37,\n          pathval: 38,\n          \"type-detect\": 39,\n        },\n      ],\n      24: [\n        function (l, v, w) {\n          var d = l(\"get-func-name\"),\n            a = l(\"./getProperties\"),\n            r = l(\"./getEnumerableProperties\"),\n            h = l(\"../config\");\n          function e(x, c, g, N) {\n            return t(\n              {\n                showHidden: c,\n                seen: [],\n                stylize: function (S) {\n                  return S;\n                },\n              },\n              x,\n              g === void 0 ? 2 : g\n            );\n          }\n          v.exports = e;\n          var o = function (x) {\n            return typeof HTMLElement == \"object\"\n              ? x instanceof HTMLElement\n              : x &&\n                  typeof x == \"object\" &&\n                  \"nodeType\" in x &&\n                  x.nodeType === 1 &&\n                  typeof x.nodeName == \"string\";\n          };\n          function t(x, c, g) {\n            if (\n              c &&\n              typeof c.inspect == \"function\" &&\n              c.inspect !== w.inspect &&\n              (!c.constructor || c.constructor.prototype !== c)\n            ) {\n              var N = c.inspect(g, x);\n              return typeof N != \"string\" && (N = t(x, N, g)), N;\n            }\n            var S = n(x, c);\n            if (S) return S;\n            if (o(c)) {\n              if (\"outerHTML\" in c) return c.outerHTML;\n              try {\n                if (document.xmlVersion)\n                  return new XMLSerializer().serializeToString(c);\n                var k = \"http://www.w3.org/1999/xhtml\",\n                  D = document.createElementNS(k, \"_\");\n                D.appendChild(c.cloneNode(!1));\n                var I = D.innerHTML.replace(\"><\", \">\" + c.innerHTML + \"<\");\n                return (D.innerHTML = \"\"), I;\n              } catch {}\n            }\n            var K,\n              G,\n              Z = r(c),\n              J = x.showHidden ? a(c) : Z;\n            if (\n              J.length === 0 ||\n              (U(c) &&\n                ((J.length === 1 && J[0] === \"stack\") ||\n                  (J.length === 2 &&\n                    J[0] === \"description\" &&\n                    J[1] === \"stack\")))\n            ) {\n              if (typeof c == \"function\")\n                return (\n                  (G = (K = d(c)) ? \": \" + K : \"\"),\n                  x.stylize(\"[Function\" + G + \"]\", \"special\")\n                );\n              if (_(c))\n                return x.stylize(RegExp.prototype.toString.call(c), \"regexp\");\n              if (H(c))\n                return x.stylize(Date.prototype.toUTCString.call(c), \"date\");\n              if (U(c)) return s(c);\n            }\n            var te,\n              X = \"\",\n              Y = !1,\n              oe = !1,\n              i = [\"{\", \"}\"];\n            if (\n              (C(c) && ((oe = !0), (i = [\"[\", \"]\"])),\n              B(c) && ((Y = !0), (i = [\"[\", \"]\"])),\n              typeof c == \"function\" &&\n                (X = \" [Function\" + (G = (K = d(c)) ? \": \" + K : \"\") + \"]\"),\n              _(c) && (X = \" \" + RegExp.prototype.toString.call(c)),\n              H(c) && (X = \" \" + Date.prototype.toUTCString.call(c)),\n              U(c))\n            )\n              return s(c);\n            if (J.length === 0 && (!Y || c.length == 0)) return i[0] + X + i[1];\n            if (g < 0)\n              return _(c)\n                ? x.stylize(RegExp.prototype.toString.call(c), \"regexp\")\n                : x.stylize(\"[Object]\", \"special\");\n            if ((x.seen.push(c), Y)) te = f(x, c, g, Z, J);\n            else {\n              if (oe) return b(c);\n              te = J.map(function (u) {\n                return E(x, c, g, Z, u, Y);\n              });\n            }\n            return x.seen.pop(), T(te, X, i);\n          }\n          function n(x, c) {\n            switch (typeof c) {\n              case \"undefined\":\n                return x.stylize(\"undefined\", \"undefined\");\n              case \"string\":\n                var g =\n                  \"'\" +\n                  JSON.stringify(c)\n                    .replace(/^\"|\"$/g, \"\")\n                    .replace(/'/g, \"\\\\'\")\n                    .replace(/\\\\\"/g, '\"') +\n                  \"'\";\n                return x.stylize(g, \"string\");\n              case \"number\":\n                return c === 0 && 1 / c == -1 / 0\n                  ? x.stylize(\"-0\", \"number\")\n                  : x.stylize(\"\" + c, \"number\");\n              case \"boolean\":\n                return x.stylize(\"\" + c, \"boolean\");\n              case \"symbol\":\n                return x.stylize(c.toString(), \"symbol\");\n              case \"bigint\":\n                return x.stylize(c.toString() + \"n\", \"bigint\");\n            }\n            if (c === null) return x.stylize(\"null\", \"null\");\n          }\n          function s(x) {\n            return \"[\" + Error.prototype.toString.call(x) + \"]\";\n          }\n          function f(x, c, g, N, S) {\n            for (var k = [], D = 0, I = c.length; D < I; ++D)\n              Object.prototype.hasOwnProperty.call(c, String(D))\n                ? k.push(E(x, c, g, N, String(D), !0))\n                : k.push(\"\");\n            return (\n              S.forEach(function (K) {\n                K.match(/^\\d+$/) || k.push(E(x, c, g, N, K, !0));\n              }),\n              k\n            );\n          }\n          function b(x) {\n            for (var c = \"[ \", g = 0; g < x.length; ++g) {\n              if (c.length >= h.truncateThreshold - 7) {\n                c += \"...\";\n                break;\n              }\n              c += x[g] + \", \";\n            }\n            return (\n              (c += \" ]\").indexOf(\",  ]\") !== -1 &&\n                (c = c.replace(\",  ]\", \" ]\")),\n              c\n            );\n          }\n          function E(x, c, g, N, S, k) {\n            var D,\n              I,\n              K = Object.getOwnPropertyDescriptor(c, S);\n            if (\n              (K &&\n                (K.get\n                  ? (I = K.set\n                      ? x.stylize(\"[Getter/Setter]\", \"special\")\n                      : x.stylize(\"[Getter]\", \"special\"))\n                  : K.set && (I = x.stylize(\"[Setter]\", \"special\"))),\n              N.indexOf(S) < 0 && (D = \"[\" + S + \"]\"),\n              I ||\n                (x.seen.indexOf(c[S]) < 0\n                  ? (I = t(x, c[S], g === null ? null : g - 1)).indexOf(`\n`) > -1 &&\n                    (I = k\n                      ? I.split(\n                          `\n`\n                        )\n                          .map(function (G) {\n                            return \"  \" + G;\n                          })\n                          .join(\n                            `\n`\n                          )\n                          .substr(2)\n                      : `\n` +\n                        I.split(\n                          `\n`\n                        ).map(function (G) {\n                          return \"   \" + G;\n                        }).join(`\n`))\n                  : (I = x.stylize(\"[Circular]\", \"special\"))),\n              D === void 0)\n            ) {\n              if (k && S.match(/^\\d+$/)) return I;\n              (D = JSON.stringify(\"\" + S)).match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)\n                ? ((D = D.substr(1, D.length - 2)), (D = x.stylize(D, \"name\")))\n                : ((D = D.replace(/'/g, \"\\\\'\")\n                    .replace(/\\\\\"/g, '\"')\n                    .replace(/(^\"|\"$)/g, \"'\")),\n                  (D = x.stylize(D, \"string\")));\n            }\n            return D + \": \" + I;\n          }\n          function T(x, c, g) {\n            return x.reduce(function (N, S) {\n              return N + S.length + 1;\n            }, 0) > 60\n              ? g[0] +\n                  (c === \"\"\n                    ? \"\"\n                    : c +\n                      `\n `) +\n                  \" \" +\n                  x.join(`,\n  `) +\n                  \" \" +\n                  g[1]\n              : g[0] + c + \" \" + x.join(\", \") + \" \" + g[1];\n          }\n          function C(x) {\n            return typeof x == \"object\" && /\\w+Array]$/.test(R(x));\n          }\n          function B(x) {\n            return (\n              Array.isArray(x) ||\n              (typeof x == \"object\" && R(x) === \"[object Array]\")\n            );\n          }\n          function _(x) {\n            return typeof x == \"object\" && R(x) === \"[object RegExp]\";\n          }\n          function H(x) {\n            return typeof x == \"object\" && R(x) === \"[object Date]\";\n          }\n          function U(x) {\n            return typeof x == \"object\" && R(x) === \"[object Error]\";\n          }\n          function R(x) {\n            return Object.prototype.toString.call(x);\n          }\n        },\n        {\n          \"../config\": 4,\n          \"./getEnumerableProperties\": 17,\n          \"./getProperties\": 22,\n          \"get-func-name\": 37,\n        },\n      ],\n      25: [\n        function (l, v, w) {\n          function d(a) {\n            return a != a;\n          }\n          v.exports = Number.isNaN || d;\n        },\n        {},\n      ],\n      26: [\n        function (l, v, w) {\n          var d = l(\"../config\");\n          v.exports = function () {\n            return d.useProxy && typeof Proxy < \"u\" && typeof Reflect < \"u\";\n          };\n        },\n        { \"../config\": 4 },\n      ],\n      27: [\n        function (l, v, w) {\n          var d = l(\"./inspect\"),\n            a = l(\"../config\");\n          v.exports = function (r) {\n            var h = d(r),\n              e = Object.prototype.toString.call(r);\n            if (a.truncateThreshold && h.length >= a.truncateThreshold) {\n              if (e === \"[object Function]\")\n                return r.name && r.name !== \"\"\n                  ? \"[Function: \" + r.name + \"]\"\n                  : \"[Function]\";\n              if (e === \"[object Array]\") return \"[ Array(\" + r.length + \") ]\";\n              if (e === \"[object Object]\") {\n                var o = Object.keys(r);\n                return (\n                  \"{ Object (\" +\n                  (o.length > 2\n                    ? o.splice(0, 2).join(\", \") + \", ...\"\n                    : o.join(\", \")) +\n                  \") }\"\n                );\n              }\n              return h;\n            }\n            return h;\n          };\n        },\n        { \"../config\": 4, \"./inspect\": 24 },\n      ],\n      28: [\n        function (l, v, w) {\n          var d = l(\"../../chai\"),\n            a = l(\"./transferFlags\");\n          v.exports = function (r, h, e, o) {\n            var t = r.__methods[h],\n              n = t.chainingBehavior;\n            t.chainingBehavior = function () {\n              var f = o(n).call(this);\n              if (f !== void 0) return f;\n              var b = new d.Assertion();\n              return a(this, b), b;\n            };\n            var s = t.method;\n            t.method = function () {\n              var f = e(s).apply(this, arguments);\n              if (f !== void 0) return f;\n              var b = new d.Assertion();\n              return a(this, b), b;\n            };\n          };\n        },\n        { \"../../chai\": 2, \"./transferFlags\": 33 },\n      ],\n      29: [\n        function (l, v, w) {\n          var d = l(\"./addLengthGuard\"),\n            a = l(\"../../chai\"),\n            r = l(\"./flag\"),\n            h = l(\"./proxify\"),\n            e = l(\"./transferFlags\");\n          v.exports = function (o, t, n) {\n            var s = o[t],\n              f = function () {\n                throw new Error(t + \" is not a function\");\n              };\n            s && typeof s == \"function\" && (f = s);\n            var b = function () {\n              r(this, \"lockSsfi\") || r(this, \"ssfi\", b);\n              var E = r(this, \"lockSsfi\");\n              r(this, \"lockSsfi\", !0);\n              var T = n(f).apply(this, arguments);\n              if ((r(this, \"lockSsfi\", E), T !== void 0)) return T;\n              var C = new a.Assertion();\n              return e(this, C), C;\n            };\n            d(b, t, !1), (o[t] = h(b, t));\n          };\n        },\n        {\n          \"../../chai\": 2,\n          \"./addLengthGuard\": 10,\n          \"./flag\": 15,\n          \"./proxify\": 31,\n          \"./transferFlags\": 33,\n        },\n      ],\n      30: [\n        function (l, v, w) {\n          var d = l(\"../../chai\"),\n            a = l(\"./flag\"),\n            r = l(\"./isProxyEnabled\"),\n            h = l(\"./transferFlags\");\n          v.exports = function (e, o, t) {\n            var n = Object.getOwnPropertyDescriptor(e, o),\n              s = function () {};\n            n && typeof n.get == \"function\" && (s = n.get),\n              Object.defineProperty(e, o, {\n                get: function f() {\n                  r() || a(this, \"lockSsfi\") || a(this, \"ssfi\", f);\n                  var b = a(this, \"lockSsfi\");\n                  a(this, \"lockSsfi\", !0);\n                  var E = t(s).call(this);\n                  if ((a(this, \"lockSsfi\", b), E !== void 0)) return E;\n                  var T = new d.Assertion();\n                  return h(this, T), T;\n                },\n                configurable: !0,\n              });\n          };\n        },\n        {\n          \"../../chai\": 2,\n          \"./flag\": 15,\n          \"./isProxyEnabled\": 26,\n          \"./transferFlags\": 33,\n        },\n      ],\n      31: [\n        function (l, v, w) {\n          var d = l(\"../config\"),\n            a = l(\"./flag\"),\n            r = l(\"./getProperties\"),\n            h = l(\"./isProxyEnabled\"),\n            e = [\"__flags\", \"__methods\", \"_obj\", \"assert\"];\n          function o(t, n, s) {\n            if (Math.abs(t.length - n.length) >= s) return s;\n            for (var f = [], b = 0; b <= t.length; b++)\n              (f[b] = Array(n.length + 1).fill(0)), (f[b][0] = b);\n            for (var E = 0; E < n.length; E++) f[0][E] = E;\n            for (b = 1; b <= t.length; b++) {\n              var T = t.charCodeAt(b - 1);\n              for (E = 1; E <= n.length; E++)\n                Math.abs(b - E) >= s\n                  ? (f[b][E] = s)\n                  : (f[b][E] = Math.min(\n                      f[b - 1][E] + 1,\n                      f[b][E - 1] + 1,\n                      f[b - 1][E - 1] + (T === n.charCodeAt(E - 1) ? 0 : 1)\n                    ));\n            }\n            return f[t.length][n.length];\n          }\n          v.exports = function (t, n) {\n            return h()\n              ? new Proxy(t, {\n                  get: function s(f, b) {\n                    if (\n                      typeof b == \"string\" &&\n                      d.proxyExcludedKeys.indexOf(b) === -1 &&\n                      !Reflect.has(f, b)\n                    ) {\n                      if (n)\n                        throw Error(\n                          \"Invalid Chai property: \" +\n                            n +\n                            \".\" +\n                            b +\n                            '. See docs for proper usage of \"' +\n                            n +\n                            '\".'\n                        );\n                      var E = null,\n                        T = 4;\n                      throw (\n                        (r(f).forEach(function (C) {\n                          if (\n                            !Object.prototype.hasOwnProperty(C) &&\n                            e.indexOf(C) === -1\n                          ) {\n                            var B = o(b, C, T);\n                            B < T && ((E = C), (T = B));\n                          }\n                        }),\n                        Error(\n                          E !== null\n                            ? \"Invalid Chai property: \" +\n                                b +\n                                '. Did you mean \"' +\n                                E +\n                                '\"?'\n                            : \"Invalid Chai property: \" + b\n                        ))\n                      );\n                    }\n                    return (\n                      e.indexOf(b) !== -1 ||\n                        a(f, \"lockSsfi\") ||\n                        a(f, \"ssfi\", s),\n                      Reflect.get(f, b)\n                    );\n                  },\n                })\n              : t;\n          };\n        },\n        {\n          \"../config\": 4,\n          \"./flag\": 15,\n          \"./getProperties\": 22,\n          \"./isProxyEnabled\": 26,\n        },\n      ],\n      32: [\n        function (l, v, w) {\n          var d = l(\"./flag\");\n          v.exports = function (a, r) {\n            var h = d(a, \"negate\"),\n              e = r[0];\n            return h ? !e : e;\n          };\n        },\n        { \"./flag\": 15 },\n      ],\n      33: [\n        function (l, v, w) {\n          v.exports = function (d, a, r) {\n            var h = d.__flags || (d.__flags = Object.create(null));\n            for (var e in (a.__flags || (a.__flags = Object.create(null)),\n            (r = arguments.length !== 3 || r),\n            h))\n              (r ||\n                (e !== \"object\" &&\n                  e !== \"ssfi\" &&\n                  e !== \"lockSsfi\" &&\n                  e != \"message\")) &&\n                (a.__flags[e] = h[e]);\n          };\n        },\n        {},\n      ],\n      34: [\n        function (l, v, w) {\n          function d() {\n            var r = [].slice.call(arguments);\n            function h(e, o) {\n              Object.keys(o).forEach(function (t) {\n                ~r.indexOf(t) || (e[t] = o[t]);\n              });\n            }\n            return function () {\n              for (\n                var e = [].slice.call(arguments), o = 0, t = {};\n                o < e.length;\n                o++\n              )\n                h(t, e[o]);\n              return t;\n            };\n          }\n          function a(r, h, e) {\n            var o = d(\n              \"name\",\n              \"message\",\n              \"stack\",\n              \"constructor\",\n              \"toJSON\"\n            )(h || {});\n            for (var t in ((this.message = r || \"Unspecified AssertionError\"),\n            (this.showDiff = !1),\n            o))\n              this[t] = o[t];\n            if (((e = e || a), Error.captureStackTrace))\n              Error.captureStackTrace(this, e);\n            else\n              try {\n                throw new Error();\n              } catch (n) {\n                this.stack = n.stack;\n              }\n          }\n          (v.exports = a),\n            (a.prototype = Object.create(Error.prototype)),\n            (a.prototype.name = \"AssertionError\"),\n            (a.prototype.constructor = a),\n            (a.prototype.toJSON = function (r) {\n              var h = d(\n                \"constructor\",\n                \"toJSON\",\n                \"stack\"\n              )({ name: this.name }, this);\n              return r !== !1 && this.stack && (h.stack = this.stack), h;\n            });\n        },\n        {},\n      ],\n      35: [\n        function (l, v, w) {\n          function d(n, s) {\n            return s instanceof Error && n === s;\n          }\n          function a(n, s) {\n            return s instanceof Error\n              ? n.constructor === s.constructor || n instanceof s.constructor\n              : (s.prototype instanceof Error || s === Error) &&\n                  (n.constructor === s || n instanceof s);\n          }\n          function r(n, s) {\n            var f = typeof n == \"string\" ? n : n.message;\n            return s instanceof RegExp\n              ? s.test(f)\n              : typeof s == \"string\" && f.indexOf(s) !== -1;\n          }\n          var h = /\\s*function(?:\\s|\\s*\\/\\*[^(?:*\\/)]+\\*\\/\\s*)*([^\\(\\/]+)/;\n          function e(n) {\n            var s = \"\";\n            if (n.name === void 0) {\n              var f = String(n).match(h);\n              f && (s = f[1]);\n            } else s = n.name;\n            return s;\n          }\n          function o(n) {\n            var s = n;\n            return (\n              n instanceof Error\n                ? (s = e(n.constructor))\n                : typeof n == \"function\" && (s = e(n).trim() || e(new n())),\n              s\n            );\n          }\n          function t(n) {\n            var s = \"\";\n            return (\n              n && n.message\n                ? (s = n.message)\n                : typeof n == \"string\" && (s = n),\n              s\n            );\n          }\n          v.exports = {\n            compatibleInstance: d,\n            compatibleConstructor: a,\n            compatibleMessage: r,\n            getMessage: t,\n            getConstructorName: o,\n          };\n        },\n        {},\n      ],\n      36: [\n        function (l, v, w) {\n          var d = l(\"type-detect\");\n          function a() {\n            this._key = \"chai/deep-eql__\" + Math.random() + Date.now();\n          }\n          a.prototype = {\n            get: function (c) {\n              return c[this._key];\n            },\n            set: function (c, g) {\n              Object.isExtensible(c) &&\n                Object.defineProperty(c, this._key, {\n                  value: g,\n                  configurable: !0,\n                });\n            },\n          };\n          var r = typeof WeakMap == \"function\" ? WeakMap : a;\n          function h(c, g, N) {\n            if (!N || x(c) || x(g)) return null;\n            var S = N.get(c);\n            if (S) {\n              var k = S.get(g);\n              if (typeof k == \"boolean\") return k;\n            }\n            return null;\n          }\n          function e(c, g, N, S) {\n            if (N && !x(c) && !x(g)) {\n              var k = N.get(c);\n              k ? k.set(g, S) : ((k = new r()).set(g, S), N.set(c, k));\n            }\n          }\n          function o(c, g, N) {\n            if (N && N.comparator) return n(c, g, N);\n            var S = t(c, g);\n            return S !== null ? S : n(c, g, N);\n          }\n          function t(c, g) {\n            return c === g\n              ? c !== 0 || 1 / c == 1 / g\n              : (c != c && g != g) || (!x(c) && !x(g) && null);\n          }\n          function n(c, g, N) {\n            (N = N || {}).memoize = N.memoize !== !1 && (N.memoize || new r());\n            var S = N && N.comparator,\n              k = h(c, g, N.memoize);\n            if (k !== null) return k;\n            var D = h(g, c, N.memoize);\n            if (D !== null) return D;\n            if (S) {\n              var I = S(c, g);\n              if (I === !1 || I === !0) return e(c, g, N.memoize, I), I;\n              var K = t(c, g);\n              if (K !== null) return K;\n            }\n            var G = d(c);\n            if (G !== d(g)) return e(c, g, N.memoize, !1), !1;\n            e(c, g, N.memoize, !0);\n            var Z = s(c, g, G, N);\n            return e(c, g, N.memoize, Z), Z;\n          }\n          function s(c, g, N, S) {\n            switch (N) {\n              case \"String\":\n              case \"Number\":\n              case \"Boolean\":\n              case \"Date\":\n                return o(c.valueOf(), g.valueOf());\n              case \"Promise\":\n              case \"Symbol\":\n              case \"function\":\n              case \"WeakMap\":\n              case \"WeakSet\":\n              case \"Error\":\n                return c === g;\n              case \"Arguments\":\n              case \"Int8Array\":\n              case \"Uint8Array\":\n              case \"Uint8ClampedArray\":\n              case \"Int16Array\":\n              case \"Uint16Array\":\n              case \"Int32Array\":\n              case \"Uint32Array\":\n              case \"Float32Array\":\n              case \"Float64Array\":\n              case \"Array\":\n                return E(c, g, S);\n              case \"RegExp\":\n                return f(c, g);\n              case \"Generator\":\n                return T(c, g, S);\n              case \"DataView\":\n                return E(new Uint8Array(c.buffer), new Uint8Array(g.buffer), S);\n              case \"ArrayBuffer\":\n                return E(new Uint8Array(c), new Uint8Array(g), S);\n              case \"Set\":\n              case \"Map\":\n                return b(c, g, S);\n              default:\n                return R(c, g, S);\n            }\n          }\n          function f(c, g) {\n            return c.toString() === g.toString();\n          }\n          function b(c, g, N) {\n            if (c.size !== g.size) return !1;\n            if (c.size === 0) return !0;\n            var S = [],\n              k = [];\n            return (\n              c.forEach(function (D, I) {\n                S.push([D, I]);\n              }),\n              g.forEach(function (D, I) {\n                k.push([D, I]);\n              }),\n              E(S.sort(), k.sort(), N)\n            );\n          }\n          function E(c, g, N) {\n            var S = c.length;\n            if (S !== g.length) return !1;\n            if (S === 0) return !0;\n            for (var k = -1; ++k < S; ) if (o(c[k], g[k], N) === !1) return !1;\n            return !0;\n          }\n          function T(c, g, N) {\n            return E(_(c), _(g), N);\n          }\n          function C(c) {\n            return (\n              typeof Symbol < \"u\" &&\n              typeof c == \"object\" &&\n              Symbol.iterator !== void 0 &&\n              typeof c[Symbol.iterator] == \"function\"\n            );\n          }\n          function B(c) {\n            if (C(c))\n              try {\n                return _(c[Symbol.iterator]());\n              } catch {\n                return [];\n              }\n            return [];\n          }\n          function _(c) {\n            for (var g = c.next(), N = [g.value]; g.done === !1; )\n              (g = c.next()), N.push(g.value);\n            return N;\n          }\n          function H(c) {\n            var g = [];\n            for (var N in c) g.push(N);\n            return g;\n          }\n          function U(c, g, N, S) {\n            var k = N.length;\n            if (k === 0) return !0;\n            for (var D = 0; D < k; D += 1)\n              if (o(c[N[D]], g[N[D]], S) === !1) return !1;\n            return !0;\n          }\n          function R(c, g, N) {\n            var S = H(c),\n              k = H(g);\n            if (S.length && S.length === k.length)\n              return S.sort(), k.sort(), E(S, k) !== !1 && U(c, g, S, N);\n            var D = B(c),\n              I = B(g);\n            return D.length && D.length === I.length\n              ? (D.sort(), I.sort(), E(D, I, N))\n              : S.length === 0 &&\n                  D.length === 0 &&\n                  k.length === 0 &&\n                  I.length === 0;\n          }\n          function x(c) {\n            return c === null || typeof c != \"object\";\n          }\n          (v.exports = o), (v.exports.MemoizeMap = r);\n        },\n        { \"type-detect\": 39 },\n      ],\n      37: [\n        function (l, v, w) {\n          var d = Function.prototype.toString,\n            a = /\\s*function(?:\\s|\\s*\\/\\*[^(?:*\\/)]+\\*\\/\\s*)*([^\\s\\(\\/]+)/;\n          function r(h) {\n            if (typeof h != \"function\") return null;\n            var e = \"\";\n            if (Function.prototype.name === void 0 && h.name === void 0) {\n              var o = d.call(h).match(a);\n              o && (e = o[1]);\n            } else e = h.name;\n            return e;\n          }\n          v.exports = r;\n        },\n        {},\n      ],\n      38: [\n        function (l, v, w) {\n          function d(n, s) {\n            return n != null && s in Object(n);\n          }\n          function a(n) {\n            return n\n              .replace(/([^\\\\])\\[/g, \"$1.[\")\n              .match(/(\\\\\\.|[^.]+?)+/g)\n              .map(function (s) {\n                if (\n                  s === \"constructor\" ||\n                  s === \"__proto__\" ||\n                  s === \"prototype\"\n                )\n                  return {};\n                var f = /^\\[(\\d+)\\]$/.exec(s);\n                return f\n                  ? { i: parseFloat(f[1]) }\n                  : { p: s.replace(/\\\\([.[\\]])/g, \"$1\") };\n              });\n          }\n          function r(n, s, f) {\n            var b = n,\n              E = null;\n            f = f === void 0 ? s.length : f;\n            for (var T = 0; T < f; T++) {\n              var C = s[T];\n              b &&\n                ((b = C.p === void 0 ? b[C.i] : b[C.p]),\n                T === f - 1 && (E = b));\n            }\n            return E;\n          }\n          function h(n, s, f) {\n            for (var b = n, E = f.length, T = null, C = 0; C < E; C++) {\n              var B = null,\n                _ = null;\n              if (((T = f[C]), C === E - 1))\n                b[(B = T.p === void 0 ? T.i : T.p)] = s;\n              else if (T.p !== void 0 && b[T.p]) b = b[T.p];\n              else if (T.i !== void 0 && b[T.i]) b = b[T.i];\n              else {\n                var H = f[C + 1];\n                (B = T.p === void 0 ? T.i : T.p),\n                  (_ = H.p === void 0 ? [] : {}),\n                  (b[B] = _),\n                  (b = b[B]);\n              }\n            }\n          }\n          function e(n, s) {\n            var f = a(s),\n              b = f[f.length - 1],\n              E = {\n                parent: f.length > 1 ? r(n, f, f.length - 1) : n,\n                name: b.p || b.i,\n                value: r(n, f),\n              };\n            return (E.exists = d(E.parent, E.name)), E;\n          }\n          function o(n, s) {\n            return e(n, s).value;\n          }\n          function t(n, s, f) {\n            return h(n, f, a(s)), n;\n          }\n          v.exports = {\n            hasProperty: d,\n            getPathInfo: e,\n            getPathValue: o,\n            setPathValue: t,\n          };\n        },\n        {},\n      ],\n      39: [\n        function (l, v, w) {\n          (function (d, a) {\n            typeof w == \"object\" && v !== void 0\n              ? (v.exports = a())\n              : (d.typeDetect = a());\n          })(this, function () {\n            var d = typeof Promise == \"function\",\n              a = typeof self == \"object\" ? self : se,\n              r = typeof Symbol < \"u\",\n              h = typeof Map < \"u\",\n              e = typeof Set < \"u\",\n              o = typeof WeakMap < \"u\",\n              t = typeof WeakSet < \"u\",\n              n = typeof DataView < \"u\",\n              s = r && Symbol.iterator !== void 0,\n              f = r && Symbol.toStringTag !== void 0,\n              b = e && typeof Set.prototype.entries == \"function\",\n              E = h && typeof Map.prototype.entries == \"function\",\n              T = b && Object.getPrototypeOf(new Set().entries()),\n              C = E && Object.getPrototypeOf(new Map().entries()),\n              B = s && typeof Array.prototype[Symbol.iterator] == \"function\",\n              _ = B && Object.getPrototypeOf([][Symbol.iterator]()),\n              H = s && typeof String.prototype[Symbol.iterator] == \"function\",\n              U = H && Object.getPrototypeOf(\"\"[Symbol.iterator]()),\n              R = 8,\n              x = -1;\n            function c(g) {\n              var N = typeof g;\n              if (N !== \"object\") return N;\n              if (g === null) return \"null\";\n              if (g === a) return \"global\";\n              if (Array.isArray(g) && (f === !1 || !(Symbol.toStringTag in g)))\n                return \"Array\";\n              if (typeof window == \"object\" && window !== null) {\n                if (typeof window.location == \"object\" && g === window.location)\n                  return \"Location\";\n                if (typeof window.document == \"object\" && g === window.document)\n                  return \"Document\";\n                if (typeof window.navigator == \"object\") {\n                  if (\n                    typeof window.navigator.mimeTypes == \"object\" &&\n                    g === window.navigator.mimeTypes\n                  )\n                    return \"MimeTypeArray\";\n                  if (\n                    typeof window.navigator.plugins == \"object\" &&\n                    g === window.navigator.plugins\n                  )\n                    return \"PluginArray\";\n                }\n                if (\n                  (typeof window.HTMLElement == \"function\" ||\n                    typeof window.HTMLElement == \"object\") &&\n                  g instanceof window.HTMLElement\n                ) {\n                  if (g.tagName === \"BLOCKQUOTE\") return \"HTMLQuoteElement\";\n                  if (g.tagName === \"TD\") return \"HTMLTableDataCellElement\";\n                  if (g.tagName === \"TH\") return \"HTMLTableHeaderCellElement\";\n                }\n              }\n              var S = f && g[Symbol.toStringTag];\n              if (typeof S == \"string\") return S;\n              var k = Object.getPrototypeOf(g);\n              return k === RegExp.prototype\n                ? \"RegExp\"\n                : k === Date.prototype\n                  ? \"Date\"\n                  : d && k === Promise.prototype\n                    ? \"Promise\"\n                    : e && k === Set.prototype\n                      ? \"Set\"\n                      : h && k === Map.prototype\n                        ? \"Map\"\n                        : t && k === WeakSet.prototype\n                          ? \"WeakSet\"\n                          : o && k === WeakMap.prototype\n                            ? \"WeakMap\"\n                            : n && k === DataView.prototype\n                              ? \"DataView\"\n                              : h && k === C\n                                ? \"Map Iterator\"\n                                : e && k === T\n                                  ? \"Set Iterator\"\n                                  : B && k === _\n                                    ? \"Array Iterator\"\n                                    : H && k === U\n                                      ? \"String Iterator\"\n                                      : k === null\n                                        ? \"Object\"\n                                        : Object.prototype.toString\n                                            .call(g)\n                                            .slice(R, x);\n            }\n            return c;\n          });\n        },\n        {},\n      ],\n    },\n    {},\n    [1]\n  )(1)),\n  ae = Q.version,\n  ce = Q.AssertionError,\n  ue = Q.use,\n  fe = Q.util,\n  pe = Q.config,\n  le = Q.Assertion,\n  he = Q.expect,\n  de = Q.should,\n  ge = Q.Should,\n  ye = Q.assert;\nexport {\n  le as Assertion,\n  ce as AssertionError,\n  ge as Should,\n  ye as assert,\n  pe as config,\n  Q as default,\n  he as expect,\n  de as should,\n  ue as use,\n  fe as util,\n  ae as version,\n};\n/*! Bundled license information:\n\n@esm-bundle/chai/esm/chai.js:\n  (*!\n   * chai\n   * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n   * MIT Licensed\n   *)\n  (*!\n   * Chai version\n   *)\n  (*!\n   * Utils for plugins (not exported)\n   *)\n  (*!\n   * Configuration\n   *)\n  (*!\n   * Primary `Assertion` prototype\n   *)\n  (*!\n   * Core Assertions\n   *)\n  (*!\n   * Expect interface\n   *)\n  (*!\n   * Should interface\n   *)\n  (*!\n   * Assert interface\n   *)\n  (*!\n   * chai\n   * http://chaijs.com\n   * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n   * MIT Licensed\n   *)\n  (*!\n     * Module dependencies.\n     *)\n  (*!\n     * Module export.\n     *)\n  (*!\n     * Assertion Constructor\n     *\n     * Creates object for chaining.\n     *\n     * `Assertion` objects contain metadata in the form of flags. Three flags can\n     * be assigned during instantiation by passing arguments to this constructor:\n     *\n     * - `object`: This flag contains the target of the assertion. For example, in\n     *   the assertion `expect(numKittens).to.equal(7);`, the `object` flag will\n     *   contain `numKittens` so that the `equal` assertion can reference it when\n     *   needed.\n     *\n     * - `message`: This flag contains an optional custom error message to be\n     *   prepended to the error message that's generated by the assertion when it\n     *   fails.\n     *\n     * - `ssfi`: This flag stands for \"start stack function indicator\". It\n     *   contains a function reference that serves as the starting point for\n     *   removing frames from the stack trace of the error that's created by the\n     *   assertion when it fails. The goal is to provide a cleaner stack trace to\n     *   end users by removing Chai's internal functions. Note that it only works\n     *   in environments that support `Error.captureStackTrace`, and only when\n     *   `Chai.config.includeStack` hasn't been set to `false`.\n     *\n     * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag\n     *   should retain its current value, even as assertions are chained off of\n     *   this object. This is usually set to `true` when creating a new assertion\n     *   from within another assertion. It's also temporarily set to `true` before\n     *   an overwritten assertion gets called by the overwriting assertion.\n     *\n     * @param {Mixed} obj target of the assertion\n     * @param {String} msg (optional) custom error message\n     * @param {Function} ssfi (optional) starting point for removing stack frames\n     * @param {Boolean} lockSsfi (optional) whether or not the ssfi flag is locked\n     * @api private\n     *)\n  (*!\n     * Chai dependencies.\n     *)\n  (*!\n   * Chai - addChainingMethod utility\n   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n   * MIT Licensed\n   *)\n  (*!\n   * Module dependencies\n   *)\n  (*!\n   * Chai - addLengthGuard utility\n   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n   * MIT Licensed\n   *)\n  (*!\n   * Chai - addMethod utility\n   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n   * MIT Licensed\n   *)\n  (*!\n   * Chai - addProperty utility\n   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n   * MIT Licensed\n   *)\n  (*!\n   * Chai - compareByInspect utility\n   * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>\n   * MIT Licensed\n   *)\n  (*!\n   * Chai - expectTypes utility\n   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n   * MIT Licensed\n   *)\n  (*!\n   * Chai - flag utility\n   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n   * MIT Licensed\n   *)\n  (*!\n   * Chai - getActual utility\n   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n   * MIT Licensed\n   *)\n  (*!\n   * Chai - getEnumerableProperties utility\n   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n   * MIT Licensed\n   *)\n  (*!\n   * Chai - message composition utility\n   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n   * MIT Licensed\n   *)\n  (*!\n   * Chai - getOwnEnumerableProperties utility\n   * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>\n   * MIT Licensed\n   *)\n  (*!\n   * Chai - getOwnEnumerablePropertySymbols utility\n   * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>\n   * MIT Licensed\n   *)\n  (*!\n   * Chai - getProperties utility\n   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n   * MIT Licensed\n   *)\n  (*!\n   * chai\n   * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>\n   * MIT Licensed\n   *)\n  (*!\n   * Dependencies that are used for multiple exports are required here only once\n   *)\n  (*!\n   * test utility\n   *)\n  (*!\n   * Chai - isNaN utility\n   * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>\n   * MIT Licensed\n   *)\n  (*!\n   * Chai - isProxyEnabled helper\n   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n   * MIT Licensed\n   *)\n  (*!\n   * Chai - overwriteChainableMethod utility\n   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n   * MIT Licensed\n   *)\n  (*!\n   * Chai - overwriteMethod utility\n   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n   * MIT Licensed\n   *)\n  (*!\n   * Chai - overwriteProperty utility\n   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n   * MIT Licensed\n   *)\n  (*!\n   * Chai - test utility\n   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n   * MIT Licensed\n   *)\n  (*!\n   * Chai - transferFlags utility\n   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n   * MIT Licensed\n   *)\n  (*!\n   * assertion-error\n   * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>\n   * MIT Licensed\n   *)\n  (*!\n   * Return a function that will copy properties from\n   * one object to another excluding any originally\n   * listed. Returned function will create a new `{}`.\n   *\n   * @param {String} excluded properties ...\n   * @return {Function}\n   *)\n  (*!\n   * Primary Exports\n   *)\n  (*!\n   * Inherit from Error.prototype\n   *)\n  (*!\n   * deep-eql\n   * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>\n   * MIT Licensed\n   *)\n  (*!\n   * Check to see if the MemoizeMap has recorded a result of the two operands\n   *\n   * @param {Mixed} leftHandOperand\n   * @param {Mixed} rightHandOperand\n   * @param {MemoizeMap} memoizeMap\n   * @returns {Boolean|null} result\n  *)\n  (*!\n   * Set the result of the equality into the MemoizeMap\n   *\n   * @param {Mixed} leftHandOperand\n   * @param {Mixed} rightHandOperand\n   * @param {MemoizeMap} memoizeMap\n   * @param {Boolean} result\n  *)\n  (*!\n   * Primary Export\n   *)\n  (*!\n   * The main logic of the `deepEqual` function.\n   *\n   * @param {Mixed} leftHandOperand\n   * @param {Mixed} rightHandOperand\n   * @param {Object} [options] (optional) Additional options\n   * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.\n   * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of\n      complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular\n      references to blow the stack.\n   * @return {Boolean} equal match\n  *)\n  (*!\n   * Compare two Regular Expressions for equality.\n   *\n   * @param {RegExp} leftHandOperand\n   * @param {RegExp} rightHandOperand\n   * @return {Boolean} result\n   *)\n  (*!\n   * Compare two Sets/Maps for equality. Faster than other equality functions.\n   *\n   * @param {Set} leftHandOperand\n   * @param {Set} rightHandOperand\n   * @param {Object} [options] (Optional)\n   * @return {Boolean} result\n   *)\n  (*!\n   * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.\n   *\n   * @param {Iterable} leftHandOperand\n   * @param {Iterable} rightHandOperand\n   * @param {Object} [options] (Optional)\n   * @return {Boolean} result\n   *)\n  (*!\n   * Simple equality for generator objects such as those returned by generator functions.\n   *\n   * @param {Iterable} leftHandOperand\n   * @param {Iterable} rightHandOperand\n   * @param {Object} [options] (Optional)\n   * @return {Boolean} result\n   *)\n  (*!\n   * Determine if the given object has an @@iterator function.\n   *\n   * @param {Object} target\n   * @return {Boolean} `true` if the object has an @@iterator function.\n   *)\n  (*!\n   * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.\n   * This will consume the iterator - which could have side effects depending on the @@iterator implementation.\n   *\n   * @param {Object} target\n   * @returns {Array} an array of entries from the @@iterator function\n   *)\n  (*!\n   * Gets all entries from a Generator. This will consume the generator - which could have side effects.\n   *\n   * @param {Generator} target\n   * @returns {Array} an array of entries from the Generator.\n   *)\n  (*!\n   * Gets all own and inherited enumerable keys from a target.\n   *\n   * @param {Object} target\n   * @returns {Array} an array of own and inherited enumerable keys from the target.\n   *)\n  (*!\n   * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of\n   * each key. If any value of the given key is not equal, the function will return false (early).\n   *\n   * @param {Mixed} leftHandOperand\n   * @param {Mixed} rightHandOperand\n   * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against\n   * @param {Object} [options] (Optional)\n   * @return {Boolean} result\n   *)\n  (*!\n   * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`\n   * for each enumerable key in the object.\n   *\n   * @param {Mixed} leftHandOperand\n   * @param {Mixed} rightHandOperand\n   * @param {Object} [options] (Optional)\n   * @return {Boolean} result\n   *)\n  (*!\n   * Returns true if the argument is a primitive.\n   *\n   * This intentionally returns true for all objects that can be compared by reference,\n   * including functions and symbols.\n   *\n   * @param {Mixed} value\n   * @return {Boolean} result\n   *)\n*/\n//# sourceMappingURL=chai.bundle.mjs.map\n",
      "metadata": {
        "title": "chai-bundle",
        "description": "",
        "runnable": false
      }
    },
    "chai": {
      "code": "import * as c from \"./chai-bundle\";\nconst chai = c;\nconst { expect, should, use, util, assert, config, version, Assertion, AssertionError, } = chai;\nexport { expect, should, use, util, assert, config, version, Assertion, AssertionError, };\n",
      "metadata": {
        "title": "chai",
        "source": {
          "code": "import * as c from \"./chai-bundle\";\n\nconst chai = c as Chai.ChaiStatic;\nconst {\n  expect,\n  should,\n  use,\n  util,\n  assert,\n  config,\n  version,\n  Assertion,\n  AssertionError,\n} = chai;\n\nexport {\n  expect,\n  should,\n  use,\n  util,\n  assert,\n  config,\n  version,\n  Assertion,\n  AssertionError,\n};\n\ndeclare namespace Chai {\n  type Message = string | (() => string);\n  type ObjectProperty = string | symbol | number;\n\n  interface PathInfo {\n    parent: object;\n    name: string;\n    value?: any;\n    exists: boolean;\n  }\n\n  interface Constructor<T> {\n    new (...args: any[]): T;\n  }\n\n  interface ErrorConstructor {\n    new (...args: any[]): Error;\n  }\n\n  interface ChaiUtils {\n    addChainableMethod(\n      // object to define the method on, e.g. chai.Assertion.prototype\n      ctx: object,\n      // method name\n      name: string,\n      // method itself; any arguments\n      method: (...args: any[]) => void,\n      // called when property is accessed\n      chainingBehavior?: () => void\n    ): void;\n    overwriteChainableMethod(\n      ctx: object,\n      name: string,\n      method: (...args: any[]) => void,\n      chainingBehavior?: () => void\n    ): void;\n    addLengthGuard(\n      fn: Function,\n      assertionName: string,\n      isChainable: boolean\n    ): void;\n    addMethod(ctx: object, name: string, method: Function): void;\n    addProperty(ctx: object, name: string, getter: () => any): void;\n    overwriteMethod(ctx: object, name: string, method: Function): void;\n    overwriteProperty(\n      ctx: object,\n      name: string,\n      getter: (this: AssertionStatic, _super: any) => any\n    ): void;\n    compareByInspect(a: object, b: object): -1 | 1;\n    expectTypes(obj: object, types: string[]): void;\n    flag(obj: object, key: string, value?: any): any;\n    getActual(obj: object, args: AssertionArgs): any;\n    getProperties(obj: object): string[];\n    getEnumerableProperties(obj: object): string[];\n    getOwnEnumerablePropertySymbols(obj: object): symbol[];\n    getOwnEnumerableProperties(obj: object): Array<string | symbol>;\n    getMessage(errorLike: Error | string): string;\n    getMessage(obj: any, args: AssertionArgs): string;\n    inspect(\n      obj: any,\n      showHidden?: boolean,\n      depth?: number,\n      colors?: boolean\n    ): string;\n    isProxyEnabled(): boolean;\n    objDisplay(obj: object): void;\n    proxify(obj: object, nonChainableMethodName: string): object;\n    test(obj: object, args: AssertionArgs): boolean;\n    transferFlags(\n      assertion: Assertion,\n      obj: object,\n      includeAll?: boolean\n    ): void;\n    compatibleInstance(\n      thrown: Error,\n      errorLike: Error | ErrorConstructor\n    ): boolean;\n    compatibleConstructor(\n      thrown: Error,\n      errorLike: Error | ErrorConstructor\n    ): boolean;\n    compatibleMessage(thrown: Error, errMatcher: string | RegExp): boolean;\n    getConstructorName(constructorFn: Function): string;\n    getFuncName(constructorFn: Function): string | null;\n\n    // Reexports from pathval:\n    hasProperty(obj: object | undefined | null, name: ObjectProperty): boolean;\n    getPathInfo(obj: object, path: string): PathInfo;\n    getPathValue(obj: object, path: string): object | undefined;\n  }\n\n  type ChaiPlugin = (chai: ChaiStatic, utils: ChaiUtils) => void;\n\n  interface ChaiStatic {\n    expect: ExpectStatic;\n    should(): Should;\n    /**\n     * Provides a way to extend the internals of Chai\n     */\n    use(fn: ChaiPlugin): ChaiStatic;\n    util: ChaiUtils;\n    assert: AssertStatic;\n    config: Config;\n    Assertion: AssertionStatic;\n    AssertionError: typeof AssertionError;\n    version: string;\n  }\n\n  export interface ExpectStatic {\n    (val: any, message?: string): Assertion;\n    fail(message?: string): never;\n    fail(\n      actual: any,\n      expected: any,\n      message?: string,\n      operator?: Operator\n    ): never;\n  }\n\n  export interface AssertStatic extends Assert {}\n\n  // chai.Assertion.prototype.assert arguments\n  type AssertionArgs = [\n    // 'expression to be tested'\n    // This parameter is unused and the docs list its type as\n    // 'Philosophical', which is mentioned nowhere else in the source. Do\n    // with that what you will!\n    any,\n    Message, // message if value fails\n    Message, // message if negated value fails\n    any, // expected value\n    any?, // actual value\n    boolean?, // showDiff\n  ];\n\n  export interface AssertionPrototype {\n    assert(...args: AssertionArgs): void;\n    _obj: any;\n  }\n\n  export interface AssertionStatic extends AssertionPrototype {\n    prototype: AssertionPrototype;\n\n    new (\n      target: any,\n      message?: string,\n      ssfi?: Function,\n      lockSsfi?: boolean\n    ): Assertion;\n\n    // Deprecated properties:\n    includeStack: boolean;\n    showDiff: boolean;\n\n    // Partials of functions on ChaiUtils:\n    addProperty(name: string, getter: (this: AssertionStatic) => any): void;\n    addMethod(\n      name: string,\n      method: (this: AssertionStatic, ...args: any[]) => any\n    ): void;\n    addChainableMethod(\n      name: string,\n      method: (this: AssertionStatic, ...args: any[]) => void,\n      chainingBehavior?: () => void\n    ): void;\n    overwriteProperty(\n      name: string,\n      getter: (this: AssertionStatic, _super: any) => any\n    ): void;\n    overwriteMethod(\n      name: string,\n      method: (this: AssertionStatic, ...args: any[]) => any\n    ): void;\n    overwriteChainableMethod(\n      name: string,\n      method: (this: AssertionStatic, ...args: any[]) => void,\n      chainingBehavior?: () => void\n    ): void;\n  }\n\n  export type Operator = string; // \"==\" | \"===\" | \">\" | \">=\" | \"<\" | \"<=\" | \"!=\" | \"!==\";\n\n  export type OperatorComparable =\n    | boolean\n    | null\n    | number\n    | string\n    | undefined\n    | Date;\n\n  interface ShouldAssertion {\n    equal(value1: any, value2: any, message?: string): void;\n    Throw: ShouldThrow;\n    throw: ShouldThrow;\n    exist(value: any, message?: string): void;\n  }\n\n  interface Should extends ShouldAssertion {\n    not: ShouldAssertion;\n    fail(message?: string): never;\n    fail(\n      actual: any,\n      expected: any,\n      message?: string,\n      operator?: Operator\n    ): never;\n  }\n\n  interface ShouldThrow {\n    (actual: Function, expected?: string | RegExp, message?: string): void;\n    (\n      actual: Function,\n      constructor: Error | Function,\n      expected?: string | RegExp,\n      message?: string\n    ): void;\n  }\n\n  interface Assertion\n    extends LanguageChains,\n      NumericComparison,\n      TypeComparison {\n    not: Assertion;\n    deep: Deep;\n    ordered: Ordered;\n    nested: Nested;\n    own: Own;\n    any: KeyFilter;\n    all: KeyFilter;\n    a: Assertion;\n    an: Assertion;\n    include: Include;\n    includes: Include;\n    contain: Include;\n    contains: Include;\n    ok: Assertion;\n    true: Assertion;\n    false: Assertion;\n    null: Assertion;\n    undefined: Assertion;\n    NaN: Assertion;\n    exist: Assertion;\n    empty: Assertion;\n    arguments: Assertion;\n    Arguments: Assertion;\n    finite: Assertion;\n    equal: Equal;\n    equals: Equal;\n    eq: Equal;\n    eql: Equal;\n    eqls: Equal;\n    property: Property;\n    ownProperty: Property;\n    haveOwnProperty: Property;\n    ownPropertyDescriptor: OwnPropertyDescriptor;\n    haveOwnPropertyDescriptor: OwnPropertyDescriptor;\n    length: Length;\n    lengthOf: Length;\n    match: Match;\n    matches: Match;\n    string(string: string, message?: string): Assertion;\n    keys: Keys;\n    key(string: string): Assertion;\n    throw: Throw;\n    throws: Throw;\n    Throw: Throw;\n    respondTo: RespondTo;\n    respondsTo: RespondTo;\n    itself: Assertion;\n    satisfy: Satisfy;\n    satisfies: Satisfy;\n    closeTo: CloseTo;\n    approximately: CloseTo;\n    members: Members;\n    increase: PropertyChange;\n    increases: PropertyChange;\n    decrease: PropertyChange;\n    decreases: PropertyChange;\n    change: PropertyChange;\n    changes: PropertyChange;\n    extensible: Assertion;\n    sealed: Assertion;\n    frozen: Assertion;\n    oneOf: OneOf;\n  }\n\n  interface LanguageChains {\n    to: Assertion;\n    be: Assertion;\n    been: Assertion;\n    is: Assertion;\n    that: Assertion;\n    which: Assertion;\n    and: Assertion;\n    has: Assertion;\n    have: Assertion;\n    with: Assertion;\n    at: Assertion;\n    of: Assertion;\n    same: Assertion;\n    but: Assertion;\n    does: Assertion;\n  }\n\n  interface NumericComparison {\n    above: NumberComparer;\n    gt: NumberComparer;\n    greaterThan: NumberComparer;\n    least: NumberComparer;\n    gte: NumberComparer;\n    greaterThanOrEqual: NumberComparer;\n    below: NumberComparer;\n    lt: NumberComparer;\n    lessThan: NumberComparer;\n    most: NumberComparer;\n    lte: NumberComparer;\n    lessThanOrEqual: NumberComparer;\n    within(start: number, finish: number, message?: string): Assertion;\n    within(start: Date, finish: Date, message?: string): Assertion;\n  }\n\n  interface NumberComparer {\n    (value: number | Date, message?: string): Assertion;\n  }\n\n  interface TypeComparison {\n    (type: string, message?: string): Assertion;\n    instanceof: InstanceOf;\n    instanceOf: InstanceOf;\n  }\n\n  interface InstanceOf {\n    (constructor: any, message?: string): Assertion;\n  }\n\n  interface CloseTo {\n    (expected: number, delta: number, message?: string): Assertion;\n  }\n\n  interface Nested {\n    include: Include;\n    includes: Include;\n    contain: Include;\n    contains: Include;\n    property: Property;\n    members: Members;\n  }\n\n  interface Own {\n    include: Include;\n    includes: Include;\n    contain: Include;\n    contains: Include;\n    property: Property;\n  }\n\n  interface Deep extends KeyFilter {\n    be: Assertion;\n    equal: Equal;\n    equals: Equal;\n    eq: Equal;\n    include: Include;\n    includes: Include;\n    contain: Include;\n    contains: Include;\n    property: Property;\n    ordered: Ordered;\n    nested: Nested;\n    oneOf: OneOf;\n    own: Own;\n  }\n\n  interface Ordered {\n    members: Members;\n  }\n\n  interface KeyFilter {\n    keys: Keys;\n    members: Members;\n  }\n\n  interface Equal {\n    (value: any, message?: string): Assertion;\n  }\n\n  interface Property {\n    (name: string | symbol, value: any, message?: string): Assertion;\n    (name: string | symbol, message?: string): Assertion;\n  }\n\n  interface OwnPropertyDescriptor {\n    (\n      name: string | symbol,\n      descriptor: PropertyDescriptor,\n      message?: string\n    ): Assertion;\n    (name: string | symbol, message?: string): Assertion;\n  }\n\n  interface Length extends LanguageChains, NumericComparison {\n    (length: number, message?: string): Assertion;\n  }\n\n  interface Include {\n    (value: any, message?: string): Assertion;\n    keys: Keys;\n    deep: Deep;\n    ordered: Ordered;\n    members: Members;\n    any: KeyFilter;\n    all: KeyFilter;\n    oneOf: OneOf;\n  }\n\n  interface OneOf {\n    (list: readonly unknown[], message?: string): Assertion;\n  }\n\n  interface Match {\n    (regexp: RegExp, message?: string): Assertion;\n  }\n\n  interface Keys {\n    (...keys: string[]): Assertion;\n    (keys: readonly any[] | Object): Assertion;\n  }\n\n  interface Throw {\n    (expected?: string | RegExp, message?: string): Assertion;\n    (\n      constructor: Error | Function,\n      expected?: string | RegExp,\n      message?: string\n    ): Assertion;\n  }\n\n  interface RespondTo {\n    (method: string, message?: string): Assertion;\n  }\n\n  interface Satisfy {\n    (matcher: Function, message?: string): Assertion;\n  }\n\n  interface Members {\n    (set: readonly any[], message?: string): Assertion;\n  }\n\n  interface PropertyChange {\n    (object: Object, property?: string, message?: string): DeltaAssertion;\n  }\n\n  interface DeltaAssertion extends Assertion {\n    by(delta: number, msg?: string): Assertion;\n  }\n\n  export interface Assert {\n    /**\n     * @param expression    Expression to test for truthiness.\n     * @param message    Message to display on error.\n     */\n    (expression: any, message?: string): asserts expression;\n\n    /**\n     * Throws a failure.\n     *\n     * @param message    Message to display on error.\n     * @remarks Node.js assert module-compatible.\n     */\n    fail(message?: string): never;\n\n    /**\n     * Throws a failure.\n     *\n     * T   Type of the objects.\n     * @param actual   Actual value.\n     * @param expected   Potential expected value.\n     * @param message    Message to display on error.\n     * @param operator   Comparison operator, if not strict equality.\n     * @remarks Node.js assert module-compatible.\n     */\n    fail<T>(\n      actual: T,\n      expected: T,\n      message?: string,\n      operator?: Operator\n    ): never;\n\n    /**\n     * Asserts that object is truthy.\n     *\n     * @param object   Object to test.\n     * @param message    Message to display on error.\n     */\n    isOk(value: unknown, message?: string): asserts value;\n\n    /**\n     * Asserts that object is truthy.\n     *\n     * @param object   Object to test.\n     * @param message    Message to display on error.\n     */\n    ok(value: unknown, message?: string): asserts value;\n\n    /**\n     * Asserts that object is falsy.\n     *\n     * T   Type of object.\n     * @param object   Object to test.\n     * @param message    Message to display on error.\n     */\n    isNotOk<T>(value: T, message?: string): void;\n\n    /**\n     * Asserts that object is falsy.\n     *\n     * T   Type of object.\n     * @param object   Object to test.\n     * @param message    Message to display on error.\n     */\n    notOk<T>(value: T, message?: string): void;\n\n    /**\n     * Asserts non-strict equality (==) of actual and expected.\n     *\n     * T   Type of the objects.\n     * @param actual   Actual value.\n     * @param expected   Potential expected value.\n     * @param message   Message to display on error.\n     */\n    equal<T>(actual: T, expected: T, message?: string): void;\n\n    /**\n     * Asserts non-strict inequality (!=) of actual and expected.\n     *\n     * T   Type of the objects.\n     * @param actual   Actual value.\n     * @param expected   Potential expected value.\n     * @param message   Message to display on error.\n     */\n    notEqual<T>(actual: T, expected: T, message?: string): void;\n\n    /**\n     * Asserts strict equality (===) of actual and expected.\n     *\n     * T   Type of the objects.\n     * @param actual   Actual value.\n     * @param expected   Potential expected value.\n     * @param message   Message to display on error.\n     */\n    strictEqual<T>(actual: T, expected: T, message?: string): void;\n\n    /**\n     * Asserts strict inequality (!==) of actual and expected.\n     *\n     * T   Type of the objects.\n     * @param actual   Actual value.\n     * @param expected   Potential expected value.\n     * @param message   Message to display on error.\n     */\n    notStrictEqual<T>(actual: T, expected: T, message?: string): void;\n\n    /**\n     * Asserts that actual is deeply equal to expected.\n     *\n     * T   Type of the objects.\n     * @param actual   Actual value.\n     * @param expected   Potential expected value.\n     * @param message   Message to display on error.\n     */\n    deepEqual<T>(actual: T, expected: T, message?: string): void;\n\n    /**\n     * Asserts that actual is not deeply equal to expected.\n     *\n     * T   Type of the objects.\n     * @param actual   Actual value.\n     * @param expected   Potential expected value.\n     * @param message   Message to display on error.\n     */\n    notDeepEqual<T>(actual: T, expected: T, message?: string): void;\n\n    /**\n     * Alias to deepEqual\n     *\n     * T   Type of the objects.\n     * @param actual   Actual value.\n     * @param expected   Potential expected value.\n     * @param message   Message to display on error.\n     */\n    deepStrictEqual<T>(actual: T, expected: T, message?: string): void;\n\n    /**\n     * Asserts valueToCheck is strictly greater than (>) valueToBeAbove.\n     *\n     * @param valueToCheck   Actual value.\n     * @param valueToBeAbove   Minimum Potential expected value.\n     * @param message   Message to display on error.\n     */\n    isAbove(\n      valueToCheck: number,\n      valueToBeAbove: number,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts valueToCheck is greater than or equal to (>=) valueToBeAtLeast.\n     *\n     * @param valueToCheck   Actual value.\n     * @param valueToBeAtLeast   Minimum Potential expected value.\n     * @param message   Message to display on error.\n     */\n    isAtLeast(\n      valueToCheck: number,\n      valueToBeAtLeast: number,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts valueToCheck is strictly less than (<) valueToBeBelow.\n     *\n     * @param valueToCheck   Actual value.\n     * @param valueToBeBelow   Minimum Potential expected value.\n     * @param message   Message to display on error.\n     */\n    isBelow(\n      valueToCheck: number,\n      valueToBeBelow: number,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts valueToCheck is less than or equal to (<=) valueToBeAtMost.\n     *\n     * @param valueToCheck   Actual value.\n     * @param valueToBeAtMost   Minimum Potential expected value.\n     * @param message   Message to display on error.\n     */\n    isAtMost(\n      valueToCheck: number,\n      valueToBeAtMost: number,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that value is true.\n     *\n     * @param value   Actual value.\n     * @param message   Message to display on error.\n     */\n    isTrue(value: unknown, message?: string): asserts value is true;\n\n    /**\n     * Asserts that value is false.\n     *\n     * @param value   Actual value.\n     * @param message   Message to display on error.\n     */\n    isFalse(value: unknown, message?: string): asserts value is false;\n\n    /**\n     * Asserts that value is not true.\n     *\n     * T   Type of value.\n     * @param value   Actual value.\n     * @param message   Message to display on error.\n     */\n    isNotTrue<T>(value: T, message?: string): asserts value is Exclude<T, true>;\n\n    /**\n     * Asserts that value is not false.\n     *\n     * @param value   Actual value.\n     * @param message   Message to display on error.\n     */\n    isNotFalse<T>(\n      value: T,\n      message?: string\n    ): asserts value is Exclude<T, false>;\n\n    /**\n     * Asserts that value is null.\n     *\n     * @param value   Actual value.\n     * @param message   Message to display on error.\n     */\n    isNull(value: unknown, message?: string): asserts value is null;\n\n    /**\n     * Asserts that value is not null.\n     *\n     * T   Type of value.\n     * @param value   Actual value.\n     * @param message   Message to display on error.\n     */\n    isNotNull<T>(value: T, message?: string): asserts value is Exclude<T, null>;\n\n    /**\n     * Asserts that value is NaN.\n     *\n     * T   Type of value.\n     * @param value   Actual value.\n     * @param message   Message to display on error.\n     */\n    isNaN<T>(value: T, message?: string): void;\n\n    /**\n     * Asserts that value is not NaN.\n     *\n     * T   Type of value.\n     * @param value   Actual value.\n     * @param message   Message to display on error.\n     */\n    isNotNaN<T>(value: T, message?: string): void;\n\n    /**\n     * Asserts that the target is neither null nor undefined.\n     *\n     * T   Type of value.\n     * @param value   Actual value.\n     * @param message    Message to display on error.\n     */\n    exists<T>(value: T, message?: string): asserts value is NonNullable<T>;\n\n    /**\n     * Asserts that the target is either null or undefined.\n     *\n     * @param value   Actual value.\n     * @param message    Message to display on error.\n     */\n    notExists(\n      value: unknown,\n      message?: string\n    ): asserts value is null | undefined;\n\n    /**\n     * Asserts that value is undefined.\n     *\n     * @param value   Actual value.\n     * @param message   Message to display on error.\n     */\n    isUndefined(value: unknown, message?: string): asserts value is undefined;\n\n    /**\n     * Asserts that value is not undefined.\n     *\n     * T   Type of value.\n     * @param value   Actual value.\n     * @param message   Message to display on error.\n     */\n    isDefined<T>(\n      value: T,\n      message?: string\n    ): asserts value is Exclude<T, undefined>;\n\n    /**\n     * Asserts that value is a function.\n     *\n     * T   Type of value.\n     * @param value   Actual value.\n     * @param message   Message to display on error.\n     */\n    isFunction<T>(value: T, message?: string): void;\n\n    /**\n     * Asserts that value is not a function.\n     *\n     * T   Type of value.\n     * @param value   Actual value.\n     * @param message   Message to display on error.\n     */\n    isNotFunction<T>(value: T, message?: string): void;\n\n    /**\n     * Asserts that value is an object of type 'Object'\n     * (as revealed by Object.prototype.toString).\n     *\n     * T   Type of value.\n     * @param value   Actual value.\n     * @param message   Message to display on error.\n     * @remarks The assertion does not match subclassed objects.\n     */\n    isObject<T>(value: T, message?: string): void;\n\n    /**\n     * Asserts that value is not an object of type 'Object'\n     * (as revealed by Object.prototype.toString).\n     *\n     * T   Type of value.\n     * @param value   Actual value.\n     * @param message   Message to display on error.\n     */\n    isNotObject<T>(value: T, message?: string): void;\n\n    /**\n     * Asserts that value is an array.\n     *\n     * T   Type of value.\n     * @param value   Actual value.\n     * @param message   Message to display on error.\n     */\n    isArray<T>(value: T, message?: string): void;\n\n    /**\n     * Asserts that value is not an array.\n     *\n     * T   Type of value.\n     * @param value   Actual value.\n     * @param message   Message to display on error.\n     */\n    isNotArray<T>(value: T, message?: string): void;\n\n    /**\n     * Asserts that value is a string.\n     *\n     * T   Type of value.\n     * @param value   Actual value.\n     * @param message   Message to display on error.\n     */\n    isString<T>(value: T, message?: string): void;\n\n    /**\n     * Asserts that value is not a string.\n     *\n     * T   Type of value.\n     * @param value   Actual value.\n     * @param message   Message to display on error.\n     */\n    isNotString<T>(value: T, message?: string): void;\n\n    /**\n     * Asserts that value is a number.\n     *\n     * T   Type of value.\n     * @param value   Actual value.\n     * @param message   Message to display on error.\n     */\n    isNumber<T>(value: T, message?: string): void;\n\n    /**\n     * Asserts that value is not a number.\n     *\n     * T   Type of value.\n     * @param value   Actual value.\n     * @param message   Message to display on error.\n     */\n    isNotNumber<T>(value: T, message?: string): void;\n\n    /**\n     * Asserts that value is a finite number.\n     * Unlike `.isNumber`, this will fail for `NaN` and `Infinity`.\n     *\n     * T   Type of value\n     * @param value    Actual value\n     * @param message   Message to display on error.\n     */\n    isFinite<T>(value: T, message?: string): void;\n\n    /**\n     * Asserts that value is a boolean.\n     *\n     * T   Type of value.\n     * @param value   Actual value.\n     * @param message   Message to display on error.\n     */\n    isBoolean<T>(value: T, message?: string): void;\n\n    /**\n     * Asserts that value is not a boolean.\n     *\n     * T   Type of value.\n     * @param value   Actual value.\n     * @param message   Message to display on error.\n     */\n    isNotBoolean<T>(value: T, message?: string): void;\n\n    /**\n     * Asserts that value's type is name, as determined by Object.prototype.toString.\n     *\n     * T   Type of value.\n     * @param value   Actual value.\n     * @param name   Potential expected type name of value.\n     * @param message   Message to display on error.\n     */\n    typeOf<T>(value: T, name: string, message?: string): void;\n\n    /**\n     * Asserts that value's type is not name, as determined by Object.prototype.toString.\n     *\n     * T   Type of value.\n     * @param value   Actual value.\n     * @param name   Potential expected type name of value.\n     * @param message   Message to display on error.\n     */\n    notTypeOf<T>(value: T, name: string, message?: string): void;\n\n    /**\n     * Asserts that value is an instance of constructor.\n     *\n     * T   Expected type of value.\n     * @param value   Actual value.\n     * @param constructor   Potential expected contructor of value.\n     * @param message   Message to display on error.\n     */\n    instanceOf<T>(\n      value: unknown,\n      constructor: Constructor<T>,\n      message?: string\n    ): asserts value is T;\n\n    /**\n     * Asserts that value is not an instance of constructor.\n     *\n     * T   Type of value.\n     * U   Type that value shouldn't be an instance of.\n     * @param value   Actual value.\n     * @param constructor   Potential expected contructor of value.\n     * @param message   Message to display on error.\n     */\n    notInstanceOf<T, U>(\n      value: T,\n      type: Constructor<U>,\n      message?: string\n    ): asserts value is Exclude<T, U>;\n\n    /**\n     * Asserts that haystack includes needle.\n     *\n     * @param haystack   Container string.\n     * @param needle   Potential substring of haystack.\n     * @param message   Message to display on error.\n     */\n    include(haystack: string, needle: string, message?: string): void;\n\n    /**\n     * Asserts that haystack includes needle.\n     *\n     * T   Type of values in haystack.\n     * @param haystack   Container array, set or map.\n     * @param needle   Potential value contained in haystack.\n     * @param message   Message to display on error.\n     */\n    include<T>(\n      haystack: readonly T[] | ReadonlySet<T> | ReadonlyMap<any, T>,\n      needle: T,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that haystack includes needle.\n     *\n     * T   Type of values in haystack.\n     * @param haystack   WeakSet container.\n     * @param needle   Potential value contained in haystack.\n     * @param message   Message to display on error.\n     */\n    include<T extends object>(\n      haystack: WeakSet<T>,\n      needle: T,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that haystack includes needle.\n     *\n     * T   Type of haystack.\n     * @param haystack   Object.\n     * @param needle   Potential subset of the haystack's properties.\n     * @param message   Message to display on error.\n     */\n    include<T>(haystack: T, needle: Partial<T>, message?: string): void;\n\n    /**\n     * Asserts that haystack does not includes needle.\n     *\n     * @param haystack   Container string.\n     * @param needle   Potential substring of haystack.\n     * @param message   Message to display on error.\n     */\n    notInclude(haystack: string, needle: string, message?: string): void;\n\n    /**\n     * Asserts that haystack does not includes needle.\n     *\n     * T   Type of values in haystack.\n     * @param haystack   Container array, set or map.\n     * @param needle   Potential value contained in haystack.\n     * @param message   Message to display on error.\n     */\n    notInclude<T>(\n      haystack: readonly T[] | ReadonlySet<T> | ReadonlyMap<any, T>,\n      needle: T,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that haystack does not includes needle.\n     *\n     * T   Type of values in haystack.\n     * @param haystack   WeakSet container.\n     * @param needle   Potential value contained in haystack.\n     * @param message   Message to display on error.\n     */\n    notInclude<T extends object>(\n      haystack: WeakSet<T>,\n      needle: T,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that haystack does not includes needle.\n     *\n     * T   Type of haystack.\n     * @param haystack   Object.\n     * @param needle   Potential subset of the haystack's properties.\n     * @param message   Message to display on error.\n     */\n    notInclude<T>(haystack: T, needle: Partial<T>, message?: string): void;\n\n    /**\n     * Asserts that haystack includes needle. Deep equality is used.\n     *\n     * @param haystack   Container string.\n     * @param needle   Potential substring of haystack.\n     * @param message   Message to display on error.\n     *\n     * @deprecated Does not have any effect on string. Use {@link Assert#include} instead.\n     */\n    deepInclude(haystack: string, needle: string, message?: string): void;\n\n    /**\n     * Asserts that haystack includes needle. Deep equality is used.\n     *\n     * T   Type of values in haystack.\n     * @param haystack   Container array, set or map.\n     * @param needle   Potential value contained in haystack.\n     * @param message   Message to display on error.\n     */\n    deepInclude<T>(\n      haystack: readonly T[] | ReadonlySet<T> | ReadonlyMap<any, T>,\n      needle: T,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that haystack does not includes needle.\n     *\n     * T   Type of haystack.\n     * @param haystack   Object.\n     * @param needle   Potential subset of the haystack's properties.\n     * @param message   Message to display on error.\n     */\n    deepInclude<T>(\n      haystack: T,\n      needle: T extends WeakSet<any> ? never : Partial<T>,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that haystack does not includes needle. Deep equality is used.\n     *\n     * @param haystack   Container string.\n     * @param needle   Potential substring of haystack.\n     * @param message   Message to display on error.\n     *\n     * @deprecated Does not have any effect on string. Use {@link Assert#notInclude} instead.\n     */\n    notDeepInclude(haystack: string, needle: string, message?: string): void;\n\n    /**\n     * Asserts that haystack does not includes needle. Deep equality is used.\n     *\n     * T   Type of values in haystack.\n     * @param haystack   Container array, set or map.\n     * @param needle   Potential value contained in haystack.\n     * @param message   Message to display on error.\n     */\n    notDeepInclude<T>(\n      haystack: readonly T[] | ReadonlySet<T> | ReadonlyMap<any, T>,\n      needle: T,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that haystack does not includes needle. Deep equality is used.\n     *\n     * T   Type of haystack.\n     * @param haystack   Object.\n     * @param needle   Potential subset of the haystack's properties.\n     * @param message   Message to display on error.\n     */\n    notDeepInclude<T>(\n      haystack: T,\n      needle: T extends WeakSet<any> ? never : Partial<T>,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that ‘haystack’ includes ‘needle’. Can be used to assert the inclusion of a subset of properties in an object.\n     *\n     * Enables the use of dot- and bracket-notation for referencing nested properties.\n     * ‘[]’ and ‘.’ in property names can be escaped using double backslashes.Asserts that ‘haystack’ includes ‘needle’.\n     * Can be used to assert the inclusion of a subset of properties in an object.\n     * Enables the use of dot- and bracket-notation for referencing nested properties.\n     * ‘[]’ and ‘.’ in property names can be escaped using double backslashes.\n     *\n     * @param haystack\n     * @param needle\n     * @param message   Message to display on error.\n     */\n    nestedInclude(haystack: any, needle: any, message?: string): void;\n\n    /**\n     * Asserts that ‘haystack’ does not include ‘needle’. Can be used to assert the absence of a subset of properties in an object.\n     *\n     * Enables the use of dot- and bracket-notation for referencing nested properties.\n     * ‘[]’ and ‘.’ in property names can be escaped using double backslashes.Asserts that ‘haystack’ includes ‘needle’.\n     * Can be used to assert the inclusion of a subset of properties in an object.\n     * Enables the use of dot- and bracket-notation for referencing nested properties.\n     * ‘[]’ and ‘.’ in property names can be escaped using double backslashes.\n     *\n     * @param haystack\n     * @param needle\n     * @param message   Message to display on error.\n     */\n    notNestedInclude(haystack: any, needle: any, message?: string): void;\n\n    /**\n     * Asserts that ‘haystack’ includes ‘needle’. Can be used to assert the inclusion of a subset of properties in an object while checking for deep equality\n     *\n     * Enables the use of dot- and bracket-notation for referencing nested properties.\n     * ‘[]’ and ‘.’ in property names can be escaped using double backslashes.Asserts that ‘haystack’ includes ‘needle’.\n     * Can be used to assert the inclusion of a subset of properties in an object.\n     * Enables the use of dot- and bracket-notation for referencing nested properties.\n     * ‘[]’ and ‘.’ in property names can be escaped using double backslashes.\n     *\n     * @param haystack\n     * @param needle\n     * @param message   Message to display on error.\n     */\n    deepNestedInclude(haystack: any, needle: any, message?: string): void;\n\n    /**\n     * Asserts that ‘haystack’ does not include ‘needle’. Can be used to assert the absence of a subset of properties in an object while checking for deep equality.\n     *\n     * Enables the use of dot- and bracket-notation for referencing nested properties.\n     * ‘[]’ and ‘.’ in property names can be escaped using double backslashes.Asserts that ‘haystack’ includes ‘needle’.\n     * Can be used to assert the inclusion of a subset of properties in an object.\n     * Enables the use of dot- and bracket-notation for referencing nested properties.\n     * ‘[]’ and ‘.’ in property names can be escaped using double backslashes.\n     *\n     * @param haystack\n     * @param needle\n     * @param message   Message to display on error.\n     */\n    notDeepNestedInclude(haystack: any, needle: any, message?: string): void;\n\n    /**\n     * Asserts that ‘haystack’ includes ‘needle’. Can be used to assert the inclusion of a subset of properties in an object while ignoring inherited properties.\n     *\n     * @param haystack\n     * @param needle\n     * @param message   Message to display on error.\n     */\n    ownInclude(haystack: any, needle: any, message?: string): void;\n\n    /**\n     * Asserts that ‘haystack’ includes ‘needle’. Can be used to assert the absence of a subset of properties in an object while ignoring inherited properties.\n     *\n     * @param haystack\n     * @param needle\n     * @param message   Message to display on error.\n     */\n    notOwnInclude(haystack: any, needle: any, message?: string): void;\n\n    /**\n     * Asserts that ‘haystack’ includes ‘needle’. Can be used to assert the inclusion of a subset of properties in an object while ignoring inherited properties and checking for deep\n     *\n     * @param haystack\n     * @param needle\n     * @param message   Message to display on error.\n     */\n    deepOwnInclude(haystack: any, needle: any, message?: string): void;\n\n    /**\n     * Asserts that ‘haystack’ includes ‘needle’. Can be used to assert the absence of a subset of properties in an object while ignoring inherited properties and checking for deep equality.\n     *\n     * @param haystack\n     * @param needle\n     * @param message   Message to display on error.\n     */\n    notDeepOwnInclude(haystack: any, needle: any, message?: string): void;\n\n    /**\n     * Asserts that value matches the regular expression regexp.\n     *\n     * @param value   Actual value.\n     * @param regexp   Potential match of value.\n     * @param message   Message to display on error.\n     */\n    match(value: string, regexp: RegExp, message?: string): void;\n\n    /**\n     * Asserts that value does not match the regular expression regexp.\n     *\n     * @param value   Actual value.\n     * @param regexp   Potential match of value.\n     * @param message   Message to display on error.\n     */\n    notMatch(expected: any, regexp: RegExp, message?: string): void;\n\n    /**\n     * Asserts that object has a property named by property.\n     *\n     * T   Type of object.\n     * @param object   Container object.\n     * @param property   Potential contained property of object.\n     * @param message   Message to display on error.\n     */\n    property<T>(\n      object: T,\n      property: string,\n      /* keyof T */ message?: string\n    ): void;\n\n    /**\n     * Asserts that object has a property named by property.\n     *\n     * T   Type of object.\n     * @param object   Container object.\n     * @param property   Potential contained property of object.\n     * @param message   Message to display on error.\n     */\n    notProperty<T>(\n      object: T,\n      property: string,\n      /* keyof T */ message?: string\n    ): void;\n\n    /**\n     * Asserts that object has a property named by property, which can be a string\n     * using dot- and bracket-notation for deep reference.\n     *\n     * T   Type of object.\n     * @param object   Container object.\n     * @param property   Potential contained property of object.\n     * @param message   Message to display on error.\n     */\n    deepProperty<T>(object: T, property: string, message?: string): void;\n\n    /**\n     * Asserts that object does not have a property named by property, which can be a\n     * string using dot- and bracket-notation for deep reference.\n     *\n     * T   Type of object.\n     * @param object   Container object.\n     * @param property   Potential contained property of object.\n     * @param message   Message to display on error.\n     */\n    notDeepProperty<T>(object: T, property: string, message?: string): void;\n\n    /**\n     * Asserts that object has a property named by property with value given by value.\n     *\n     * T   Type of object.\n     * V   Type of value.\n     * @param object   Container object.\n     * @param property   Potential contained property of object.\n     * @param value   Potential expected property value.\n     * @param message   Message to display on error.\n     */\n    propertyVal<T, V>(\n      object: T,\n      property: string,\n      /* keyof T */ value: V,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that object has a property named by property with value given by value.\n     *\n     * T   Type of object.\n     * V   Type of value.\n     * @param object   Container object.\n     * @param property   Potential contained property of object.\n     * @param value   Potential expected property value.\n     * @param message   Message to display on error.\n     */\n    notPropertyVal<T, V>(\n      object: T,\n      property: string,\n      /* keyof T */ value: V,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that object has a property named by property, which can be a string\n     * using dot- and bracket-notation for deep reference.\n     *\n     * T   Type of object.\n     * V   Type of value.\n     * @param object   Container object.\n     * @param property   Potential contained property of object.\n     * @param value   Potential expected property value.\n     * @param message   Message to display on error.\n     */\n    deepPropertyVal<T, V>(\n      object: T,\n      property: string,\n      value: V,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that object does not have a property named by property, which can be a\n     * string using dot- and bracket-notation for deep reference.\n     *\n     * T   Type of object.\n     * V   Type of value.\n     * @param object   Container object.\n     * @param property   Potential contained property of object.\n     * @param value   Potential expected property value.\n     * @param message   Message to display on error.\n     */\n    notDeepPropertyVal<T, V>(\n      object: T,\n      property: string,\n      value: V,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that object has a length property with the expected value.\n     *\n     * T   Type of object.\n     * @param object   Container object.\n     * @param length   Potential expected length of object.\n     * @param message   Message to display on error.\n     */\n    lengthOf<\n      T extends\n        | { readonly length?: number | undefined }\n        | { readonly size?: number | undefined },\n    >(\n      object: T,\n      length: number,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that fn will throw an error.\n     *\n     * @param fn   Function that may throw.\n     * @param errMsgMatcher   Expected error message matcher.\n     * @param ignored   Ignored parameter.\n     * @param message   Message to display on error.\n     */\n    throw(\n      fn: () => void,\n      errMsgMatcher?: RegExp | string,\n      ignored?: any,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that fn will throw an error.\n     *\n     * @param fn   Function that may throw.\n     * @param errorLike   Expected error constructor or error instance.\n     * @param errMsgMatcher   Expected error message matcher.\n     * @param message   Message to display on error.\n     */\n    throw(\n      fn: () => void,\n      errorLike?: ErrorConstructor | Error | null,\n      errMsgMatcher?: RegExp | string | null,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that fn will throw an error.\n     *\n     * @param fn   Function that may throw.\n     * @param errMsgMatcher   Expected error message matcher.\n     * @param ignored   Ignored parameter.\n     * @param message   Message to display on error.\n     */\n    throws(\n      fn: () => void,\n      errMsgMatcher?: RegExp | string,\n      ignored?: any,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that fn will throw an error.\n     *\n     * @param fn   Function that may throw.\n     * @param errorLike   Expected error constructor or error instance.\n     * @param errMsgMatcher   Expected error message matcher.\n     * @param message   Message to display on error.\n     */\n    throws(\n      fn: () => void,\n      errorLike?: ErrorConstructor | Error | null,\n      errMsgMatcher?: RegExp | string | null,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that fn will throw an error.\n     *\n     * @param fn   Function that may throw.\n     * @param errMsgMatcher   Expected error message matcher.\n     * @param ignored   Ignored parameter.\n     * @param message   Message to display on error.\n     */\n    Throw(\n      fn: () => void,\n      errMsgMatcher?: RegExp | string,\n      ignored?: any,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that fn will throw an error.\n     *\n     * @param fn   Function that may throw.\n     * @param errorLike   Expected error constructor or error instance.\n     * @param errMsgMatcher   Expected error message matcher.\n     * @param message   Message to display on error.\n     */\n    Throw(\n      fn: () => void,\n      errorLike?: ErrorConstructor | Error | null,\n      errMsgMatcher?: RegExp | string | null,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that fn will not throw an error.\n     *\n     * @param fn   Function that may throw.\n     * @param errMsgMatcher   Expected error message matcher.\n     * @param ignored   Ignored parameter.\n     * @param message   Message to display on error.\n     */\n    doesNotThrow(\n      fn: () => void,\n      errMsgMatcher?: RegExp | string,\n      ignored?: any,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that fn will not throw an error.\n     *\n     * @param fn   Function that may throw.\n     * @param errorLike   Expected error constructor or error instance.\n     * @param errMsgMatcher   Expected error message matcher.\n     * @param message   Message to display on error.\n     */\n    doesNotThrow(\n      fn: () => void,\n      errorLike?: ErrorConstructor | Error | null,\n      errMsgMatcher?: RegExp | string | null,\n      message?: string\n    ): void;\n\n    /**\n     * Compares two values using operator.\n     *\n     * @param val1   Left value during comparison.\n     * @param operator   Comparison operator.\n     * @param val2   Right value during comparison.\n     * @param message   Message to display on error.\n     */\n    operator(\n      val1: OperatorComparable,\n      operator: Operator,\n      val2: OperatorComparable,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that the target is equal to expected, to within a +/- delta range.\n     *\n     * @param actual   Actual value\n     * @param expected   Potential expected value.\n     * @param delta   Maximum differenced between values.\n     * @param message   Message to display on error.\n     */\n    closeTo(\n      actual: number,\n      expected: number,\n      delta: number,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that the target is equal to expected, to within a +/- delta range.\n     *\n     * @param actual   Actual value\n     * @param expected   Potential expected value.\n     * @param delta   Maximum differenced between values.\n     * @param message   Message to display on error.\n     */\n    approximately(\n      act: number,\n      exp: number,\n      delta: number,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that set1 and set2 have the same members. Order is not take into account.\n     *\n     * T   Type of set values.\n     * @param set1   Actual set of values.\n     * @param set2   Potential expected set of values.\n     * @param message   Message to display on error.\n     */\n    sameMembers<T>(set1: T[], set2: T[], message?: string): void;\n\n    /**\n     * Asserts that set1 and set2 have the same members using deep equality checking.\n     * Order is not take into account.\n     *\n     * T   Type of set values.\n     * @param set1   Actual set of values.\n     * @param set2   Potential expected set of values.\n     * @param message   Message to display on error.\n     */\n    sameDeepMembers<T>(set1: T[], set2: T[], message?: string): void;\n\n    /**\n     * Asserts that `set1` and `set2` don't have the same members in any order.\n     * Uses a deep equality check.\n     *\n     *  T   Type of set values.\n     * @param set1\n     * @param set2\n     * @param message\n     */\n    notSameDeepMembers<T>(set1: T[], set2: T[], message?: string): void;\n\n    /**\n     * Asserts that set1 and set2 have the same members in the same order.\n     * Uses a strict equality check (===).\n     *\n     * T   Type of set values.\n     * @param set1   Actual set of values.\n     * @param set2   Potential expected set of values.\n     * @param message   Message to display on error.\n     */\n    sameOrderedMembers<T>(set1: T[], set2: T[], message?: string): void;\n\n    /**\n     * Asserts that set1 and set2 don’t have the same members in the same order.\n     * Uses a strict equality check (===).\n     *\n     * T   Type of set values.\n     * @param set1   Actual set of values.\n     * @param set2   Potential expected set of values.\n     * @param message   Message to display on error.\n     */\n    notSameOrderedMembers<T>(set1: T[], set2: T[], message?: string): void;\n\n    /**\n     * Asserts that set1 and set2 have the same members in the same order.\n     * Uses a deep equality check.\n     *\n     * T   Type of set values.\n     * @param set1   Actual set of values.\n     * @param set2   Potential expected set of values.\n     * @param message   Message to display on error.\n     */\n    sameDeepOrderedMembers<T>(set1: T[], set2: T[], message?: string): void;\n\n    /**\n     * Asserts that set1 and set2 don’t have the same members in the same order.\n     * Uses a deep equality check.\n     *\n     * T   Type of set values.\n     * @param set1   Actual set of values.\n     * @param set2   Potential expected set of values.\n     * @param message   Message to display on error.\n     */\n    notSameDeepOrderedMembers<T>(set1: T[], set2: T[], message?: string): void;\n\n    /**\n     * Asserts that subset is included in superset in the same order beginning with the first element in superset.\n     * Uses a strict equality check (===).\n     *\n     * T   Type of set values.\n     * @param superset   Actual set of values.\n     * @param subset   Potential contained set of values.\n     * @param message   Message to display on error.\n     */\n    includeOrderedMembers<T>(\n      superset: T[],\n      subset: T[],\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that subset isn’t included in superset in the same order beginning with the first element in superset.\n     * Uses a strict equality check (===).\n     *\n     * T   Type of set values.\n     * @param superset   Actual set of values.\n     * @param subset   Potential contained set of values.\n     * @param message   Message to display on error.\n     */\n    notIncludeOrderedMembers<T>(\n      superset: T[],\n      subset: T[],\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that subset is included in superset in the same order beginning with the first element in superset.\n     * Uses a deep equality check.\n     *\n     * T   Type of set values.\n     * @param superset   Actual set of values.\n     * @param subset   Potential contained set of values.\n     * @param message   Message to display on error.\n     */\n    includeDeepOrderedMembers<T>(\n      superset: T[],\n      subset: T[],\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that subset isn’t included in superset in the same order beginning with the first element in superset.\n     * Uses a deep equality check.\n     *\n     * T   Type of set values.\n     * @param superset   Actual set of values.\n     * @param subset   Potential contained set of values.\n     * @param message   Message to display on error.\n     */\n    notIncludeDeepOrderedMembers<T>(\n      superset: T[],\n      subset: T[],\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that subset is included in superset. Order is not take into account.\n     *\n     * T   Type of set values.\n     * @param superset   Actual set of values.\n     * @param subset   Potential contained set of values.\n     * @param message   Message to display on error.\n     */\n    includeMembers<T>(superset: T[], subset: T[], message?: string): void;\n\n    /**\n     * Asserts that subset isn’t included in superset in any order.\n     * Uses a strict equality check (===). Duplicates are ignored.\n     *\n     * T   Type of set values.\n     * @param superset   Actual set of values.\n     * @param subset   Potential not contained set of values.\n     * @param message   Message to display on error.\n     */\n    notIncludeMembers<T>(superset: T[], subset: T[], message?: string): void;\n\n    /**\n     * Asserts that subset is included in superset using deep equality checking.\n     * Order is not take into account.\n     *\n     * T   Type of set values.\n     * @param superset   Actual set of values.\n     * @param subset   Potential contained set of values.\n     * @param message   Message to display on error.\n     */\n    includeDeepMembers<T>(superset: T[], subset: T[], message?: string): void;\n\n    /**\n     * Asserts that `subset` isn't included in `superset` in any order. Uses a\n     * deep equality check. Duplicates are ignored.\n     *\n     * assert.notIncludeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { f: 5 } ], 'not include deep members');\n     *\n     * T   Type of set values.\n     * @param superset   Actual set of values.\n     * @param subset   Potential contained set of values.\n     * @param message   Message to display on error.\n     */\n    notIncludeDeepMembers<T>(\n      superset: T[],\n      subset: T[],\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that non-object, non-array value inList appears in the flat array list.\n     *\n     * T   Type of list values.\n     * @param inList   Value expected to be in the list.\n     * @param list   List of values.\n     * @param message   Message to display on error.\n     */\n    oneOf<T>(inList: T, list: T[], message?: string): void;\n\n    /**\n     * Asserts that a function changes the value of a property.\n     *\n     * T   Type of object.\n     * @param modifier   Function to run.\n     * @param object   Container object.\n     * @param property   Property of object expected to be modified.\n     * @param message   Message to display on error.\n     */\n    changes<T>(\n      modifier: Function,\n      object: T,\n      property: string,\n      /* keyof T */ message?: string\n    ): void;\n\n    /**\n     * Asserts that a function changes the value of a property by an amount (delta).\n     *\n     * @param modifier function\n     * @param object or getter function\n     * @param property name _optional_\n     * @param change amount (delta)\n     * @param message _optional_\n     */\n    changesBy<T>(\n      modifier: Function,\n      object: T,\n      property: string,\n      /* keyof T */ change: number,\n      message?: string\n    ): void;\n    changesBy<T>(\n      modifier: Function,\n      object: T,\n      change: number,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that a function does not change the value of a property.\n     *\n     * T   Type of object.\n     * @param modifier   Function to run.\n     * @param object   Container object.\n     * @param property   Property of object expected not to be modified.\n     * @param message   Message to display on error.\n     */\n    doesNotChange<T>(\n      modifier: Function,\n      object: T,\n      property: string,\n      /* keyof T */ message?: string\n    ): void;\n\n    /**\n     * Asserts that a function increases an object property.\n     *\n     * T   Type of object.\n     * @param modifier   Function to run.\n     * @param object   Container object.\n     * @param property   Property of object expected to be increased.\n     * @param message   Message to display on error.\n     */\n    increases<T>(\n      modifier: Function,\n      object: T,\n      property: string,\n      /* keyof T */ message?: string\n    ): void;\n\n    /**\n     * Asserts that a function increases a numeric object property or a function's return value by an amount (delta).\n     *\n     * T   Type of object or function.\n     * @param modifier function\n     * @param object or getter function\n     * @param property name _optional_\n     * @param change amount (delta)\n     * @param message _optional_\n     */\n    increasesBy<T>(\n      modifier: Function,\n      object: T,\n      property: string,\n      /* keyof T */ change: number,\n      message?: string\n    ): void;\n    increasesBy<T>(\n      modifier: Function,\n      object: T,\n      change: number,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that a function does not increase an object property.\n     *\n     * T   Type of object.\n     * @param modifier   Function to run.\n     * @param object   Container object.\n     * @param property   Property of object expected not to be increased.\n     * @param message   Message to display on error.\n     */\n    doesNotIncrease<T>(\n      modifier: Function,\n      object: T,\n      property: string,\n      /* keyof T */ message?: string\n    ): void;\n\n    /**\n     * Asserts that a function does not increase a numeric object property or function's return value by an amount (delta).\n     *\n     * T   Type of object or function.\n     * @param modifier function\n     * @param object or getter function\n     * @param property name _optional_\n     * @param change amount (delta)\n     * @param message _optional_\n     */\n\n    increasesButNotBy<T>(\n      modifier: Function,\n      object: T,\n      property: string,\n      /* keyof T */ change: number,\n      message?: string\n    ): void;\n    increasesButNotBy<T>(\n      modifier: Function,\n      object: T,\n      change: number,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that a function decreases an object property.\n     *\n     * T   Type of object.\n     * @param modifier   Function to run.\n     * @param object   Container object.\n     * @param property   Property of object expected to be decreased.\n     * @param message   Message to display on error.\n     */\n    decreases<T>(\n      modifier: Function,\n      object: T,\n      property: string,\n      /* keyof T */ message?: string\n    ): void;\n\n    /**\n     * Asserts that a function decreases a numeric object property or a function's return value by an amount (delta)\n     *\n     * T   Type of object or function.\n     * @param modifier function\n     * @param object or getter function\n     * @param property name _optional_\n     * @param change amount (delta)\n     * @param message _optional_\n     */\n\n    decreasesBy<T>(\n      modifier: Function,\n      object: T,\n      property: string,\n      /* keyof T */ change: number,\n      message?: string\n    ): void;\n    decreasesBy<T>(\n      modifier: Function,\n      object: T,\n      change: number,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that a function does not decrease an object property.\n     *\n     * T   Type of object.\n     * @param modifier   Function to run.\n     * @param object   Container object.\n     * @param property   Property of object expected not to be decreased.\n     * @param message   Message to display on error.\n     */\n    doesNotDecrease<T>(\n      modifier: Function,\n      object: T,\n      property: string,\n      /* keyof T */ message?: string\n    ): void;\n\n    /**\n     * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)\n     *\n     * T   Type of object or function.\n     * @param modifier function\n     * @param object or getter function\n     * @param property name _optional_\n     * @param change amount (delta)\n     * @param message _optional_\n     */\n\n    doesNotDecreaseBy<T>(\n      modifier: Function,\n      object: T,\n      property: string,\n      /* keyof T */ change: number,\n      message?: string\n    ): void;\n    doesNotDecreaseBy<T>(\n      modifier: Function,\n      object: T,\n      change: number,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)\n     *\n     * T   Type of object or function.\n     * @param modifier function\n     * @param object or getter function\n     * @param property name _optional_\n     * @param change amount (delta)\n     * @param message _optional_\n     */\n\n    decreasesButNotBy<T>(\n      modifier: Function,\n      object: T,\n      property: string,\n      /* keyof T */ change: number,\n      message?: string\n    ): void;\n    decreasesButNotBy<T>(\n      modifier: Function,\n      object: T,\n      change: number,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts if value is not a false value, and throws if it is a true value.\n     *\n     * T   Type of object.\n     * @param object   Actual value.\n     * @param message   Message to display on error.\n     * @remarks This is added to allow for chai to be a drop-in replacement for\n     *          Node’s assert class.\n     */\n    ifError<T>(object: T, message?: string): void;\n\n    /**\n     * Asserts that object is extensible (can have new properties added to it).\n     *\n     * T   Type of object\n     * @param object   Actual value.\n     * @param message   Message to display on error.\n     */\n    isExtensible<T>(object: T, message?: string): void;\n\n    /**\n     * Asserts that object is extensible (can have new properties added to it).\n     *\n     * T   Type of object\n     * @param object   Actual value.\n     * @param message   Message to display on error.\n     */\n    extensible<T>(object: T, message?: string): void;\n\n    /**\n     * Asserts that object is not extensible.\n     *\n     * T   Type of object\n     * @param object   Actual value.\n     * @param message   Message to display on error.\n     */\n    isNotExtensible<T>(object: T, message?: string): void;\n\n    /**\n     * Asserts that object is not extensible.\n     *\n     * T   Type of object\n     * @param object   Actual value.\n     * @param message   Message to display on error.\n     */\n    notExtensible<T>(object: T, message?: string): void;\n\n    /**\n     * Asserts that object is sealed (can have new properties added to it\n     * and its existing properties cannot be removed).\n     *\n     * T   Type of object\n     * @param object   Actual value.\n     * @param message   Message to display on error.\n     */\n    isSealed<T>(object: T, message?: string): void;\n\n    /**\n     * Asserts that object is sealed (can have new properties added to it\n     * and its existing properties cannot be removed).\n     *\n     * T   Type of object\n     * @param object   Actual value.\n     * @param message   Message to display on error.\n     */\n    sealed<T>(object: T, message?: string): void;\n\n    /**\n     * Asserts that object is not sealed.\n     *\n     * T   Type of object\n     * @param object   Actual value.\n     * @param message   Message to display on error.\n     */\n    isNotSealed<T>(object: T, message?: string): void;\n\n    /**\n     * Asserts that object is not sealed.\n     *\n     * T   Type of object\n     * @param object   Actual value.\n     * @param message   Message to display on error.\n     */\n    notSealed<T>(object: T, message?: string): void;\n\n    /**\n     * Asserts that object is frozen (cannot have new properties added to it\n     * and its existing properties cannot be removed).\n     *\n     * T   Type of object\n     * @param object   Actual value.\n     * @param message   Message to display on error.\n     */\n    isFrozen<T>(object: T, message?: string): void;\n\n    /**\n     * Asserts that object is frozen (cannot have new properties added to it\n     * and its existing properties cannot be removed).\n     *\n     * T   Type of object\n     * @param object   Actual value.\n     * @param message   Message to display on error.\n     */\n    frozen<T>(object: T, message?: string): void;\n\n    /**\n     * Asserts that object is not frozen (cannot have new properties added to it\n     * and its existing properties cannot be removed).\n     *\n     * T   Type of object\n     * @param object   Actual value.\n     * @param message   Message to display on error.\n     */\n    isNotFrozen<T>(object: T, message?: string): void;\n\n    /**\n     * Asserts that object is not frozen (cannot have new properties added to it\n     * and its existing properties cannot be removed).\n     *\n     * T   Type of object\n     * @param object   Actual value.\n     * @param message   Message to display on error.\n     */\n    notFrozen<T>(object: T, message?: string): void;\n\n    /**\n     * Asserts that the target does not contain any values. For arrays and\n     * strings, it checks the length property. For Map and Set instances, it\n     * checks the size property. For non-function objects, it gets the count\n     * of own enumerable string keys.\n     *\n     * T   Type of object\n     * @param object   Actual value.\n     * @param message   Message to display on error.\n     */\n    isEmpty<T>(object: T, message?: string): void;\n\n    /**\n     * Asserts that the target contains values. For arrays and strings, it checks\n     * the length property. For Map and Set instances, it checks the size property.\n     * For non-function objects, it gets the count of own enumerable string keys.\n     *\n     * T   Type of object.\n     * @param object   Object to test.\n     * @param message    Message to display on error.\n     */\n    isNotEmpty<T>(object: T, message?: string): void;\n\n    /**\n     * Asserts that `object` has at least one of the `keys` provided.\n     * You can also provide a single object instead of a `keys` array and its keys\n     * will be used as the expected set of keys.\n     *\n     * T   Type of object.\n     * @param object   Object to test.\n     * @param keys   Keys to check\n     * @param message    Message to display on error.\n     */\n    hasAnyKeys<T>(\n      object: T,\n      keys: Array<Object | string> | { [key: string]: any },\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that `object` has all and only all of the `keys` provided.\n     * You can also provide a single object instead of a `keys` array and its keys\n     * will be used as the expected set of keys.\n     *\n     * T   Type of object.\n     * @param object   Object to test.\n     * @param keys   Keys to check\n     * @param message    Message to display on error.\n     */\n    hasAllKeys<T>(\n      object: T,\n      keys: Array<Object | string> | { [key: string]: any },\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that `object` has all of the `keys` provided but may have more keys not listed.\n     * You can also provide a single object instead of a `keys` array and its keys\n     * will be used as the expected set of keys.\n     *\n     * T   Type of object.\n     * @param object   Object to test.\n     * @param keys   Keys to check\n     * @param message    Message to display on error.\n     */\n    containsAllKeys<T>(\n      object: T,\n      keys: Array<Object | string> | { [key: string]: any },\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that `object` has none of the `keys` provided.\n     * You can also provide a single object instead of a `keys` array and its keys\n     * will be used as the expected set of keys.\n     *\n     * T   Type of object.\n     * @param object   Object to test.\n     * @param keys   Keys to check\n     * @param message    Message to display on error.\n     */\n    doesNotHaveAnyKeys<T>(\n      object: T,\n      keys: Array<Object | string> | { [key: string]: any },\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that `object` does not have at least one of the `keys` provided.\n     * You can also provide a single object instead of a `keys` array and its keys\n     * will be used as the expected set of keys.\n     *\n     * T   Type of object.\n     * @param object   Object to test.\n     * @param keys   Keys to check\n     * @param message    Message to display on error.\n     */\n    doesNotHaveAllKeys<T>(\n      object: T,\n      keys: Array<Object | string> | { [key: string]: any },\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that `object` has at least one of the `keys` provided.\n     * Since Sets and Maps can have objects as keys you can use this assertion to perform\n     * a deep comparison.\n     * You can also provide a single object instead of a `keys` array and its keys\n     * will be used as the expected set of keys.\n     *\n     * T   Type of object.\n     * @param object   Object to test.\n     * @param keys   Keys to check\n     * @param message    Message to display on error.\n     */\n    hasAnyDeepKeys<T>(\n      object: T,\n      keys: Array<Object | string> | { [key: string]: any },\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that `object` has all and only all of the `keys` provided.\n     * Since Sets and Maps can have objects as keys you can use this assertion to perform\n     * a deep comparison.\n     * You can also provide a single object instead of a `keys` array and its keys\n     * will be used as the expected set of keys.\n     *\n     * T   Type of object.\n     * @param object   Object to test.\n     * @param keys   Keys to check\n     * @param message    Message to display on error.\n     */\n    hasAllDeepKeys<T>(\n      object: T,\n      keys: Array<Object | string> | { [key: string]: any },\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that `object` contains all of the `keys` provided.\n     * Since Sets and Maps can have objects as keys you can use this assertion to perform\n     * a deep comparison.\n     * You can also provide a single object instead of a `keys` array and its keys\n     * will be used as the expected set of keys.\n     *\n     * T   Type of object.\n     * @param object   Object to test.\n     * @param keys   Keys to check\n     * @param message    Message to display on error.\n     */\n    containsAllDeepKeys<T>(\n      object: T,\n      keys: Array<Object | string> | { [key: string]: any },\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that `object` contains all of the `keys` provided.\n     * Since Sets and Maps can have objects as keys you can use this assertion to perform\n     * a deep comparison.\n     * You can also provide a single object instead of a `keys` array and its keys\n     * will be used as the expected set of keys.\n     *\n     * T   Type of object.\n     * @param object   Object to test.\n     * @param keys   Keys to check\n     * @param message    Message to display on error.\n     */\n    doesNotHaveAnyDeepKeys<T>(\n      object: T,\n      keys: Array<Object | string> | { [key: string]: any },\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that `object` contains all of the `keys` provided.\n     * Since Sets and Maps can have objects as keys you can use this assertion to perform\n     * a deep comparison.\n     * You can also provide a single object instead of a `keys` array and its keys\n     * will be used as the expected set of keys.\n     *\n     * T   Type of object.\n     * @param object   Object to test.\n     * @param keys   Keys to check\n     * @param message    Message to display on error.\n     */\n    doesNotHaveAllDeepKeys<T>(\n      object: T,\n      keys: Array<Object | string> | { [key: string]: any },\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that object has a direct or inherited property named by property,\n     * which can be a string using dot- and bracket-notation for nested reference.\n     *\n     * T   Type of object.\n     * @param object   Object to test.\n     * @param property    Property to test.\n     * @param message    Message to display on error.\n     */\n    nestedProperty<T>(object: T, property: string, message?: string): void;\n\n    /**\n     * Asserts that object does not have a property named by property,\n     * which can be a string using dot- and bracket-notation for nested reference.\n     * The property cannot exist on the object nor anywhere in its prototype chain.\n     *\n     * T   Type of object.\n     * @param object   Object to test.\n     * @param property    Property to test.\n     * @param message    Message to display on error.\n     */\n    notNestedProperty<T>(object: T, property: string, message?: string): void;\n\n    /**\n     * Asserts that object has a property named by property with value given by value.\n     * property can use dot- and bracket-notation for nested reference. Uses a strict equality check (===).\n     *\n     * T   Type of object.\n     * @param object   Object to test.\n     * @param property    Property to test.\n     * @param value    Value to test.\n     * @param message    Message to display on error.\n     */\n    nestedPropertyVal<T>(\n      object: T,\n      property: string,\n      value: any,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that object does not have a property named by property with value given by value.\n     * property can use dot- and bracket-notation for nested reference. Uses a strict equality check (===).\n     *\n     * T   Type of object.\n     * @param object   Object to test.\n     * @param property    Property to test.\n     * @param value    Value to test.\n     * @param message    Message to display on error.\n     */\n    notNestedPropertyVal<T>(\n      object: T,\n      property: string,\n      value: any,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that object has a property named by property with a value given by value.\n     * property can use dot- and bracket-notation for nested reference. Uses a deep equality check.\n     *\n     * T   Type of object.\n     * @param object   Object to test.\n     * @param property    Property to test.\n     * @param value    Value to test.\n     * @param message    Message to display on error.\n     */\n    deepNestedPropertyVal<T>(\n      object: T,\n      property: string,\n      value: any,\n      message?: string\n    ): void;\n\n    /**\n     * Asserts that object does not have a property named by property with value given by value.\n     * property can use dot- and bracket-notation for nested reference. Uses a deep equality check.\n     *\n     * T   Type of object.\n     * @param object   Object to test.\n     * @param property    Property to test.\n     * @param value    Value to test.\n     * @param message    Message to display on error.\n     */\n    notDeepNestedPropertyVal<T>(\n      object: T,\n      property: string,\n      value: any,\n      message?: string\n    ): void;\n  }\n\n  export interface Config {\n    /**\n     * Default: false\n     */\n    includeStack: boolean;\n\n    /**\n     * Default: true\n     */\n    showDiff: boolean;\n\n    /**\n     * Default: 40\n     */\n    truncateThreshold: number;\n\n    /**\n     * Default: true\n     */\n    useProxy: boolean;\n\n    /**\n     * Default: ['then', 'catch', 'inspect', 'toJSON']\n     */\n    proxyExcludedKeys: string[];\n  }\n\n  export class AssertionError {\n    constructor(message: string, _props?: any, ssf?: Function);\n    name: string;\n    message: string;\n    showDiff: boolean;\n    stack: string;\n  }\n}\n\ninterface Object {\n  should: Chai.Assertion;\n}\n",
          "language": "typescript"
        },
        "description": "",
        "runnable": false
      }
    },
    "test": {
      "code": "import output from \"@output\";\nexport { suite, test, runTests };\nlet currentSuite = null;\nlet tests = [];\nfunction suite(name, fn) {\n    const nestedName = currentSuite;\n    currentSuite = name;\n    fn();\n    currentSuite = nestedName;\n}\nfunction test(name, fn) {\n    const suite = currentSuite || \"Test\";\n    tests.push({ suite, name, fn });\n}\nfunction getIndicator(type) {\n    switch (type) {\n        case \"driver\":\n            return \"⚙️\";\n        case \"fail\":\n            return \"❌\";\n        case \"ok\":\n            return \"✅\";\n    }\n}\nasync function log(type, title, ...message) {\n    title = `${getIndicator(type)} ${title}`;\n    await output({\n        $metadata: { title, icon: \"generative-text\" },\n        schema: {\n            type: \"object\",\n            properties: {\n                messages: {\n                    title: \" \",\n                    type: \"string\",\n                    format: \"markdown\",\n                },\n            },\n        },\n        messages: message.join(\"\\n\\n\"),\n    });\n}\nasync function runTests() {\n    await log(\"driver\", \"Start\", \"Running tests ...\");\n    let passed = 0;\n    let failed = 0;\n    for (const test of tests) {\n        try {\n            await test.fn();\n            await log(\"ok\", test.suite, test.name);\n            passed++;\n        }\n        catch (e) {\n            const error = e;\n            await log(\"fail\", test.suite, test.name, error.message);\n            failed++;\n        }\n    }\n    await log(\"driver\", \"End\", `${failed + passed} tests completed`, `${failed} failed`, `${passed} passed`);\n}\n",
      "metadata": {
        "title": "test",
        "source": {
          "code": "import output from \"@output\";\n\nexport type SuiteFunction = () => void;\nexport type TestFunction = () => Promise<void>;\nexport type TestDeclaration = {\n  suite: string;\n  name: string;\n  fn: TestFunction;\n};\nexport type LogType = \"driver\" | \"fail\" | \"ok\";\n\nexport { suite, test, runTests };\n\nlet currentSuite: string | null = null;\nlet tests: TestDeclaration[] = [];\n\nfunction suite(name: string, fn: SuiteFunction) {\n  const nestedName = currentSuite;\n  currentSuite = name;\n  fn();\n  currentSuite = nestedName;\n}\n\nfunction test(name: string, fn: TestFunction) {\n  const suite = currentSuite || \"Test\";\n  tests.push({ suite, name, fn });\n}\n\nfunction getIndicator(type: LogType) {\n  switch (type) {\n    case \"driver\":\n      return \"⚙️\";\n    case \"fail\":\n      return \"❌\";\n    case \"ok\":\n      return \"✅\";\n  }\n}\n\nasync function log(type: LogType, title: string, ...message: string[]) {\n  title = `${getIndicator(type)} ${title}`;\n\n  await output({\n    $metadata: { title, icon: \"generative-text\" },\n    schema: {\n      type: \"object\",\n      properties: {\n        messages: {\n          title: \" \",\n          type: \"string\",\n          format: \"markdown\",\n        },\n      },\n    },\n    messages: message.join(\"\\n\\n\"),\n  });\n}\n\nasync function runTests() {\n  await log(\"driver\", \"Start\", \"Running tests ...\");\n  let passed = 0;\n  let failed = 0;\n\n  for (const test of tests) {\n    try {\n      await test.fn();\n      await log(\"ok\", test.suite, test.name);\n      passed++;\n    } catch (e) {\n      const error = e as Error;\n      await log(\"fail\", test.suite, test.name, error.message);\n      failed++;\n    }\n  }\n\n  await log(\n    \"driver\",\n    \"End\",\n    `${failed + passed} tests completed`,\n    `${failed} failed`,\n    `${passed} passed`\n  );\n}\n",
          "language": "typescript"
        },
        "description": "",
        "runnable": false
      }
    }
  },
  "nodes": [
    {
      "id": "input",
      "type": "input",
      "metadata": {
        "title": "Input"
      }
    },
    {
      "id": "run-module",
      "type": "runModule",
      "configuration": {
        "$module": "main"
      },
      "metadata": {
        "title": "Run \"Test Template\" module"
      }
    },
    {
      "id": "output",
      "type": "output",
      "metadata": {
        "title": "Output"
      }
    }
  ],
  "edges": [
    {
      "from": "input",
      "to": "run-module",
      "out": "*",
      "in": ""
    },
    {
      "from": "run-module",
      "to": "output",
      "out": "*",
      "in": ""
    }
  ]
}
