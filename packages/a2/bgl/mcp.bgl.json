{
  "title": "MCP Server",
  "description": "",
  "version": "0.0.1",
  "nodes": [],
  "edges": [],
  "metadata": {
    "icon": "generative",
    "visual": {
      "presentation": {
        "themes": {
          "f65ea9aa-b8c6-4c80-9667-a08c4f631013": {
            "themeColors": {
              "primaryColor": "#246db5",
              "secondaryColor": "#5cadff",
              "backgroundColor": "#ffffff",
              "textColor": "#1a1a1a",
              "primaryTextColor": "#ffffff"
            },
            "template": "basic",
            "splashScreen": {
              "storedData": {
                "handle": "/images/app/generic-flow.jpg",
                "mimeType": "image/jpeg"
              }
            }
          }
        },
        "theme": "f65ea9aa-b8c6-4c80-9667-a08c4f631013"
      }
    },
    "userModified": true,
    "tags": [
      "connector",
      "connector-singleton",
      "experimental",
      "published"
    ],
    "comments": [
      {
        "id": "comment-c74afa15",
        "text": "Intentionally Left Blank",
        "metadata": {
          "title": "Comment",
          "visual": {
            "x": 281,
            "y": 501,
            "collapsed": "expanded",
            "outputHeight": 0
          }
        }
      }
    ]
  },
  "modules": {
    "configurator": {
      "code": "/**\n * @fileoverview Add a description for your module here.\n */\nimport { createConfigurator } from \"./a2/connector-manager\";\nexport { invoke as default, describe };\nconst CONNECTOR_TITLE = \"MCP Server\";\nconst { invoke, describe } = createConfigurator({\n    title: CONNECTOR_TITLE,\n    initialize: async () => {\n        return { title: CONNECTOR_TITLE, configuration: {} };\n    },\n    read: async ({ id, configuration }) => {\n        return {\n            schema: {\n                type: \"object\",\n                properties: {\n                    endpoint: {\n                        type: \"string\",\n                        title: \"URL\",\n                        description: \"The URL of MCP Server SSE endpoint\",\n                    },\n                },\n            },\n            values: configuration,\n        };\n    },\n});\n",
      "metadata": {
        "title": "configurator",
        "source": {
          "code": "/**\n * @fileoverview Add a description for your module here.\n */\n\nimport { err, ok } from \"./a2/utils\";\nimport { createConfigurator } from \"./a2/connector-manager\";\n\nimport read from \"@read\";\nimport write from \"@write\";\n\nexport { invoke as default, describe };\n\nconst CONNECTOR_TITLE = \"MCP Server\";\n\ntype McpConfiguration = {\n  endpoint?: string;\n};\n\nconst { invoke, describe } = createConfigurator<McpConfiguration>({\n  title: CONNECTOR_TITLE,\n  initialize: async () => {\n    return { title: CONNECTOR_TITLE, configuration: {} };\n  },\n  read: async ({ id, configuration }) => {\n    return {\n      schema: {\n        type: \"object\",\n        properties: {\n          endpoint: {\n            type: \"string\",\n            title: \"URL\",\n            description: \"The URL of MCP Server SSE endpoint\",\n          },\n        },\n      },\n      values: configuration,\n    };\n  },\n});\n",
          "language": "typescript"
        },
        "description": "Add a description for your module here.",
        "runnable": false
      }
    },
    "mcp-client": {
      "code": "/**\n * @fileoverview Breadboard MCP Client\n */\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _McpClient_instances, _McpClient_id, _McpClient_messageEndpoint, _McpClient_path, _McpClient_sessionIdPath, _McpClient_newId;\nimport fetch from \"@fetch\";\nimport read from \"@read\";\nimport write from \"@write\";\nimport { ok, err } from \"./a2/utils\";\nexport { McpClient };\nfunction json(result) {\n    if (!ok(result))\n        return result;\n    const j = result.data?.at(-1)?.parts.at(0)?.json;\n    if (!j) {\n        return err(`Invalid result structure`);\n    }\n    return j;\n}\nfunction sse(result) {\n    const e = json(result);\n    if (!ok(e))\n        return e;\n    return e.data;\n}\nfunction rpc(result) {\n    const e = sse(result);\n    if (!ok(e))\n        return e;\n    return e.result;\n}\nclass McpClient {\n    constructor(connectorId, url) {\n        _McpClient_instances.add(this);\n        this.connectorId = connectorId;\n        this.url = url;\n        _McpClient_id.set(this, 0);\n        _McpClient_messageEndpoint.set(this, null);\n    }\n    async connect() {\n        if (__classPrivateFieldGet(this, _McpClient_messageEndpoint, \"f\")) {\n            return err(`Already connected to \"${__classPrivateFieldGet(this, _McpClient_messageEndpoint, \"f\")}\"`);\n        }\n        const file = __classPrivateFieldGet(this, _McpClient_instances, \"m\", _McpClient_path).call(this);\n        const url = this.url;\n        const savedSession = json(await read({ path: __classPrivateFieldGet(this, _McpClient_instances, \"m\", _McpClient_sessionIdPath).call(this) }));\n        if (ok(savedSession)) {\n            console.log(\"EXISTING SESSION\", savedSession);\n            __classPrivateFieldSet(this, _McpClient_messageEndpoint, savedSession.endpoint, \"f\");\n            return;\n        }\n        // Establish connection.\n        const connecting = await fetch({ url, file, stream: \"sse\" });\n        if (!ok(connecting))\n            return connecting;\n        // This is the connection path.\n        const path = connecting.response;\n        // Read the endpoint event\n        const connection = sse(await read({ path }));\n        if (!ok(connection))\n            return connection;\n        // do some crude URL munging.\n        const hostname = url.split(\"/\").slice(0, -1).join(\"/\");\n        const messageEndpoint = `${hostname}${connection}`;\n        const id = __classPrivateFieldGet(this, _McpClient_instances, \"m\", _McpClient_newId).call(this);\n        // send initialize request\n        const initializing = await fetch({\n            url: messageEndpoint,\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify({\n                jsonrpc: \"2.0\",\n                id,\n                method: \"initialize\",\n                params: {\n                    protocolVersion: \"2024-11-05\",\n                    clientInfo: {\n                        name: \"Breadboard\",\n                        version: \"1.0.0\",\n                    },\n                    capabilities: {\n                        tools: {},\n                    },\n                },\n            }),\n        });\n        if (!ok(initializing))\n            return initializing;\n        const initializeResponse = rpc(await read({ path }));\n        if (!ok(initializeResponse))\n            return initializeResponse;\n        const confirmInitialization = await fetch({\n            url: messageEndpoint,\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify({\n                jsonrpc: \"2.0\",\n                method: \"notifications/initialized\",\n            }),\n        });\n        if (!ok(confirmInitialization))\n            return confirmInitialization;\n        __classPrivateFieldSet(this, _McpClient_messageEndpoint, messageEndpoint, \"f\");\n        // Save message endpoint\n        const savingMessageEndpoint = await write({\n            path: __classPrivateFieldGet(this, _McpClient_instances, \"m\", _McpClient_sessionIdPath).call(this),\n            data: [\n                {\n                    parts: [{ json: { endpoint: messageEndpoint } }],\n                },\n            ],\n        });\n        if (!ok(savingMessageEndpoint))\n            return savingMessageEndpoint;\n    }\n    async listTools() {\n        if (!__classPrivateFieldGet(this, _McpClient_messageEndpoint, \"f\")) {\n            return err(`The client wasn't initialized. Call \"connect\" first.`);\n        }\n        const url = __classPrivateFieldGet(this, _McpClient_messageEndpoint, \"f\");\n        const id = __classPrivateFieldGet(this, _McpClient_instances, \"m\", _McpClient_newId).call(this);\n        const path = __classPrivateFieldGet(this, _McpClient_instances, \"m\", _McpClient_path).call(this);\n        // get list of tools\n        const askToListTools = await fetch({\n            url,\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify({\n                jsonrpc: \"2.0\",\n                id,\n                method: \"tools/list\",\n            }),\n        });\n        if (!ok(askToListTools))\n            return askToListTools;\n        const toolList = rpc(await read({ path }));\n        if (!ok(toolList))\n            return toolList;\n        return toolList.tools;\n    }\n    async callTool(name, args) {\n        if (!__classPrivateFieldGet(this, _McpClient_messageEndpoint, \"f\")) {\n            return err(`The client wasn't initialized. Call \"connect\" first.`);\n        }\n        const url = __classPrivateFieldGet(this, _McpClient_messageEndpoint, \"f\");\n        const id = __classPrivateFieldGet(this, _McpClient_instances, \"m\", _McpClient_newId).call(this);\n        const path = __classPrivateFieldGet(this, _McpClient_instances, \"m\", _McpClient_path).call(this);\n        // Call tool\n        const askToCallTool = await fetch({\n            url,\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify({\n                jsonrpc: \"2.0\",\n                id,\n                method: \"tools/call\",\n                params: { name, arguments: args },\n            }),\n        });\n        const readCallToolResults = rpc(await read({ path }));\n        if (!ok(readCallToolResults))\n            return readCallToolResults;\n        return readCallToolResults.content;\n    }\n    async disconnect() {\n        const path = __classPrivateFieldGet(this, _McpClient_instances, \"m\", _McpClient_path).call(this);\n        // Close the stream.\n        const deleting = await write({ path, delete: true });\n        // Delete the saved session\n        const deletingSession = await write({\n            path: __classPrivateFieldGet(this, _McpClient_instances, \"m\", _McpClient_sessionIdPath).call(this),\n            delete: true,\n        });\n        if (!ok(deleting))\n            return deleting;\n        if (!ok(deletingSession))\n            return deletingSession;\n    }\n}\n_McpClient_id = new WeakMap(), _McpClient_messageEndpoint = new WeakMap(), _McpClient_instances = new WeakSet(), _McpClient_path = function _McpClient_path() {\n    return `/session/mcp/${this.connectorId}/stream`;\n}, _McpClient_sessionIdPath = function _McpClient_sessionIdPath() {\n    return `/session/mcp/${this.connectorId}/id`;\n}, _McpClient_newId = function _McpClient_newId() {\n    var _a;\n    return __classPrivateFieldSet(this, _McpClient_id, (_a = __classPrivateFieldGet(this, _McpClient_id, \"f\"), ++_a), \"f\");\n};\n",
      "metadata": {
        "title": "mcp-client",
        "source": {
          "code": "/**\n * @fileoverview Breadboard MCP Client\n */\n\nimport fetch from \"@fetch\";\nimport read from \"@read\";\nimport write from \"@write\";\nimport query from \"@query\";\n\nimport { ok, err } from \"./a2/utils\";\n\nexport { McpClient };\n\nexport type InitializeResponse = {\n  capabilities: {\n    resources?: {};\n    tools?: {};\n    prompts?: {};\n  };\n  protocolVersion: string;\n  serverInfo: {\n    name: string;\n    version: string;\n  };\n};\n\nexport type ListToolsTool = {\n  name: string;\n  description: string;\n  // Schema is Breadboard-specific, but this should work well enough\n  inputSchema: Schema;\n};\n\nexport type ListToolsResponse = {\n  tools: ListToolsTool[];\n};\n\nexport type CallToolContentText = {\n  type: \"text\";\n  text: string;\n};\n\nexport type CallToolContentImage = {\n  type: \"image\";\n  data: string;\n  mimeType: string;\n};\n\nexport type CallToolContent = CallToolContentText | CallToolContentImage;\n\nexport type CallToolResponse = {\n  content: CallToolContent[];\n};\n\nexport type MCPResponse =\n  | InitializeResponse\n  | ListToolsResponse\n  | CallToolResponse;\n\nexport type JsonRpcResponse<M extends MCPResponse> = {\n  id: number;\n  jsonrpc: \"2.0\";\n  result: M;\n};\n\nexport type ServerSentEvent<T extends JsonSerializable = JsonSerializable> = {\n  data: T;\n  event: string;\n  id: string | null;\n  retry: string | null;\n};\n\nexport type SavedMessageEndpoint = {\n  endpoint: string;\n};\n\nfunction json<T>(result: FileSystemReadResult) {\n  if (!ok(result)) return result;\n  const j = (result.data?.at(-1)?.parts.at(0) as JSONPart)?.json;\n  if (!j) {\n    return err(`Invalid result structure`);\n  }\n  return j as T;\n}\n\nfunction sse<T extends JsonSerializable>(result: FileSystemReadResult) {\n  const e = json<ServerSentEvent<T>>(result);\n  if (!ok(e)) return e;\n  return e.data;\n}\n\nfunction rpc<M extends MCPResponse>(result: FileSystemReadResult) {\n  const e = sse<JsonRpcResponse<M>>(result);\n  if (!ok(e)) return e;\n  return e.result;\n}\n\nclass McpClient {\n  #id: number = 0;\n  #messageEndpoint: string | null = null;\n\n  constructor(\n    public readonly connectorId: string,\n    public readonly url: string\n  ) {}\n\n  #path(): FileSystemReadWritePath {\n    return `/session/mcp/${this.connectorId}/stream`;\n  }\n\n  #sessionIdPath(): FileSystemReadWritePath {\n    return `/session/mcp/${this.connectorId}/id`;\n  }\n\n  #newId() {\n    return ++this.#id;\n  }\n\n  async connect(): Promise<Outcome<void>> {\n    if (this.#messageEndpoint) {\n      return err(`Already connected to \"${this.#messageEndpoint}\"`);\n    }\n    const file = this.#path();\n    const url = this.url;\n\n    const savedSession = json<SavedMessageEndpoint>(\n      await read({ path: this.#sessionIdPath() })\n    );\n    if (ok(savedSession)) {\n      console.log(\"EXISTING SESSION\", savedSession);\n      this.#messageEndpoint = savedSession.endpoint;\n      return;\n    }\n\n    // Establish connection.\n    const connecting = await fetch({ url, file, stream: \"sse\" });\n    if (!ok(connecting)) return connecting;\n    // This is the connection path.\n    const path = connecting.response as FileSystemReadWritePath;\n\n    // Read the endpoint event\n    const connection = sse(await read({ path }));\n    if (!ok(connection)) return connection;\n\n    // do some crude URL munging.\n    const hostname = url.split(\"/\").slice(0, -1).join(\"/\");\n    const messageEndpoint = `${hostname}${connection}`;\n\n    const id = this.#newId();\n\n    // send initialize request\n    const initializing = await fetch({\n      url: messageEndpoint,\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n\n      body: JSON.stringify({\n        jsonrpc: \"2.0\",\n        id,\n        method: \"initialize\",\n        params: {\n          protocolVersion: \"2024-11-05\",\n          clientInfo: {\n            name: \"Breadboard\",\n            version: \"1.0.0\",\n          },\n          capabilities: {\n            tools: {},\n          },\n        },\n      }),\n    });\n    if (!ok(initializing)) return initializing;\n\n    const initializeResponse = rpc<InitializeResponse>(await read({ path }));\n    if (!ok(initializeResponse)) return initializeResponse;\n\n    const confirmInitialization = await fetch({\n      url: messageEndpoint,\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n\n      body: JSON.stringify({\n        jsonrpc: \"2.0\",\n        method: \"notifications/initialized\",\n      }),\n    });\n    if (!ok(confirmInitialization)) return confirmInitialization;\n\n    this.#messageEndpoint = messageEndpoint;\n    // Save message endpoint\n    const savingMessageEndpoint = await write({\n      path: this.#sessionIdPath(),\n      data: [\n        {\n          parts: [{ json: { endpoint: messageEndpoint } }],\n        },\n      ],\n    });\n    if (!ok(savingMessageEndpoint)) return savingMessageEndpoint;\n  }\n\n  async listTools(): Promise<Outcome<ListToolsTool[]>> {\n    if (!this.#messageEndpoint) {\n      return err(`The client wasn't initialized. Call \"connect\" first.`);\n    }\n    const url = this.#messageEndpoint;\n    const id = this.#newId();\n    const path = this.#path();\n    // get list of tools\n    const askToListTools = await fetch({\n      url,\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n\n      body: JSON.stringify({\n        jsonrpc: \"2.0\",\n        id,\n        method: \"tools/list\",\n      }),\n    });\n    if (!ok(askToListTools)) return askToListTools;\n\n    const toolList = rpc<ListToolsResponse>(await read({ path }));\n    if (!ok(toolList)) return toolList;\n    return toolList.tools;\n  }\n\n  async callTool(\n    name: string,\n    args: Record<string, JsonSerializable>\n  ): Promise<Outcome<CallToolContent[]>> {\n    if (!this.#messageEndpoint) {\n      return err(`The client wasn't initialized. Call \"connect\" first.`);\n    }\n\n    const url = this.#messageEndpoint;\n    const id = this.#newId();\n    const path = this.#path();\n\n    // Call tool\n    const askToCallTool = await fetch({\n      url,\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n\n      body: JSON.stringify({\n        jsonrpc: \"2.0\",\n        id,\n        method: \"tools/call\",\n        params: { name, arguments: args },\n      }),\n    });\n    const readCallToolResults = rpc<CallToolResponse>(await read({ path }));\n    if (!ok(readCallToolResults)) return readCallToolResults;\n    return readCallToolResults.content;\n  }\n\n  async disconnect(): Promise<Outcome<void>> {\n    const path = this.#path();\n\n    // Close the stream.\n    const deleting = await write({ path, delete: true });\n    // Delete the saved session\n    const deletingSession = await write({\n      path: this.#sessionIdPath(),\n      delete: true,\n    });\n    if (!ok(deleting)) return deleting;\n    if (!ok(deletingSession)) return deletingSession;\n  }\n}\n",
          "language": "typescript"
        },
        "description": "Breadboard MCP Client",
        "runnable": false
      }
    },
    "connector-tools": {
      "code": "/**\n * @fileoverview The tools export for the connector.\n */\nimport { ok } from \"./a2/utils\";\nimport { McpClient } from \"./mcp-client\";\nimport { createTools } from \"./a2/connector-manager\";\nexport { invoke as default, describe };\nasync function getClient(id, info) {\n    // for now, wrap it to point at MCP proxy\n    const url = `http://127.0.0.1:6277/sse?transportType=sse&url=${encodeURIComponent(info.configuration.endpoint)}`;\n    const client = new McpClient(id, url);\n    const connecting = await client.connect();\n    if (!ok(connecting))\n        return connecting;\n    return client;\n}\nconst { invoke, describe } = createTools({\n    title: \"MCP Server\",\n    list: async (id, info) => {\n        const client = await getClient(id, info);\n        if (!ok(client))\n            return client;\n        const listing = await client.listTools();\n        if (!ok(listing))\n            return listing;\n        // Transform to the ToolManager format.\n        const list = listing.map((item) => {\n            return {\n                url: info.url,\n                description: { ...item, title: item.name },\n                passContext: false,\n            };\n        });\n        return { list };\n    },\n    invoke: async (id, info, name, args) => {\n        const client = await getClient(id, info);\n        if (!ok(client))\n            return client;\n        const connecting = await client.connect();\n        if (!ok(connecting))\n            return connecting;\n        const invoking = await client.callTool(name, args);\n        if (!ok(invoking))\n            return invoking;\n        return { result: JSON.stringify(invoking) };\n    },\n});\n",
      "metadata": {
        "title": "connector-tools",
        "source": {
          "code": "/**\n * @fileoverview The tools export for the connector.\n */\n\nimport { err, ok } from \"./a2/utils\";\nimport { McpClient } from \"./mcp-client\";\nimport type {\n  ListToolResult,\n  ListMethodOutput,\n  InvokeMethodOutput,\n  ConnectorInfo,\n} from \"./a2/connector-manager\";\nimport { createTools } from \"./a2/connector-manager\";\n\nexport { invoke as default, describe };\n\ntype Configuration = {\n  endpoint: string;\n};\n\nasync function getClient(\n  id: string,\n  info: ConnectorInfo<Configuration>\n): Promise<Outcome<McpClient>> {\n  // for now, wrap it to point at MCP proxy\n  const url = `http://127.0.0.1:6277/sse?transportType=sse&url=${encodeURIComponent(info.configuration.endpoint)}`;\n  const client = new McpClient(id, url);\n  const connecting = await client.connect();\n  if (!ok(connecting)) return connecting;\n  return client;\n}\n\nconst { invoke, describe } = createTools<Configuration>({\n  title: \"MCP Server\",\n  list: async (id, info) => {\n    const client = await getClient(id, info);\n    if (!ok(client)) return client;\n    const listing = await client.listTools();\n    if (!ok(listing)) return listing;\n\n    // Transform to the ToolManager format.\n    const list = listing.map<ListToolResult>((item) => {\n      return {\n        url: info.url,\n        description: { ...item, title: item.name },\n        passContext: false,\n      };\n    });\n    return { list };\n  },\n  invoke: async (id, info, name, args) => {\n    const client = await getClient(id, info);\n    if (!ok(client)) return client;\n    const connecting = await client.connect();\n    if (!ok(connecting)) return connecting;\n    const invoking = await client.callTool(name, args);\n    if (!ok(invoking)) return invoking;\n    return { result: JSON.stringify(invoking) };\n  },\n});\n",
          "language": "typescript"
        },
        "description": "The tools export for the connector.",
        "runnable": false
      }
    }
  },
  "imports": {
    "a2": {
      "url": "./a2.bgl.json"
    }
  },
  "exports": [
    "#module:configurator",
    "#module:connector-tools"
  ]
}