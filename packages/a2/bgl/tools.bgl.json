{
  "title": "Tools",
  "description": "A collection of useful tools.",
  "version": "0.0.1",
  "nodes": [],
  "edges": [],
  "imports": {
    "a2": {
      "url": "./a2.bgl.json"
    }
  },
  "metadata": {
    "comments": [
      {
        "id": "comment-6fc8b597",
        "text": "Intentionally Left Blank",
        "metadata": {
          "visual": {
            "x": 7,
            "y": -575,
            "collapsed": "expanded",
            "outputHeight": 0
          }
        }
      }
    ],
    "visual": {
      "presentation": {
        "themes": {
          "f90eb9c1-e12c-4864-ba74-a15a3b8d77f3": {
            "themeColors": {
              "primaryColor": "#246db5",
              "secondaryColor": "#5cadff",
              "backgroundColor": "#ffffff",
              "textColor": "#1a1a1a",
              "primaryTextColor": "#ffffff"
            },
            "template": "basic",
            "splashScreen": {
              "storedData": {
                "handle": "/images/app/generic-flow.jpg",
                "mimeType": "image/jpeg"
              }
            }
          }
        },
        "theme": "f90eb9c1-e12c-4864-ba74-a15a3b8d77f3"
      }
    },
    "tags": [
      "published",
      "tool",
      "component"
    ]
  },
  "modules": {
    "Search-Events": {
      "code": "/**\n * @fileoverview Search local events.\n */\nimport { Template } from \"./a2/template\";\nimport { defaultLLMContent, err, ok, toLLMContent, toText } from \"./a2/utils\";\nimport toolSearchEvents, { describe as toolSearchEventsDescribe, } from \"./tool-search-events\";\nexport { invoke as default, describe };\nasync function resolveInput(caps, inputContent) {\n    const template = new Template(caps, inputContent);\n    const substituting = await template.substitute({}, async () => \"\");\n    if (!ok(substituting)) {\n        return substituting.$error;\n    }\n    return toText(substituting);\n}\nasync function invoke(inputs, caps) {\n    console.log(\"INTERNAL SEARCH INPUTS\", inputs);\n    let query;\n    let mode;\n    if (\"context\" in inputs) {\n        mode = \"step\";\n        const last = inputs.context?.at(-1);\n        if (last) {\n            query = toText(last);\n        }\n        else {\n            return err(\"Please provide a query\");\n        }\n    }\n    else if (\"p-query\" in inputs) {\n        query = await resolveInput(caps, inputs[\"p-query\"]);\n        mode = \"step\";\n    }\n    else {\n        query = inputs.query;\n        mode = \"tool\";\n    }\n    query = (query || \"\").trim();\n    if (!query) {\n        return err(\"Please provide a query\");\n    }\n    console.log(\"Query: \" + query);\n    const searchResults = await toolSearchEvents({\n        query,\n    }, caps);\n    if (!ok(searchResults)) {\n        return searchResults;\n    }\n    const results = searchResults.results;\n    if (mode === \"step\") {\n        return {\n            context: [toLLMContent(results)],\n        };\n    }\n    return { results };\n}\nasync function describe({ asType: _, ...inputs }) {\n    const isTool = inputs && Object.keys(inputs).length === 1;\n    if (isTool) {\n        return toolSearchEventsDescribe();\n    }\n    const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n    const query = hasWires\n        ? {}\n        : {\n            \"p-query\": {\n                type: \"object\",\n                title: \"Event search query\",\n                description: \"Please provide an event search query\",\n                behavior: [\n                    \"llm-content\",\n                    \"config\",\n                    \"hint-preview\",\n                    \"hint-single-line\",\n                ],\n                default: defaultLLMContent(),\n            },\n        };\n    return {\n        title: \"Search Events\",\n        description: \"Search local events.\",\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context in\",\n                    behavior: [\"main-port\"],\n                },\n                ...query,\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context out\",\n                    behavior: [\"main-port\"],\n                },\n            },\n        },\n        metadata: {\n            icon: \"web-search\",\n            tags: [\"quick-access\", \"tool\", \"component\", \"environment-corp\"],\n            order: 2,\n        },\n    };\n}\n"
    },
    "Search-Hotels": {
      "code": "/**\n * @fileoverview Search available hotels.\n */\nimport { Template } from \"./a2/template\";\nimport { defaultLLMContent, err, ok, toLLMContent, toText } from \"./a2/utils\";\nimport toolSearchHotels, { describe as toolSearchHotelsDescribe, } from \"./tool-search-hotels\";\nexport { invoke as default, describe };\nasync function resolveInput(caps, inputContent) {\n    const template = new Template(caps, inputContent);\n    const substituting = await template.substitute({}, async () => \"\");\n    if (!ok(substituting)) {\n        return substituting.$error;\n    }\n    return toText(substituting);\n}\nasync function invoke(inputs, caps) {\n    console.log(\"INTERNAL SEARCH INPUTS\", inputs);\n    let query;\n    let mode;\n    if (\"context\" in inputs) {\n        mode = \"step\";\n        const last = inputs.context?.at(-1);\n        if (last) {\n            query = toText(last);\n        }\n        else {\n            return err(\"Please provide a query\");\n        }\n    }\n    else if (\"p-query\" in inputs) {\n        query = await resolveInput(caps, inputs[\"p-query\"]);\n        mode = \"step\";\n    }\n    else {\n        query = inputs.query;\n        mode = \"tool\";\n    }\n    query = (query || \"\").trim();\n    if (!query) {\n        return err(\"Please provide a query\");\n    }\n    console.log(\"Query: \" + query);\n    const searchResults = await toolSearchHotels({\n        query,\n    }, caps);\n    if (!ok(searchResults)) {\n        return searchResults;\n    }\n    const results = searchResults.results;\n    if (mode === \"step\") {\n        return {\n            context: [toLLMContent(results)],\n        };\n    }\n    return { results };\n}\nasync function describe({ asType: _, ...inputs }) {\n    const isTool = inputs && Object.keys(inputs).length === 1;\n    if (isTool) {\n        return toolSearchHotelsDescribe();\n    }\n    const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n    const query = hasWires\n        ? {}\n        : {\n            \"p-query\": {\n                type: \"object\",\n                title: \"Hotel search query\",\n                description: \"Please provide a hotel search query\",\n                behavior: [\n                    \"llm-content\",\n                    \"config\",\n                    \"hint-preview\",\n                    \"hint-single-line\",\n                ],\n                default: defaultLLMContent(),\n            },\n        };\n    return {\n        title: \"Search Hotels\",\n        description: \"Search available hotels.\",\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context in\",\n                    behavior: [\"main-port\"],\n                },\n                ...query,\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context out\",\n                    behavior: [\"main-port\"],\n                },\n            },\n        },\n        metadata: {\n            icon: \"web-search\",\n            tags: [\"quick-access\", \"tool\", \"component\", \"environment-corp\"],\n            order: 2,\n        },\n    };\n}\n"
    },
    "Search-Jobs": {
      "code": "/**\n * @fileoverview Search available jobs.\n */\nimport { Template } from \"./a2/template\";\nimport { defaultLLMContent, err, ok, toLLMContent, toText } from \"./a2/utils\";\nimport toolSearchJobs, { describe as toolSearchJobsDescribe, } from \"./tool-search-jobs\";\nexport { invoke as default, describe };\nasync function resolveInput(caps, inputContent) {\n    const template = new Template(caps, inputContent);\n    const substituting = await template.substitute({}, async () => \"\");\n    if (!ok(substituting)) {\n        return substituting.$error;\n    }\n    return toText(substituting);\n}\nasync function invoke(inputs, caps) {\n    console.log(\"SEARCH INPUTS\", inputs);\n    let query;\n    let mode;\n    if (\"context\" in inputs) {\n        mode = \"step\";\n        const last = inputs.context?.at(-1);\n        if (last) {\n            query = toText(last);\n        }\n        else {\n            return err(\"Please provide a query\");\n        }\n    }\n    else if (\"p-query\" in inputs) {\n        query = await resolveInput(caps, inputs[\"p-query\"]);\n        mode = \"step\";\n    }\n    else {\n        query = inputs.query;\n        mode = \"tool\";\n    }\n    query = (query || \"\").trim();\n    if (!query) {\n        return err(\"Please provide a query\");\n    }\n    console.log(\"Query: \" + query);\n    const searchResults = await toolSearchJobs({\n        query,\n    }, caps);\n    if (!ok(searchResults)) {\n        return searchResults;\n    }\n    const results = searchResults.results;\n    if (mode === \"step\") {\n        return {\n            context: [toLLMContent(results)],\n        };\n    }\n    return { results };\n}\nasync function describe({ asType: _, ...inputs }) {\n    const isTool = inputs && Object.keys(inputs).length === 1;\n    if (isTool) {\n        return toolSearchJobsDescribe();\n    }\n    const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n    const query = hasWires\n        ? {}\n        : {\n            \"p-query\": {\n                type: \"object\",\n                title: \"Job search query\",\n                description: \"Please provide a job search query\",\n                behavior: [\n                    \"llm-content\",\n                    \"config\",\n                    \"hint-preview\",\n                    \"hint-single-line\",\n                ],\n                default: defaultLLMContent(),\n            },\n        };\n    return {\n        title: \"Search Jobs\",\n        description: \"Search available jobs.\",\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context in\",\n                    behavior: [\"main-port\"],\n                },\n                ...query,\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context out\",\n                    behavior: [\"main-port\"],\n                },\n            },\n        },\n        metadata: {\n            icon: \"web-search\",\n            tags: [\"quick-access\", \"tool\", \"component\", \"environment-corp\"],\n            order: 2,\n        },\n    };\n}\n"
    },
    "Search-Moma": {
      "code": "/**\n * @fileoverview Search using internal moma search engine.\n */\nimport { Template } from \"./a2/template\";\nimport { defaultLLMContent, err, ok, toLLMContent, toText } from \"./a2/utils\";\nimport toolSearchMoma, { describe as toolSearchMomaDescribe, } from \"./tool-search-moma\";\nexport { invoke as default, describe };\nasync function resolveInput(caps, inputContent) {\n    const template = new Template(caps, inputContent);\n    const substituting = await template.substitute({}, async () => \"\");\n    if (!ok(substituting)) {\n        return substituting.$error;\n    }\n    return toText(substituting);\n}\nasync function invoke(inputs, caps) {\n    console.log(\"MOMA SEARCH INPUTS\", inputs);\n    let query;\n    let mode;\n    if (\"context\" in inputs) {\n        mode = \"step\";\n        const last = inputs.context?.at(-1);\n        if (last) {\n            query = toText(last);\n        }\n        else {\n            return err(\"Please provide a query\");\n        }\n    }\n    else if (\"p-query\" in inputs) {\n        query = await resolveInput(caps, inputs[\"p-query\"]);\n        mode = \"step\";\n    }\n    else {\n        query = inputs.query;\n        mode = \"tool\";\n    }\n    query = (query || \"\").trim();\n    if (!query) {\n        return err(\"Please provide a query\");\n    }\n    console.log(\"Query: \" + query);\n    const searchResults = await toolSearchMoma({\n        query,\n    }, caps);\n    if (!ok(searchResults)) {\n        return searchResults;\n    }\n    const results = searchResults.results;\n    if (mode === \"step\") {\n        return {\n            context: [toLLMContent(results)],\n        };\n    }\n    return { results };\n}\nasync function describe({ asType: _, ...inputs }) {\n    const isTool = inputs && Object.keys(inputs).length === 1;\n    if (isTool) {\n        return toolSearchMomaDescribe();\n    }\n    const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n    const query = hasWires\n        ? {}\n        : {\n            \"p-query\": {\n                type: \"object\",\n                title: \"Search query\",\n                description: \"Please provide a search query\",\n                behavior: [\n                    \"llm-content\",\n                    \"config\",\n                    \"hint-preview\",\n                    \"hint-single-line\",\n                ],\n                default: defaultLLMContent(),\n            },\n        };\n    return {\n        title: \"Search Moma\",\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context in\",\n                    behavior: [\"main-port\"],\n                },\n                ...query,\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context out\",\n                    behavior: [\"main-port\"],\n                },\n            },\n        },\n        metadata: {\n            icon: \"web-search\",\n            tags: [\"quick-access\", \"tool\", \"component\"],\n            order: 2,\n        },\n    };\n}\n"
    },
    "code-execution": {
      "code": "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { err } from \"./a2/utils\";\nexport { invoke as default, describe };\nasync function invoke() {\n    return err(`Do not invoke this tool directly.`);\n}\nasync function describe() {\n    return {\n        title: \"Code Execution\",\n        description: \"Generates and runs Python code\",\n        inputSchema: {},\n        outputSchema: {},\n        metadata: {\n            icon: \"code\",\n            tags: [\"quick-access\", \"tool\", \"component\", \"experimental\"],\n            order: 5,\n        },\n    };\n}\n"
    },
    "get-weather-tool": {
      "code": "/**\n * @fileoverview The actual tool that gets the weather.\n */\nexport { invoke as default, describe };\nimport { executeTool } from \"./a2/step-executor\";\nimport { ok, toLLMContent } from \"./a2/utils\";\nconst USE_METEO = false;\nconst WEATHER_CODES = {\n    // Individual codes\n    \"0\": {\n        description: \"Clear sky\",\n        category: \"clear\",\n    },\n    // Ranges for cloud coverage\n    \"1\": {\n        description: \"Mainly clear\",\n        category: \"partlyCloudy\",\n    },\n    \"2\": {\n        description: \"Partly cloudy\",\n        category: \"partlyCloudy\",\n    },\n    \"3\": {\n        description: \"Overcast\",\n        category: \"cloudy\",\n    },\n    // Fog conditions\n    \"45\": {\n        description: \"Fog\",\n        category: \"fog\",\n    },\n    \"48\": {\n        description: \"Depositing rime fog\",\n        category: \"fog\",\n    },\n    // Drizzle intensities\n    \"51\": {\n        description: \"Light drizzle\",\n        category: \"drizzle\",\n        intensity: \"light\",\n    },\n    \"53\": {\n        description: \"Moderate drizzle\",\n        category: \"drizzle\",\n        intensity: \"moderate\",\n    },\n    \"55\": {\n        description: \"Dense drizzle\",\n        category: \"drizzle\",\n        intensity: \"heavy\",\n    },\n    // Freezing drizzle\n    \"56\": {\n        description: \"Light freezing drizzle\",\n        category: \"freezingDrizzle\",\n        intensity: \"light\",\n    },\n    \"57\": {\n        description: \"Dense freezing drizzle\",\n        category: \"freezingDrizzle\",\n        intensity: \"heavy\",\n    },\n    // Rain intensities\n    \"61\": {\n        description: \"Slight rain\",\n        category: \"rain\",\n        intensity: \"light\",\n    },\n    \"63\": {\n        description: \"Moderate rain\",\n        category: \"rain\",\n        intensity: \"moderate\",\n    },\n    \"65\": {\n        description: \"Heavy rain\",\n        category: \"rain\",\n        intensity: \"heavy\",\n    },\n    // Freezing rain\n    \"66\": {\n        description: \"Light freezing rain\",\n        category: \"freezingRain\",\n        intensity: \"light\",\n    },\n    \"67\": {\n        description: \"Heavy freezing rain\",\n        category: \"freezingRain\",\n        intensity: \"heavy\",\n    },\n    // Snow intensities\n    \"71\": {\n        description: \"Slight snow fall\",\n        category: \"snow\",\n        intensity: \"light\",\n    },\n    \"73\": {\n        description: \"Moderate snow fall\",\n        category: \"snow\",\n        intensity: \"moderate\",\n    },\n    \"75\": {\n        description: \"Heavy snow fall\",\n        category: \"snow\",\n        intensity: \"heavy\",\n    },\n    // Snow grains\n    \"77\": {\n        description: \"Snow grains\",\n        category: \"snowGrains\",\n    },\n    // Rain showers\n    \"80\": {\n        description: \"Slight rain showers\",\n        category: \"rainShowers\",\n        intensity: \"light\",\n    },\n    \"81\": {\n        description: \"Moderate rain showers\",\n        category: \"rainShowers\",\n        intensity: \"moderate\",\n    },\n    \"82\": {\n        description: \"Violent rain showers\",\n        category: \"rainShowers\",\n        intensity: \"violent\",\n    },\n    // Snow showers\n    \"85\": {\n        description: \"Slight snow showers\",\n        category: \"snowShowers\",\n        intensity: \"light\",\n    },\n    \"86\": {\n        description: \"Heavy snow showers\",\n        category: \"snowShowers\",\n        intensity: \"heavy\",\n    },\n    // Thunderstorm\n    \"95\": {\n        description: \"Thunderstorm\",\n        category: \"thunderstorm\",\n        intensity: \"moderate\",\n    },\n    // Thunderstorm with hail\n    \"96\": {\n        description: \"Thunderstorm with slight hail\",\n        category: \"thunderstormWithHail\",\n        intensity: \"light\",\n    },\n    \"99\": {\n        description: \"Thunderstorm with heavy hail\",\n        category: \"thunderstormWithHail\",\n        intensity: \"heavy\",\n    },\n};\nfunction geocodingUrl(location) {\n    return `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(location)}&count=10&language=en&format=json`;\n}\nfunction weatherUrl(latitude, longitude) {\n    // current=temperature_2m,is_day,precipitation,rain,showers,snowfall&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch&timezone=auto&forecast_days=1\n    return `https://api.open-meteo.com/v1/forecast?latitude=${encodeURIComponent(latitude)}&longitude=${encodeURIComponent(longitude)}&current=weather_code,temperature_2m,is_day,precipitation,rain,showers,snowfall&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch&timezone=auto&forecast_days=1`;\n}\nfunction getConditions(weather_code) {\n    const code = `${weather_code}`;\n    const conditions = WEATHER_CODES[code];\n    return conditions;\n}\nasync function invoke({ location }, caps) {\n    if (!USE_METEO) {\n        const executing = await executeTool(caps, \"get_weather\", {\n            location,\n        });\n        if (!ok(executing))\n            return executing;\n        return toLLMContent(executing);\n    }\n    const geocodingResponse = await caps.fetch({ url: geocodingUrl(location) });\n    if (\"$error\" in geocodingResponse) {\n        return { $error: geocodingResponse.$error };\n    }\n    const geocodingResults = geocodingResponse.response;\n    if (!geocodingResults.results) {\n        return { $error: `No results for location: \"${location}\"` };\n    }\n    const { latitude, longitude } = geocodingResults.results.at(0) || {};\n    if (!latitude || !longitude) {\n        return { $error: `No latitude/longitude for location: \"${location}\"` };\n    }\n    const weatherResponse = await caps.fetch({\n        url: weatherUrl(latitude, longitude),\n    });\n    if (\"$error\" in weatherResponse) {\n        return { $error: weatherResponse.$error };\n    }\n    const { current } = weatherResponse.response;\n    const precipitation = current.precipitation\n        ? `${current.precipitation} inches`\n        : \"none\";\n    const weather = {\n        location,\n        conditions: getConditions(current.weather_code),\n        time: current.time,\n        is_day: current.is_day == 1,\n        precipitation,\n        temperature: `${current.temperature_2m} F`,\n    };\n    if (current.showers) {\n        weather.showers = true;\n    }\n    if (current.snowfall) {\n        weather.snowfall = true;\n    }\n    if (current.rain) {\n        weather.rain = true;\n    }\n    const result = JSON.stringify(weather, null, 2);\n    return toLLMContent(result);\n}\nasync function describe() {\n    return {\n        title: \"Get Weather\",\n        description: \"Searches weather information on Google Search.\",\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                location: {\n                    type: \"string\",\n                    title: \"Location\",\n                    description: \"The name of the city\",\n                },\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                weather: {\n                    type: \"object\",\n                    title: \"Current Weather\",\n                },\n            },\n        },\n    };\n}\n"
    },
    "get-weather": {
      "code": "/**\n * @fileoverview Searches weather information on Google Search.\n */\nimport { Template } from \"./a2/template\";\nimport { defaultLLMContent, err, ok, toLLMContent, toText } from \"./a2/utils\";\nimport getWeather, { describe as getWeatherDescriber, } from \"./get-weather-tool\";\nexport { invoke as default, describe };\nasync function resolveInput(caps, inputContent) {\n    const template = new Template(caps, inputContent);\n    const substituting = await template.substitute({}, async () => \"\");\n    if (!ok(substituting)) {\n        return substituting.$error;\n    }\n    return toText(substituting);\n}\nasync function invoke(inputs, caps) {\n    let location;\n    if (\"context\" in inputs) {\n        const last = inputs.context?.at(-1);\n        if (last) {\n            location = toText(last);\n        }\n        else {\n            return err(\"Please provide a location\");\n        }\n    }\n    else if (\"p-location\" in inputs) {\n        location = await resolveInput(caps, inputs[\"p-location\"]);\n    }\n    else {\n        location = inputs.location;\n    }\n    location = (location || \"\").trim();\n    if (!location) {\n        return err(\"Please provide a location\");\n    }\n    console.log(\"Location: \" + location);\n    const weatherResult = await getWeather({ location }, caps);\n    if (!ok(weatherResult)) {\n        return weatherResult;\n    }\n    return {\n        context: [\n            toLLMContent(`Location: ${location}\\n\\n Weather information: ${toText(weatherResult)}`),\n        ],\n    };\n}\nasync function describe({ asType: _, ...inputs }) {\n    const isTool = inputs && Object.keys(inputs).length === 1;\n    if (isTool) {\n        return getWeatherDescriber();\n    }\n    const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n    const location = hasWires\n        ? {}\n        : {\n            \"p-location\": {\n                type: \"object\",\n                title: \"Location\",\n                description: \"Please provide the location for which to get current weather\",\n                behavior: [\n                    \"llm-content\",\n                    \"config\",\n                    \"hint-preview\",\n                    \"hint-single-line\",\n                ],\n                default: defaultLLMContent(),\n            },\n        };\n    return {\n        title: \"Get Weather\",\n        description: \"Searches weather information on Google Search.\",\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context in\",\n                    behavior: [\"main-port\"],\n                },\n                ...location,\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context out\",\n                    behavior: [\"hint-text\", \"main-port\"],\n                },\n            },\n        },\n        metadata: {\n            icon: \"sunny\",\n            tags: [\"quick-access\", \"tool\", \"component\"],\n            order: 5,\n        },\n    };\n}\n"
    },
    "get-webpage": {
      "code": "/**\n * @fileoverview Given a URL of a webpage, returns its content as Markdown with a list of links and other metadata.\n */\nimport { ListExpander } from \"./a2/lists\";\nimport { Template } from \"./a2/template\";\nimport { defaultLLMContent, err, ok, toLLMContent, toText, toTextConcat, } from \"./a2/utils\";\nimport toolGetWebpage, { describe as toolGetWebpageDescribe, } from \"./tool-get-webpage\";\nexport { invoke as default, describe };\nasync function resolveInput(caps, inputContent) {\n    const template = new Template(caps, inputContent);\n    const substituting = await template.substitute({}, async () => \"\");\n    if (!ok(substituting)) {\n        return toLLMContent(substituting.$error);\n    }\n    return substituting;\n}\nfunction extractURL(maybeMarkdownLink) {\n    // Sometimes Listification returns URLS in markdown format.\n    const singleRegex = /\\[.*?\\]\\(([^)]+)\\)/;\n    const match = maybeMarkdownLink.match(singleRegex);\n    if (match && match[1]) {\n        // match[1] is the content of the first capturing group (the URL)\n        const url = match[1];\n        return url;\n    }\n    return maybeMarkdownLink;\n}\nasync function invoke(inputs, caps) {\n    let urlContext = [];\n    let mode;\n    if (\"context\" in inputs) {\n        mode = \"step\";\n        if (inputs.context) {\n            urlContext = inputs.context;\n        }\n        else {\n            return err(\"Please provide a URL\");\n        }\n    }\n    else if (\"p-url\" in inputs) {\n        const urlContent = await resolveInput(caps, inputs[\"p-url\"]);\n        if (!ok(urlContent)) {\n            return urlContent;\n        }\n        urlContext = [urlContent];\n        mode = \"step\";\n    }\n    else {\n        urlContext = [toLLMContent(inputs.url)];\n        mode = \"tool\";\n    }\n    console.log(\"urlContext\");\n    console.log(urlContext);\n    const results = await new ListExpander(toLLMContent(defaultLLMContent()), urlContext).map(async (_, itemContext) => {\n        console.log(\"itemContext\");\n        console.log(itemContext);\n        let urlString = extractURL(toText(itemContext));\n        urlString = (urlString || \"\").trim();\n        if (!urlString) {\n            return err(\"Please provide a URL\");\n        }\n        console.log(\"URL: \", urlString);\n        const getting = await toolGetWebpage({ url: urlString }, caps);\n        if (!ok(getting)) {\n            return toLLMContent(getting.$error);\n        }\n        return toLLMContent(getting.results);\n    });\n    if (!ok(results)) {\n        return results;\n    }\n    if (mode == \"step\") {\n        return {\n            context: results,\n        };\n    }\n    return { results: toTextConcat(results) };\n}\nasync function describe({ asType: _, ...inputs }) {\n    const isTool = inputs && Object.keys(inputs).length === 1;\n    if (isTool) {\n        return toolGetWebpageDescribe();\n    }\n    const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n    const query = hasWires\n        ? {}\n        : {\n            \"p-url\": {\n                type: \"object\",\n                title: \"URL\",\n                description: \"Please provide URL of the webpage\",\n                behavior: [\n                    \"llm-content\",\n                    \"config\",\n                    \"hint-preview\",\n                    \"hint-single-line\",\n                ],\n                default: defaultLLMContent(),\n            },\n        };\n    return {\n        title: \"Get Webpage\",\n        description: \"Given a URL of a webpage, returns its content as Markdown with a list of links and other metadata.\",\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context in\",\n                    behavior: [\"main-port\"],\n                },\n                ...query,\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context out\",\n                    behavior: [\"main-port\"],\n                },\n            },\n        },\n        metadata: {\n            icon: \"language\",\n            tags: [\"quick-access\", \"tool\", \"component\"],\n            order: 4,\n        },\n    };\n}\n"
    },
    "search-enterprise": {
      "code": "/**\n * @fileoverview Search an enterprise search engine.\n */\nimport { Template } from \"./a2/template\";\nimport { defaultLLMContent, err, ok, toLLMContent, toText } from \"./a2/utils\";\nimport toolSearchEnterprise, { describe as toolSearchEnterpriseDescribe, } from \"./tool-search-enterprise\";\nexport { invoke as default, describe };\nasync function resolveInput(caps, inputContent) {\n    const template = new Template(caps, inputContent);\n    const substituting = await template.substitute({}, async () => \"\");\n    if (!ok(substituting)) {\n        return substituting.$error;\n    }\n    return toText(substituting);\n}\nasync function invoke(inputs, caps) {\n    console.log(\"ENTERPRISE SEARCH INPUTS\", inputs);\n    let query;\n    let search_engine_resource_name;\n    let mode;\n    if (\"context\" in inputs) {\n        mode = \"step\";\n        const last = inputs.context?.at(-1);\n        if (last) {\n            query = toText(last);\n        }\n        else {\n            return err(\"Please provide a query\");\n        }\n    }\n    else if (\"p-query\" in inputs) {\n        query = await resolveInput(caps, inputs[\"p-query\"]);\n        mode = \"step\";\n    }\n    else {\n        query = inputs.query;\n        search_engine_resource_name = inputs.search_engine_resource_name;\n        mode = \"tool\";\n    }\n    query = (query || \"\").trim();\n    if (!query) {\n        return err(\"Please provide a query\");\n    }\n    if (search_engine_resource_name === undefined) {\n        search_engine_resource_name = \"\";\n    }\n    console.log(\"Query: \" + query);\n    const searchResults = await toolSearchEnterprise({\n        query,\n        search_engine_resource_name,\n    }, caps);\n    if (!ok(searchResults)) {\n        return searchResults;\n    }\n    const results = searchResults.results;\n    if (mode === \"step\") {\n        return {\n            context: [toLLMContent(results)],\n        };\n    }\n    return { results };\n}\nasync function describe({ asType: _, ...inputs }) {\n    const isTool = inputs && Object.keys(inputs).length === 1;\n    if (isTool) {\n        return toolSearchEnterpriseDescribe();\n    }\n    const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n    const query = hasWires\n        ? {}\n        : {\n            \"p-query\": {\n                type: \"object\",\n                title: \"Search query\",\n                description: \"Please provide a search query\",\n                behavior: [\n                    \"llm-content\",\n                    \"config\",\n                    \"hint-preview\",\n                    \"hint-single-line\",\n                ],\n                default: defaultLLMContent(),\n            },\n        };\n    return {\n        title: \"Search Enterprise\",\n        description: \"Search an enterprise search engine.\",\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context in\",\n                    behavior: [\"main-port\"],\n                },\n                ...query,\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context out\",\n                    behavior: [\"main-port\"],\n                },\n            },\n        },\n        metadata: {\n            icon: \"web-search\",\n            tags: [\"quick-access\", \"tool\", \"component\", \"environment-agentspace\"],\n            order: 2,\n        },\n    };\n}\n"
    },
    "search-internal": {
      "code": "/**\n * @fileoverview Search using internal search engine.\n */\nimport { Template } from \"./a2/template\";\nimport { defaultLLMContent, err, ok, toLLMContent, toText } from \"./a2/utils\";\nimport toolSearchInternal, { describe as toolSearchInternalDescribe, } from \"./tool-search-internal\";\nexport { invoke as default, describe };\nasync function resolveInput(caps, inputContent) {\n    const template = new Template(caps, inputContent);\n    const substituting = await template.substitute({}, async () => \"\");\n    if (!ok(substituting)) {\n        return substituting.$error;\n    }\n    return toText(substituting);\n}\nasync function invoke(inputs, caps) {\n    console.log(\"INTERNAL SEARCH INPUTS\", inputs);\n    let query;\n    let mode;\n    if (\"context\" in inputs) {\n        mode = \"step\";\n        const last = inputs.context?.at(-1);\n        if (last) {\n            query = toText(last);\n        }\n        else {\n            return err(\"Please provide a query\");\n        }\n    }\n    else if (\"p-query\" in inputs) {\n        query = await resolveInput(caps, inputs[\"p-query\"]);\n        mode = \"step\";\n    }\n    else {\n        query = inputs.query;\n        mode = \"tool\";\n    }\n    query = (query || \"\").trim();\n    if (!query) {\n        return err(\"Please provide a query\");\n    }\n    console.log(\"Query: \" + query);\n    const searchResults = await toolSearchInternal({\n        query,\n    }, caps);\n    if (!ok(searchResults)) {\n        return searchResults;\n    }\n    const results = searchResults.results;\n    if (mode === \"step\") {\n        return {\n            context: [toLLMContent(results)],\n        };\n    }\n    return { results };\n}\nasync function describe({ asType: _, ...inputs }) {\n    const isTool = inputs && Object.keys(inputs).length === 1;\n    if (isTool) {\n        return toolSearchInternalDescribe();\n    }\n    const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n    const query = hasWires\n        ? {}\n        : {\n            \"p-query\": {\n                type: \"object\",\n                title: \"Search query\",\n                description: \"Please provide a search query\",\n                behavior: [\n                    \"llm-content\",\n                    \"config\",\n                    \"hint-preview\",\n                    \"hint-single-line\",\n                ],\n                default: defaultLLMContent(),\n            },\n        };\n    return {\n        title: \"Internal Search\",\n        description: \"Search using internal search engine.\",\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context in\",\n                    behavior: [\"main-port\"],\n                },\n                ...query,\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context out\",\n                    behavior: [\"main-port\"],\n                },\n            },\n        },\n        metadata: {\n            icon: \"web-search\",\n            tags: [\"quick-access\", \"tool\", \"component\", \"environment-corp\"],\n            order: 2,\n        },\n    };\n}\n"
    },
    "search-maps": {
      "code": "/**\n * @fileoverview Search for location information.\n */\nimport { Template } from \"./a2/template\";\nimport { defaultLLMContent, err, ok, toLLMContent, toText } from \"./a2/utils\";\nimport toolSearchMaps, { describe as toolSearchMapsDescribe, } from \"./tool-search-maps\";\nexport { invoke as default, describe };\nasync function resolveInput(caps, inputContent) {\n    const template = new Template(caps, inputContent);\n    const substituting = await template.substitute({}, async () => \"\");\n    if (!ok(substituting)) {\n        return substituting.$error;\n    }\n    return toText(substituting);\n}\nasync function invoke(inputs, caps) {\n    console.log(\"MAPS INPUTS\", inputs);\n    let query;\n    let mode;\n    if (\"context\" in inputs) {\n        mode = \"step\";\n        const last = inputs.context?.at(-1);\n        if (last) {\n            query = toText(last);\n        }\n        else {\n            return err(\"Please provide a query\");\n        }\n    }\n    else if (\"p-query\" in inputs) {\n        query = await resolveInput(caps, inputs[\"p-query\"]);\n        mode = \"step\";\n    }\n    else {\n        query = inputs.query;\n        mode = \"tool\";\n    }\n    query = (query || \"\").trim();\n    if (!query) {\n        return err(\"Please provide a query\");\n    }\n    console.log(\"Query: \" + query);\n    const searchMapsResults = await toolSearchMaps({ query }, caps);\n    if (!ok(searchMapsResults)) {\n        return searchMapsResults;\n    }\n    const results = searchMapsResults.results;\n    if (mode === \"step\") {\n        return {\n            context: [toLLMContent(results)],\n        };\n    }\n    return { results };\n}\nasync function describe({ asType: _, ...inputs }) {\n    const isTool = inputs && Object.keys(inputs).length === 1;\n    if (isTool) {\n        return toolSearchMapsDescribe();\n    }\n    const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n    const query = hasWires\n        ? {}\n        : {\n            \"p-query\": {\n                type: \"object\",\n                title: \"Search query\",\n                description: \"Please provide a search query\",\n                behavior: [\n                    \"llm-content\",\n                    \"config\",\n                    \"hint-preview\",\n                    \"hint-single-line\",\n                ],\n                default: defaultLLMContent(),\n            },\n        };\n    return {\n        title: \"Search Maps\",\n        description: \"Search for location information.\",\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context in\",\n                    behavior: [\"main-port\"],\n                },\n                ...query,\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context out\",\n                    behavior: [\"main-port\"],\n                },\n            },\n        },\n        metadata: {\n            icon: \"map-search\",\n            tags: [\"quick-access\", \"tool\", \"component\"],\n            order: 2,\n        },\n    };\n}\n"
    },
    "search-web": {
      "code": "/**\n * @fileoverview Given a query, searches the Web with Google Search.\n */\nimport { ListExpander } from \"./a2/lists\";\nimport { Template } from \"./a2/template\";\nimport { defaultLLMContent, err, ok, toLLMContent, toText, toTextConcat, } from \"./a2/utils\";\nimport toolSearchWeb, { describe as toolSearchWebDescribe, } from \"./tool-search-web\";\nexport { invoke as default, describe };\nasync function resolveInput(caps, inputContent) {\n    const template = new Template(caps, inputContent);\n    const substituting = await template.substitute({}, async () => \"\");\n    if (!ok(substituting)) {\n        return toLLMContent(substituting.$error);\n    }\n    return substituting;\n}\nfunction extractQuery(maybeMarkdownListItem) {\n    if (maybeMarkdownListItem.startsWith(\"* \")) {\n        return maybeMarkdownListItem.replace(\"* \", \"\");\n    }\n    return maybeMarkdownListItem;\n}\nasync function invoke(inputs, caps) {\n    let query;\n    let mode;\n    if (\"context\" in inputs) {\n        mode = \"step\";\n        if (inputs.context) {\n            query = inputs.context;\n        }\n        else {\n            return err(\"Please provide a URL\");\n        }\n    }\n    else if (\"p-query\" in inputs) {\n        const queryContent = await resolveInput(caps, inputs[\"p-query\"]);\n        if (!ok(queryContent)) {\n            return queryContent;\n        }\n        query = [queryContent];\n        mode = \"step\";\n    }\n    else {\n        query = [toLLMContent(inputs.query)];\n        mode = \"tool\";\n    }\n    const searchResults = await new ListExpander(toLLMContent(defaultLLMContent()), query).map(async (_, itemContext) => {\n        let queryString = extractQuery(toText(itemContext));\n        queryString = (queryString || \"\").trim();\n        if (!queryString) {\n            return err(\"Please provide a query\");\n        }\n        console.log(\"Query: \", queryString);\n        const getting = await toolSearchWeb({ query: queryString }, caps);\n        if (!ok(getting)) {\n            return toLLMContent(getting.$error);\n        }\n        return toLLMContent(getting.results);\n    });\n    if (!ok(searchResults)) {\n        return searchResults;\n    }\n    if (mode === \"step\") {\n        return {\n            context: searchResults,\n        };\n    }\n    return { results: toTextConcat(searchResults) };\n}\nasync function describe({ asType: _, ...inputs }) {\n    const isTool = inputs && Object.keys(inputs).length === 1;\n    if (isTool) {\n        return toolSearchWebDescribe();\n    }\n    const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n    const query = hasWires\n        ? {}\n        : {\n            \"p-query\": {\n                type: \"object\",\n                title: \"Search query\",\n                description: \"Please provide a search query\",\n                behavior: [\n                    \"llm-content\",\n                    \"config\",\n                    \"hint-preview\",\n                    \"hint-single-line\",\n                ],\n                default: defaultLLMContent(),\n            },\n        };\n    return {\n        title: \"Search Web\",\n        description: \"Given a query, searches the Web with Google Search.\",\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: {\n                        type: \"object\",\n                        behavior: [\"llm-content\"],\n                    },\n                    title: \"Context in\",\n                    behavior: [\"main-port\"],\n                },\n                ...query,\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context out\",\n                    behavior: [\"main-port\"],\n                },\n            },\n        },\n        metadata: {\n            icon: \"search\",\n            tags: [\"quick-access\", \"tool\", \"component\"],\n            order: 1,\n        },\n    };\n}\n"
    },
    "search-wikipedia": {
      "code": "/**\n * @fileoverview Given a query, searches Wikipedia.\n */\nimport { Template } from \"./a2/template\";\nimport searchWikipedia, { describe as searchWikipediaDescriber, } from \"./tool-search-wikipedia\";\nimport { defaultLLMContent, err, ok, toLLMContent, toText } from \"./a2/utils\";\nexport { invoke as default, describe };\nasync function resolveInput(caps, inputContent) {\n    const template = new Template(caps, inputContent);\n    const substituting = await template.substitute({}, async () => \"\");\n    if (!ok(substituting)) {\n        return substituting.$error;\n    }\n    return toText(substituting);\n}\nasync function invoke(inputs, caps) {\n    let query;\n    let mode;\n    if (\"context\" in inputs) {\n        mode = \"step\";\n        const last = inputs.context?.at(-1);\n        if (last) {\n            query = toText(last);\n        }\n        else {\n            return err(\"Please provide a query\");\n        }\n    }\n    else if (\"p-query\" in inputs) {\n        query = await resolveInput(caps, inputs[\"p-query\"]);\n        mode = \"step\";\n    }\n    else {\n        query = inputs.query;\n        mode = \"tool\";\n    }\n    query = (query || \"\").trim();\n    if (!query) {\n        return err(\"Please provide a query\");\n    }\n    console.log(\"Query: \" + query);\n    const result = await searchWikipedia({ query }, caps);\n    if (!ok(result)) {\n        return result;\n    }\n    if (mode == \"step\") {\n        return {\n            context: [\n                toLLMContent(`Query: ${query}\\n\\n Search Results: \\n\\n\\`\\`\\`json\\n${JSON.stringify(result, null, 2)}\\n\\`\\`\\``),\n            ],\n        };\n    }\n    else {\n        return result;\n    }\n    return { context: [] };\n}\nasync function describe({ asType: _, ...inputs }) {\n    const isTool = inputs && Object.keys(inputs).length === 1;\n    if (isTool) {\n        return searchWikipediaDescriber();\n    }\n    const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n    const query = hasWires\n        ? {}\n        : {\n            \"p-query\": {\n                type: \"object\",\n                title: \"Query\",\n                description: \"Please provide the query with which to search Wikipedia\",\n                behavior: [\n                    \"llm-content\",\n                    \"config\",\n                    \"hint-preview\",\n                    \"hint-single-line\",\n                ],\n                default: defaultLLMContent(),\n            },\n        };\n    return {\n        title: \"Search Wikipedia\",\n        description: \"Given a query, searches Wikipedia.\",\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context in\",\n                    behavior: [\"main-port\"],\n                },\n                ...query,\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context out\",\n                    behavior: [\"main-port\"],\n                },\n            },\n        },\n        metadata: {\n            icon: \"globe-book\",\n            tags: [\"quick-access\", \"tool\", \"component\"],\n            order: 3,\n        },\n    };\n}\n"
    },
    "sql-query-internal": {
      "code": "/**\n * @fileoverview Query over data sources using internal SQL query engine.\n */\nimport { Template } from \"./a2/template\";\nimport { defaultLLMContent, err, ok, toLLMContent, toText } from \"./a2/utils\";\nimport toolQueryInternal, { describe as toolInternalDescribe, } from \"./tool-sql-query-internal\";\nexport { invoke as default, describe };\nasync function resolveInput(caps, inputContent) {\n    const template = new Template(caps, inputContent);\n    const substituting = await template.substitute({}, async () => \"\");\n    if (!ok(substituting)) {\n        return substituting.$error;\n    }\n    return toText(substituting);\n}\nasync function invoke(inputs, caps) {\n    console.log(\"SQL QUERY\", inputs);\n    let query;\n    let mode;\n    if (\"context\" in inputs) {\n        mode = \"step\";\n        const last = inputs.context?.at(-1);\n        if (last) {\n            query = toText(last);\n        }\n        else {\n            return err(\"Please provide a query\");\n        }\n    }\n    else if (\"p-query\" in inputs) {\n        query = await resolveInput(caps, inputs[\"p-query\"]);\n        mode = \"step\";\n    }\n    else {\n        query = inputs.query;\n        mode = \"tool\";\n    }\n    query = (query || \"\").trim();\n    if (!query) {\n        return err(\"Please provide a query\");\n    }\n    console.log(\"Query: \" + query);\n    const queryResults = await toolQueryInternal({\n        query,\n    }, caps);\n    if (!ok(queryResults)) {\n        return queryResults;\n    }\n    const results = queryResults.results;\n    if (mode === \"step\") {\n        return {\n            context: [toLLMContent(results)],\n        };\n    }\n    return { results };\n}\nasync function describe({ asType: _, ...inputs }) {\n    const isTool = inputs && Object.keys(inputs).length === 1;\n    if (isTool) {\n        return toolInternalDescribe();\n    }\n    const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n    const query = hasWires\n        ? {}\n        : {\n            \"p-query\": {\n                type: \"object\",\n                title: \"SQL query\",\n                description: \"Please provide a SQL query\",\n                behavior: [\n                    \"llm-content\",\n                    \"config\",\n                    \"hint-preview\",\n                    \"hint-single-line\",\n                ],\n                default: defaultLLMContent(),\n            },\n        };\n    return {\n        title: \"SQL Query Internal\",\n        description: \"Query over data sources using internal SQL query engine.\",\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context in\",\n                    behavior: [\"main-port\"],\n                },\n                ...query,\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context out\",\n                    behavior: [\"main-port\"],\n                },\n            },\n        },\n        metadata: {\n            icon: \"web-search\",\n            tags: [\"quick-access\", \"tool\", \"component\", \"environment-corp\"],\n            order: 2,\n        },\n    };\n}\n"
    },
    "tool-get-webpage": {
      "code": "/**\n * @fileoverview The guts of the Get webpage tool.\n */\nimport { executeTool } from \"./a2/step-executor\";\nimport { err, ok } from \"./a2/utils\";\nexport { invoke as default, describe };\nasync function getContentFromUrl(caps, url) {\n    const executing = await executeTool(caps, \"get_content_from_url\", { url });\n    if (!ok(executing))\n        return executing;\n    console.log(\"GET CONTENT\", executing);\n    if (typeof executing === \"string\") {\n        return err(`Unexpected string response from tool`);\n    }\n    const { html_body, markdown } = executing;\n    if (markdown) {\n        return markdown;\n    }\n    else {\n        return `\\`\\`\\`html\\n\\n${html_body}\\n\\n\\`\\`\\``;\n    }\n}\nasync function invoke({ url }, caps) {\n    const results = await getContentFromUrl(caps, url);\n    if (!ok(results))\n        return results;\n    return { results };\n}\nasync function describe() {\n    return {\n        title: \"Get Webpage\",\n        description: \"Given a URL of a webpage, returns its content as Markdown with a list of links and other metadata.\",\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                url: {\n                    type: \"string\",\n                    title: \"URL\",\n                    description: \"The URL of the webpage whose content will retrieved\",\n                },\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                results: {\n                    type: \"string\",\n                    title: \"Contents of the webpage\",\n                },\n            },\n        },\n    };\n}\n"
    },
    "tool-search-enterprise": {
      "code": "/**\n * @fileoverview The guts of the Search Enterprise tool.\n */\nimport { executeTool } from \"./a2/step-executor\";\nimport { ok } from \"./a2/utils\";\nexport { invoke as default, describe };\nasync function invoke({ query, search_engine_resource_name }, caps) {\n    const executing = await executeTool(caps, \"enterprise_search\", {\n        query,\n        search_engine_resource_name,\n    });\n    if (!ok(executing))\n        return executing;\n    return { results: executing };\n}\nasync function describe() {\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                query: {\n                    type: \"string\",\n                    title: \"Query\",\n                    description: \"The search query\",\n                },\n                search_engine_resource_name: {\n                    type: \"string\",\n                    title: \"Search Engine Resource Name [Optional]\",\n                    description: \"An optional resource name for the search backend to use\",\n                },\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                results: {\n                    type: \"string\",\n                    title: \"Search Results\",\n                },\n            },\n        },\n    };\n}\n"
    },
    "tool-search-events": {
      "code": "/**\n * @fileoverview The guts of the Event Search tool.\n */\nimport { executeTool } from \"./a2/step-executor\";\nimport { ok } from \"./a2/utils\";\nexport { invoke as default, describe };\nasync function invoke({ query }, caps) {\n    const executing = await executeTool(caps, \"google_search_activities.find_events\", {\n        query,\n    });\n    if (!ok(executing))\n        return executing;\n    return { results: executing };\n}\nasync function describe() {\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                query: {\n                    type: \"string\",\n                    title: \"Query\",\n                    description: \"The query to Local Event Search\",\n                },\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                results: {\n                    type: \"string\",\n                    title: \"Search Results\",\n                },\n            },\n        },\n    };\n}\n"
    },
    "tool-search-hotels": {
      "code": "/**\n * @fileoverview The guts of the Hotel Search tool.\n */\nimport { executeTool } from \"./a2/step-executor\";\nimport { ok } from \"./a2/utils\";\nexport { invoke as default, describe };\nasync function invoke({ query }, caps) {\n    const executing = await executeTool(caps, \"google_hotels.search\", {\n        query,\n    });\n    if (!ok(executing))\n        return executing;\n    return { results: executing };\n}\nasync function describe() {\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                query: {\n                    type: \"string\",\n                    title: \"Query\",\n                    description: \"The query to Hotel Search\",\n                },\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                results: {\n                    type: \"string\",\n                    title: \"Search Results\",\n                },\n            },\n        },\n    };\n}\n"
    },
    "tool-search-internal": {
      "code": "/**\n * @fileoverview The guts of the Internal Search tool.\n */\nimport { executeTool } from \"./a2/step-executor\";\nimport { ok } from \"./a2/utils\";\nexport { invoke as default, describe };\nasync function invoke({ query }, caps) {\n    const executing = await executeTool(caps, \"enterprise_search\", {\n        query,\n    });\n    if (!ok(executing))\n        return executing;\n    return { results: executing };\n}\nasync function describe() {\n    return {\n        title: \"Internal Search\",\n        description: \"Search using internal search engine.\",\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                query: {\n                    type: \"string\",\n                    title: \"Query\",\n                    description: \"The search query\",\n                },\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                results: {\n                    type: \"string\",\n                    title: \"Search Results\",\n                },\n            },\n        },\n    };\n}\n"
    },
    "tool-search-jobs": {
      "code": "/**\n * @fileoverview The guts of the Job Search tool.\n */\nimport { executeTool } from \"./a2/step-executor\";\nimport { ok } from \"./a2/utils\";\nexport { invoke as default, describe };\nasync function invoke({ query }, caps) {\n    const executing = await executeTool(caps, \"google_search_jobs.jobs\", {\n        query,\n    });\n    if (!ok(executing))\n        return executing;\n    return { results: executing };\n}\nasync function describe() {\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                query: {\n                    type: \"string\",\n                    title: \"Query\",\n                    description: \"The query to Job Search\",\n                },\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                results: {\n                    type: \"string\",\n                    title: \"Search Results\",\n                },\n            },\n        },\n    };\n}\n"
    },
    "tool-search-maps": {
      "code": "/**\n * @fileoverview The guts of the Search Maps tool.\n */\nimport { executeTool } from \"./a2/step-executor\";\nimport { ok } from \"./a2/utils\";\nexport { invoke as default, describe };\nfunction formatResults(query, results) {\n    // If the result is already in string format, not SearchMap results, return as is.\n    if (typeof results == \"string\") {\n        return `Search Query: ${query}\n## Google Places Search Results\n${results}\n    `;\n    }\n    return `Search Query: ${query}\n\n\n## Google Places Search Results\n\n${results.places\n        .map((place) => {\n        const title = place.websiteUri\n            ? `[${place.displayName.text}](${place.websiteUri})`\n            : place.displayName.text;\n        return `- ${title}\\n\n  ${place.editorialSummary?.text || \"\"} \n  Address: ${place.formattedAddress}\n  User Rating: ${place.rating} (${place.userRatingCount} reviews)\n  `;\n    })\n        .join(\"\\n\\n\")}\n`;\n}\nasync function invoke({ query }, caps) {\n    const executing = await executeTool(caps, \"map_search\", {\n        query,\n    });\n    if (!ok(executing))\n        return executing;\n    const results = formatResults(query, executing);\n    return { results };\n}\nasync function describe() {\n    return {\n        title: \"Get Webpage\",\n        description: \"Given a URL of a webpage, returns its content as Markdown with a list of links and other metadata.\",\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                query: {\n                    type: \"string\",\n                    title: \"Query\",\n                    description: \"Google Places API search query, typically formulated as [type of place] near [location]\",\n                },\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                results: {\n                    type: \"string\",\n                    title: \"Search Results\",\n                },\n            },\n        },\n    };\n}\n"
    },
    "tool-search-moma": {
      "code": "/**\n * @fileoverview The guts of the Moma Search tool.\n */\nimport { executeTool } from \"./a2/step-executor\";\nimport { ok } from \"./a2/utils\";\nexport { invoke as default, describe };\nasync function invoke({ query }, caps) {\n    const executing = await executeTool(caps, \"enterprise_search\", {\n        query,\n    });\n    if (!ok(executing))\n        return executing;\n    return { results: executing };\n}\nasync function describe() {\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                query: {\n                    type: \"string\",\n                    title: \"Query\",\n                    description: \"The search query\",\n                },\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                results: {\n                    type: \"string\",\n                    title: \"Search Results\",\n                },\n            },\n        },\n    };\n}\n"
    },
    "tool-search-web": {
      "code": "/**\n * @fileoverview The internal-only implementation of the Search Web tool.\n */\nimport { GeminiPrompt } from \"./a2/gemini-prompt\";\nimport { StreamableReporter } from \"./a2/output\";\nimport { executeTool } from \"./a2/step-executor\";\nimport { ToolManager } from \"./a2/tool-manager\";\nimport { ok, toText } from \"./a2/utils\";\nexport { invoke as default, describe };\nasync function generateSummary(caps, query, reporter) {\n    const toolManager = new ToolManager(caps);\n    toolManager.addSearch();\n    const result = await new GeminiPrompt(caps, {\n        body: {\n            contents: [{ parts: [{ text: query }] }],\n            tools: toolManager.list(),\n        },\n    }, toolManager).invoke();\n    if (!ok(result)) {\n        return result;\n    }\n    let results = toText(result.last);\n    await reporter.sendUpdate(\"Search Summary\", results, \"text_analysis\");\n    const links = result.candidate?.groundingMetadata?.groundingChunks?.map((chunk) => chunk.web);\n    if (links) {\n        await reporter.sendLinks(\"References\", links, \"link\");\n    }\n    const chunks = result.candidate?.groundingMetadata?.groundingChunks?.map((chunk) => {\n        const { title, uri } = chunk.web;\n        return `- [${title}](${uri})`;\n    }) || [];\n    if (chunks.length) {\n        results += `\\n## References:\\n${chunks.join(\"\\n\")}\\n`;\n    }\n    return `\\n## Summary\\n${results}`;\n}\nfunction formatBackendSearchResults(results) {\n    if (typeof results === \"string\") {\n        return results;\n    }\n    return `## Search Results\n\n    ${results\n        .map((result) => {\n        return `## Source: ${result.url}\nSource content:\n\n${result.webpage_text_content}\n`;\n    })\n        .join(\"\\n\\n\")}\n`;\n}\nasync function getSearchLinks(caps, query, reporter) {\n    const results = await executeTool(caps, \"google_search\", {\n        query,\n    });\n    if (!ok(results))\n        return results;\n    const formattedResults = formatBackendSearchResults(results);\n    await reporter.sendUpdate(\"Search Links\", formattedResults, \"link\");\n    return formattedResults;\n}\nasync function invoke({ query }, caps) {\n    const reporter = new StreamableReporter(caps, {\n        title: \"Searching Web\",\n        icon: \"search\",\n    });\n    try {\n        await reporter.start();\n        await reporter.sendUpdate(\"Search term\", query, \"search\");\n        const [summary, links] = await Promise.all([\n            generateSummary(caps, query, reporter),\n            getSearchLinks(caps, query, reporter),\n        ]);\n        if (!ok(summary)) {\n            return summary;\n        }\n        if (!ok(links)) {\n            return links;\n        }\n        return { results: `Query: ${query}\\n${summary}\\n${links}` };\n    }\n    finally {\n        reporter.close();\n    }\n}\nasync function describe() {\n    return {\n        title: \"Search Web\",\n        description: \"Given a query, searches the Web with Google Search.\",\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                query: {\n                    type: \"string\",\n                    title: \"Query\",\n                    description: \"The query to use with which to search the Web\",\n                },\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context out\",\n                },\n            },\n        },\n    };\n}\n"
    },
    "tool-search-wikipedia": {
      "code": "/**\n * @fileoverview Raw Search Wikipedia tool.\n */\nexport { invoke as default, describe };\nfunction searchURL(query) {\n    return `https://en.wikipedia.org/w/api.php?action=opensearch&search=${query}&origin=*`;\n}\nfunction pageQueryURL(page) {\n    return `https://en.wikipedia.org/w/api.php?action=query&format=json&prop=revisions%7Cextracts&titles=${page}&redirects=1&formatversion=2&rvlimit=1&explaintext=1&origin=*`;\n}\nasync function invoke({ query }, caps) {\n    if (!query) {\n        return { $error: \"No search query provided.\" };\n    }\n    const gettingTitles = await caps.fetch({\n        url: searchURL(query),\n        method: \"GET\",\n    });\n    if (\"$error\" in gettingTitles) {\n        return gettingTitles;\n    }\n    const response = gettingTitles.response;\n    const titles = response.at(3)?.map((item) => decodeURIComponent(item.slice(30))) || [];\n    if (!titles.length) {\n        return { $error: `No titles found` };\n    }\n    const extracts = await Promise.all(titles.map(async (title) => {\n        const gettingPage = (await caps.fetch({\n            url: pageQueryURL(title),\n            method: \"GET\",\n        }));\n        if (\"$error\" in gettingPage) {\n            return { $error: `Error getting page: ${title}` };\n        }\n        console.log(\"GETTING PAGE\", gettingPage.response);\n        const extract = gettingPage.response.query.pages.at(0)?.extract;\n        if (!extract) {\n            return { $error: `Error getting extract: ${title}` };\n        }\n        return extract;\n    }));\n    const errors = extracts.filter((item) => typeof item !== \"string\");\n    if (errors.length) {\n        return { $error: errors.join(\"\\n\\n\") };\n    }\n    return {\n        result: extracts,\n    };\n}\nasync function describe() {\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                query: {\n                    type: \"string\",\n                    title: \"Query\",\n                    description: \"The query to use for searching Wikipedia\",\n                },\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                result: {\n                    type: \"object\",\n                    title: \"Result\",\n                    description: \"Wikipedia Search Result\",\n                },\n            },\n        },\n    };\n}\n"
    },
    "tool-sql-query-internal": {
      "code": "/**\n * @fileoverview The guts of the internal SQL query tool.\n */\nimport { executeTool } from \"./a2/step-executor\";\nimport { ok } from \"./a2/utils\";\nexport { invoke as default, describe };\nasync function invoke({ query }, caps) {\n    const executing = await executeTool(caps, \"sql_query\", {\n        query,\n    });\n    if (!ok(executing))\n        return executing;\n    return { results: executing };\n}\nasync function describe() {\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                query: {\n                    type: \"string\",\n                    title: \"Query\",\n                    description: \"The SQL query to execute\",\n                },\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                results: {\n                    type: \"string\",\n                    title: \"Query Results\",\n                },\n            },\n        },\n    };\n}\n"
    }
  },
  "exports": [
    "#module:get-weather",
    "#module:search-web",
    "#module:get-webpage",
    "#module:search-maps",
    "#module:search-internal",
    "#module:code-execution"
  ]
}