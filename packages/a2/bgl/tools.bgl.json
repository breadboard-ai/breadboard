{
  "title": "Tools",
  "description": "A collection of useful tools.",
  "version": "0.0.1",
  "nodes": [],
  "edges": [],
  "imports": {
    "a2": {
      "url": "./a2.bgl.json"
    }
  },
  "metadata": {
    "comments": [
      {
        "id": "comment-6fc8b597",
        "text": "Intentionally Left Blank",
        "metadata": {
          "visual": {
            "x": 7,
            "y": -575,
            "collapsed": "expanded",
            "outputHeight": 0
          }
        }
      }
    ],
    "visual": {
      "presentation": {
        "themes": {
          "f90eb9c1-e12c-4864-ba74-a15a3b8d77f3": {
            "themeColors": {
              "primaryColor": "#246db5",
              "secondaryColor": "#5cadff",
              "backgroundColor": "#ffffff",
              "textColor": "#1a1a1a",
              "primaryTextColor": "#ffffff"
            },
            "template": "basic",
            "splashScreen": {
              "storedData": {
                "handle": "/images/app/generic-flow.jpg",
                "mimeType": "image/jpeg"
              }
            }
          }
        },
        "theme": "f90eb9c1-e12c-4864-ba74-a15a3b8d77f3"
      }
    },
    "tags": [
      "published",
      "tool",
      "component"
    ]
  },
  "modules": {
    "search-web": {
      "code": "/**\n * @fileoverview Given a query, searches the Web with Google Search.\n */\nimport gemini, {} from \"./a2/gemini\";\nimport { Template } from \"./a2/template\";\nimport { ToolManager } from \"./a2/tool-manager\";\nimport { GeminiPrompt } from \"./a2/gemini-prompt\";\nimport { ok, err, toText, toTextConcat, toLLMContent, addUserTurn, defaultLLMContent, } from \"./a2/utils\";\nimport { ListExpander } from \"./a2/lists\";\nimport toolSearchWeb, { describe as toolSearchWebDescribe, } from \"./tool-search-web\";\nimport fetch from \"@fetch\";\nexport { invoke as default, describe };\nasync function resolveInput(inputContent) {\n    const template = new Template(inputContent);\n    const substituting = await template.substitute({}, async () => \"\");\n    if (!ok(substituting)) {\n        return toLLMContent(substituting.$error);\n    }\n    return substituting;\n}\nfunction extractQuery(maybeMarkdownListItem) {\n    if (maybeMarkdownListItem.startsWith(\"* \")) {\n        return maybeMarkdownListItem.replace(\"* \", \"\");\n    }\n    return maybeMarkdownListItem;\n}\nasync function invoke(inputs) {\n    let query;\n    let mode;\n    if (\"context\" in inputs) {\n        mode = \"step\";\n        const last = inputs.context?.at(-1);\n        if (inputs.context) {\n            query = inputs.context;\n        }\n        else {\n            return err(\"Please provide a URL\");\n        }\n    }\n    else if (\"p-query\" in inputs) {\n        const queryContent = await resolveInput(inputs[\"p-query\"]);\n        if (!ok(queryContent)) {\n            return queryContent;\n        }\n        query = [queryContent];\n        mode = \"step\";\n    }\n    else {\n        query = [toLLMContent(inputs.query)];\n        mode = \"tool\";\n    }\n    const searchResults = await new ListExpander(toLLMContent(defaultLLMContent()), query).map(async (_, itemContext) => {\n        let queryString = extractQuery(toText(itemContext));\n        queryString = (queryString || \"\").trim();\n        if (!queryString) {\n            return err(\"Please provide a query\");\n        }\n        console.log(\"Query: \", queryString);\n        const getting = await toolSearchWeb({ query: queryString });\n        if (!ok(getting)) {\n            return toLLMContent(getting.$error);\n        }\n        return toLLMContent(getting.results);\n    });\n    if (!ok(searchResults)) {\n        return searchResults;\n    }\n    if (mode === \"step\") {\n        return {\n            context: searchResults,\n        };\n    }\n    return { results: toTextConcat(searchResults) };\n}\nasync function describe({ asType, ...inputs }) {\n    const isTool = inputs && Object.keys(inputs).length === 1;\n    if (isTool) {\n        return toolSearchWebDescribe();\n    }\n    const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n    const query = hasWires\n        ? {}\n        : {\n            \"p-query\": {\n                type: \"object\",\n                title: \"Search query\",\n                description: \"Please provide a search query\",\n                behavior: [\n                    \"llm-content\",\n                    \"config\",\n                    \"hint-preview\",\n                    \"hint-single-line\",\n                ],\n                default: defaultLLMContent(),\n            },\n        };\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: {\n                        type: \"object\",\n                        behavior: [\"llm-content\"],\n                    },\n                    title: \"Context in\",\n                    behavior: [\"main-port\"],\n                },\n                ...query,\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context out\",\n                    behavior: [\"main-port\"],\n                },\n            },\n        },\n        metadata: {\n            icon: \"search\",\n            tags: [\"quick-access\", \"tool\", \"component\"],\n            order: 1,\n        },\n    };\n}\n",
      "metadata": {
        "title": "Search Web",
        "source": {
          "code": "/**\n * @fileoverview Given a query, searches the Web with Google Search.\n */\n\nimport gemini, { type GeminiInputs } from \"./a2/gemini\";\nimport { Template } from \"./a2/template\";\nimport { ToolManager } from \"./a2/tool-manager\";\nimport { GeminiPrompt } from \"./a2/gemini-prompt\";\nimport {\n  ok,\n  err,\n  toText,\n  toTextConcat,\n  toLLMContent,\n  addUserTurn,\n  defaultLLMContent,\n} from \"./a2/utils\";\nimport { ListExpander } from \"./a2/lists\";\nimport toolSearchWeb, {\n  type SearchWebOutputs,\n  describe as toolSearchWebDescribe,\n} from \"./tool-search-web\";\n\nimport fetch from \"@fetch\";\n\nexport { invoke as default, describe };\n\ntype Inputs =\n  | {\n      context?: LLMContent[];\n      \"p-query\": LLMContent;\n    }\n  | {\n      query: string;\n    };\n\ntype Outputs =\n  | {\n      context: LLMContent[];\n    }\n  | SearchWebOutputs;\n\nasync function resolveInput(inputContent: LLMContent): Promise<LLMContent> {\n  const template = new Template(inputContent);\n  const substituting = await template.substitute({}, async () => \"\");\n  if (!ok(substituting)) {\n    return toLLMContent(substituting.$error);\n  }\n  return substituting;\n}\n\nfunction extractQuery(maybeMarkdownListItem: string): string {\n  if (maybeMarkdownListItem.startsWith(\"* \")) {\n    return maybeMarkdownListItem.replace(\"* \", \"\");\n  }\n  return maybeMarkdownListItem;\n}\n\nasync function invoke(inputs: Inputs): Promise<Outcome<Outputs>> {\n  let query: LLMContent[];\n  let mode: \"step\" | \"tool\";\n  if (\"context\" in inputs) {\n    mode = \"step\";\n    const last = inputs.context?.at(-1);\n    if (inputs.context) {\n      query = inputs.context;\n    } else {\n      return err(\"Please provide a URL\");\n    }\n  } else if (\"p-query\" in inputs) {\n    const queryContent = await resolveInput(inputs[\"p-query\"]);\n    if (!ok(queryContent)) {\n      return queryContent;\n    }\n    query = [queryContent];\n    mode = \"step\";\n  } else {\n    query = [toLLMContent(inputs.query)];\n    mode = \"tool\";\n  }\n\n  const searchResults = await new ListExpander(\n    toLLMContent(defaultLLMContent()),\n    query\n  ).map(async (_, itemContext) => {\n    let queryString = extractQuery(toText(itemContext));\n    queryString = (queryString || \"\").trim();\n    if (!queryString) {\n      return err(\"Please provide a query\");\n    }\n    console.log(\"Query: \", queryString);\n    const getting = await toolSearchWeb({ query: queryString });\n    if (!ok(getting)) {\n      return toLLMContent(getting.$error);\n    }\n    return toLLMContent(getting.results);\n  });\n  if (!ok(searchResults)) {\n    return searchResults;\n  }\n  if (mode === \"step\") {\n    return {\n      context: searchResults,\n    };\n  }\n  return { results: toTextConcat(searchResults) };\n}\n\nexport type DescribeInputs = {\n  inputs: Inputs;\n  inputSchema: Schema;\n  asType?: boolean;\n};\n\nasync function describe({ asType, ...inputs }: DescribeInputs) {\n  const isTool = inputs && Object.keys(inputs).length === 1;\n  if (isTool) {\n    return toolSearchWebDescribe();\n  }\n  const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n  const query: Schema[\"properties\"] = hasWires\n    ? {}\n    : {\n        \"p-query\": {\n          type: \"object\",\n          title: \"Search query\",\n          description: \"Please provide a search query\",\n          behavior: [\n            \"llm-content\",\n            \"config\",\n            \"hint-preview\",\n            \"hint-single-line\",\n          ],\n          default: defaultLLMContent(),\n        },\n      };\n\n  return {\n    inputSchema: {\n      type: \"object\",\n      properties: {\n        context: {\n          type: \"array\",\n          items: {\n            type: \"object\",\n            behavior: [\"llm-content\"],\n          },\n          title: \"Context in\",\n          behavior: [\"main-port\"],\n        },\n        ...query,\n      },\n    } satisfies Schema,\n    outputSchema: {\n      type: \"object\",\n      properties: {\n        context: {\n          type: \"array\",\n          items: { type: \"object\", behavior: [\"llm-content\"] },\n          title: \"Context out\",\n          behavior: [\"main-port\"],\n        },\n      },\n    } satisfies Schema,\n    metadata: {\n      icon: \"search\",\n      tags: [\"quick-access\", \"tool\", \"component\"],\n      order: 1,\n    },\n  };\n}\n",
          "language": "typescript"
        },
        "description": "Given a query, searches the Web with Google Search.",
        "runnable": false
      }
    },
    "search-maps": {
      "code": "/**\n * @fileoverview Search for location information.\n */\nimport toolSearchMaps, { describe as toolSearchMapsDescribe, } from \"./tool-search-maps\";\nimport { Template } from \"./a2/template\";\nimport { err, ok, toText, toLLMContent, defaultLLMContent } from \"./a2/utils\";\nexport { invoke as default, describe };\nasync function resolveInput(inputContent) {\n    const template = new Template(inputContent);\n    const substituting = await template.substitute({}, async () => \"\");\n    if (!ok(substituting)) {\n        return substituting.$error;\n    }\n    return toText(substituting);\n}\nasync function invoke(inputs) {\n    console.log(\"MAPS INPUTS\", inputs);\n    let query;\n    let mode;\n    if (\"context\" in inputs) {\n        mode = \"step\";\n        const last = inputs.context?.at(-1);\n        if (last) {\n            query = toText(last);\n        }\n        else {\n            return err(\"Please provide a query\");\n        }\n    }\n    else if (\"p-query\" in inputs) {\n        query = await resolveInput(inputs[\"p-query\"]);\n        mode = \"step\";\n    }\n    else {\n        query = inputs.query;\n        mode = \"tool\";\n    }\n    query = (query || \"\").trim();\n    if (!query) {\n        return err(\"Please provide a query\");\n    }\n    console.log(\"Query: \" + query);\n    const searchMapsResults = await toolSearchMaps({ query });\n    if (!ok(searchMapsResults)) {\n        return searchMapsResults;\n    }\n    const results = searchMapsResults.results;\n    if (mode === \"step\") {\n        return {\n            context: [toLLMContent(results)],\n        };\n    }\n    return { results };\n}\nasync function describe({ asType, ...inputs }) {\n    const isTool = inputs && Object.keys(inputs).length === 1;\n    if (isTool) {\n        return toolSearchMapsDescribe();\n    }\n    const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n    const query = hasWires\n        ? {}\n        : {\n            \"p-query\": {\n                type: \"object\",\n                title: \"Search query\",\n                description: \"Please provide a search query\",\n                behavior: [\n                    \"llm-content\",\n                    \"config\",\n                    \"hint-preview\",\n                    \"hint-single-line\",\n                ],\n                default: defaultLLMContent(),\n            },\n        };\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context in\",\n                    behavior: [\"main-port\"],\n                },\n                ...query,\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context out\",\n                    behavior: [\"main-port\"],\n                },\n            },\n        },\n        metadata: {\n            icon: \"map-search\",\n            tags: [\"quick-access\", \"tool\", \"component\"],\n            order: 2,\n        },\n    };\n}\n",
      "metadata": {
        "title": "Search Maps",
        "source": {
          "code": "/**\n * @fileoverview Search for location information.\n */\n\nimport toolSearchMaps, {\n  type SearchMapsOutputs,\n  describe as toolSearchMapsDescribe,\n} from \"./tool-search-maps\";\nimport { Template } from \"./a2/template\";\nimport { err, ok, toText, toLLMContent, defaultLLMContent } from \"./a2/utils\";\nexport { invoke as default, describe };\n\ntype Inputs =\n  | {\n      context?: LLMContent[];\n      \"p-query\": LLMContent;\n    }\n  | {\n      query: string;\n    };\n\ntype Outputs =\n  | {\n      context: LLMContent[];\n    }\n  | {\n      results: string;\n    };\n\nasync function resolveInput(inputContent: LLMContent): Promise<string> {\n  const template = new Template(inputContent);\n  const substituting = await template.substitute({}, async () => \"\");\n  if (!ok(substituting)) {\n    return substituting.$error;\n  }\n  return toText(substituting);\n}\n\nasync function invoke(inputs: Inputs): Promise<Outcome<Outputs>> {\n  console.log(\"MAPS INPUTS\", inputs);\n  let query: string;\n  let mode: \"step\" | \"tool\";\n  if (\"context\" in inputs) {\n    mode = \"step\";\n    const last = inputs.context?.at(-1);\n    if (last) {\n      query = toText(last);\n    } else {\n      return err(\"Please provide a query\");\n    }\n  } else if (\"p-query\" in inputs) {\n    query = await resolveInput(inputs[\"p-query\"]);\n    mode = \"step\";\n  } else {\n    query = inputs.query;\n    mode = \"tool\";\n  }\n  query = (query || \"\").trim();\n  if (!query) {\n    return err(\"Please provide a query\");\n  }\n\n  console.log(\"Query: \" + query);\n  const searchMapsResults = await toolSearchMaps({ query });\n  if (!ok(searchMapsResults)) {\n    return searchMapsResults;\n  }\n  const results = searchMapsResults.results;\n  if (mode === \"step\") {\n    return {\n      context: [toLLMContent(results)],\n    };\n  }\n  return { results };\n}\n\nexport type DescribeInputs = {\n  inputs: Inputs;\n  inputSchema: Schema;\n  asType?: boolean;\n};\n\nasync function describe({ asType, ...inputs }: DescribeInputs) {\n  const isTool = inputs && Object.keys(inputs).length === 1;\n  if (isTool) {\n    return toolSearchMapsDescribe();\n  }\n  const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n  const query: Schema[\"properties\"] = hasWires\n    ? {}\n    : {\n        \"p-query\": {\n          type: \"object\",\n          title: \"Search query\",\n          description: \"Please provide a search query\",\n          behavior: [\n            \"llm-content\",\n            \"config\",\n            \"hint-preview\",\n            \"hint-single-line\",\n          ],\n          default: defaultLLMContent(),\n        },\n      };\n\n  return {\n    inputSchema: {\n      type: \"object\",\n      properties: {\n        context: {\n          type: \"array\",\n          items: { type: \"object\", behavior: [\"llm-content\"] },\n          title: \"Context in\",\n          behavior: [\"main-port\"],\n        },\n        ...query,\n      },\n    } satisfies Schema,\n    outputSchema: {\n      type: \"object\",\n      properties: {\n        context: {\n          type: \"array\",\n          items: { type: \"object\", behavior: [\"llm-content\"] },\n          title: \"Context out\",\n          behavior: [\"main-port\"],\n        },\n      },\n    } satisfies Schema,\n\n    metadata: {\n      icon: \"map-search\",\n      tags: [\"quick-access\", \"tool\", \"component\"],\n      order: 2,\n    },\n  };\n}\n",
          "language": "typescript"
        },
        "description": "Search for location information.",
        "runnable": false
      }
    },
    "search-enterprise": {
      "code": "/**\n * @fileoverview Search an enterprise search engine.\n */\nimport toolSearchEnterprise, { describe as toolSearchEnterpriseDescribe, } from \"./tool-search-enterprise\";\nimport { Template } from \"./a2/template\";\nimport { err, ok, toText, toLLMContent, defaultLLMContent } from \"./a2/utils\";\nexport { invoke as default, describe };\nasync function resolveInput(inputContent) {\n    const template = new Template(inputContent);\n    const substituting = await template.substitute({}, async () => \"\");\n    if (!ok(substituting)) {\n        return substituting.$error;\n    }\n    return toText(substituting);\n}\nasync function invoke(inputs) {\n    console.log(\"ENTERPRISE SEARCH INPUTS\", inputs);\n    let query;\n    let search_engine_resource_name;\n    let mode;\n    if (\"context\" in inputs) {\n        mode = \"step\";\n        const last = inputs.context?.at(-1);\n        if (last) {\n            query = toText(last);\n        }\n        else {\n            return err(\"Please provide a query\");\n        }\n    }\n    else if (\"p-query\" in inputs) {\n        query = await resolveInput(inputs[\"p-query\"]);\n        mode = \"step\";\n    }\n    else {\n        query = inputs.query;\n        search_engine_resource_name = inputs.search_engine_resource_name;\n        mode = \"tool\";\n    }\n    query = (query || \"\").trim();\n    if (!query) {\n        return err(\"Please provide a query\");\n    }\n    if (search_engine_resource_name === undefined) {\n        search_engine_resource_name = \"\";\n    }\n    console.log(\"Query: \" + query);\n    const searchResults = await toolSearchEnterprise({\n        query,\n        search_engine_resource_name,\n    });\n    if (!ok(searchResults)) {\n        return searchResults;\n    }\n    const results = searchResults.results;\n    if (mode === \"step\") {\n        return {\n            context: [toLLMContent(results)],\n        };\n    }\n    return { results };\n}\nasync function describe({ asType, ...inputs }) {\n    const isTool = inputs && Object.keys(inputs).length === 1;\n    if (isTool) {\n        return toolSearchEnterpriseDescribe();\n    }\n    const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n    const query = hasWires\n        ? {}\n        : {\n            \"p-query\": {\n                type: \"object\",\n                title: \"Search query\",\n                description: \"Please provide a search query\",\n                behavior: [\n                    \"llm-content\",\n                    \"config\",\n                    \"hint-preview\",\n                    \"hint-single-line\",\n                ],\n                default: defaultLLMContent(),\n            },\n        };\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context in\",\n                    behavior: [\"main-port\"],\n                },\n                ...query,\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context out\",\n                    behavior: [\"main-port\"],\n                },\n            },\n        },\n        metadata: {\n            icon: \"web-search\",\n            tags: [\"quick-access\", \"tool\", \"component\"],\n            order: 2,\n        },\n    };\n}\n",
      "metadata": {
        "title": "Search Enterprise",
        "source": {
          "code": "/**\n * @fileoverview Search an enterprise search engine.\n */\n\nimport toolSearchEnterprise, {\n  describe as toolSearchEnterpriseDescribe,\n} from \"./tool-search-enterprise\";\nimport { Template } from \"./a2/template\";\nimport { err, ok, toText, toLLMContent, defaultLLMContent } from \"./a2/utils\";\nexport { invoke as default, describe };\n\ntype Inputs =\n  | {\n      context?: LLMContent[];\n      \"p-query\": LLMContent;\n    }\n  | {\n      query: string;\n      search_engine_resource_name?: string;\n    };\n\ntype Outputs =\n  | {\n      context: LLMContent[];\n    }\n  | {\n      results: string;\n    };\n\nasync function resolveInput(inputContent: LLMContent): Promise<string> {\n  const template = new Template(inputContent);\n  const substituting = await template.substitute({}, async () => \"\");\n  if (!ok(substituting)) {\n    return substituting.$error;\n  }\n  return toText(substituting);\n}\n\nasync function invoke(inputs: Inputs): Promise<Outcome<Outputs>> {\n  console.log(\"ENTERPRISE SEARCH INPUTS\", inputs);\n  let query: string;\n  let search_engine_resource_name: string | undefined;\n  let mode: \"step\" | \"tool\";\n  if (\"context\" in inputs) {\n    mode = \"step\";\n    const last = inputs.context?.at(-1);\n    if (last) {\n      query = toText(last);\n    } else {\n      return err(\"Please provide a query\");\n    }\n  } else if (\"p-query\" in inputs) {\n    query = await resolveInput(inputs[\"p-query\"]);\n    mode = \"step\";\n  } else {\n    query = inputs.query;\n    search_engine_resource_name = inputs.search_engine_resource_name;\n    mode = \"tool\";\n  }\n  query = (query || \"\").trim();\n  if (!query) {\n    return err(\"Please provide a query\");\n  }\n  if (search_engine_resource_name === undefined) {\n    search_engine_resource_name = \"\";\n  }\n  console.log(\"Query: \" + query);\n  const searchResults = await toolSearchEnterprise({\n    query,\n    search_engine_resource_name,\n  });\n  if (!ok(searchResults)) {\n    return searchResults;\n  }\n  const results = searchResults.results;\n  if (mode === \"step\") {\n    return {\n      context: [toLLMContent(results)],\n    };\n  }\n  return { results };\n}\n\nexport type DescribeInputs = {\n  inputs: Inputs;\n  inputSchema: Schema;\n  asType?: boolean;\n};\n\nasync function describe({ asType, ...inputs }: DescribeInputs) {\n  const isTool = inputs && Object.keys(inputs).length === 1;\n  if (isTool) {\n    return toolSearchEnterpriseDescribe();\n  }\n  const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n  const query: Schema[\"properties\"] = hasWires\n    ? {}\n    : {\n        \"p-query\": {\n          type: \"object\",\n          title: \"Search query\",\n          description: \"Please provide a search query\",\n          behavior: [\n            \"llm-content\",\n            \"config\",\n            \"hint-preview\",\n            \"hint-single-line\",\n          ],\n          default: defaultLLMContent(),\n        },\n      };\n\n  return {\n    inputSchema: {\n      type: \"object\",\n      properties: {\n        context: {\n          type: \"array\",\n          items: { type: \"object\", behavior: [\"llm-content\"] },\n          title: \"Context in\",\n          behavior: [\"main-port\"],\n        },\n        ...query,\n      },\n    } satisfies Schema,\n    outputSchema: {\n      type: \"object\",\n      properties: {\n        context: {\n          type: \"array\",\n          items: { type: \"object\", behavior: [\"llm-content\"] },\n          title: \"Context out\",\n          behavior: [\"main-port\"],\n        },\n      },\n    } satisfies Schema,\n\n    metadata: {\n      icon: \"web-search\",\n      tags: [\"quick-access\", \"tool\", \"component\"],\n      order: 2,\n    },\n  };\n}\n",
          "language": "typescript"
        },
        "description": "Search an enterprise search engine.",
        "runnable": false
      }
    },
    "get-webpage": {
      "code": "/**\n * @fileoverview Given a URL of a webpage, returns its content as Markdown with a list of links and other metadata.\n */\nimport toolGetWebpage, { describe as toolGetWebpageDescribe, } from \"./tool-get-webpage\";\nimport { Template } from \"./a2/template\";\nimport { ok, err, toText, toLLMContent, defaultLLMContent, toTextConcat, } from \"./a2/utils\";\nimport { ListExpander } from \"./a2/lists\";\nexport { invoke as default, describe };\nasync function resolveInput(inputContent) {\n    const template = new Template(inputContent);\n    const substituting = await template.substitute({}, async () => \"\");\n    if (!ok(substituting)) {\n        return toLLMContent(substituting.$error);\n    }\n    return substituting;\n}\nfunction extractURL(maybeMarkdownLink) {\n    // Sometimes Listification returns URLS in markdown format.\n    const singleRegex = /\\[.*?\\]\\(([^)]+)\\)/;\n    const match = maybeMarkdownLink.match(singleRegex);\n    if (match && match[1]) {\n        // match[1] is the content of the first capturing group (the URL)\n        const url = match[1];\n        return url;\n    }\n    return maybeMarkdownLink;\n}\nasync function invoke(inputs) {\n    let urlContext = [];\n    let mode;\n    if (\"context\" in inputs) {\n        mode = \"step\";\n        if (inputs.context) {\n            urlContext = inputs.context;\n        }\n        else {\n            return err(\"Please provide a URL\");\n        }\n    }\n    else if (\"p-url\" in inputs) {\n        const urlContent = await resolveInput(inputs[\"p-url\"]);\n        if (!ok(urlContent)) {\n            return urlContent;\n        }\n        urlContext = [urlContent];\n        mode = \"step\";\n    }\n    else {\n        urlContext = [toLLMContent(inputs.url)];\n        mode = \"tool\";\n    }\n    console.log(\"urlContext\");\n    console.log(urlContext);\n    const results = await new ListExpander(toLLMContent(defaultLLMContent()), urlContext).map(async (_, itemContext) => {\n        console.log(\"itemContext\");\n        console.log(itemContext);\n        let urlString = extractURL(toText(itemContext));\n        urlString = (urlString || \"\").trim();\n        if (!urlString) {\n            return err(\"Please provide a URL\");\n        }\n        console.log(\"URL: \", urlString);\n        const getting = await toolGetWebpage({ url: urlString });\n        if (!ok(getting)) {\n            return toLLMContent(getting.$error);\n        }\n        return toLLMContent(getting.results);\n    });\n    if (!ok(results)) {\n        return results;\n    }\n    if (mode == \"step\") {\n        return {\n            context: results,\n        };\n    }\n    return { results: toTextConcat(results) };\n}\nasync function describe({ asType, ...inputs }) {\n    const isTool = inputs && Object.keys(inputs).length === 1;\n    if (isTool) {\n        return toolGetWebpageDescribe();\n    }\n    const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n    const query = hasWires\n        ? {}\n        : {\n            \"p-url\": {\n                type: \"object\",\n                title: \"URL\",\n                description: \"Please provide URL of the webpage\",\n                behavior: [\n                    \"llm-content\",\n                    \"config\",\n                    \"hint-preview\",\n                    \"hint-single-line\",\n                ],\n                default: defaultLLMContent(),\n            },\n        };\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context in\",\n                    behavior: [\"main-port\"],\n                },\n                ...query,\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context out\",\n                    behavior: [\"main-port\"],\n                },\n            },\n        },\n        metadata: {\n            icon: \"language\",\n            tags: [\"quick-access\", \"tool\", \"component\"],\n            order: 4,\n        },\n    };\n}\n",
      "metadata": {
        "title": "Get Webpage",
        "source": {
          "code": "/**\n * @fileoverview Given a URL of a webpage, returns its content as Markdown with a list of links and other metadata.\n */\n\nimport toolGetWebpage, {\n  describe as toolGetWebpageDescribe,\n} from \"./tool-get-webpage\";\nimport { Template } from \"./a2/template\";\nimport {\n  ok,\n  err,\n  toText,\n  toLLMContent,\n  defaultLLMContent,\n  toTextConcat,\n} from \"./a2/utils\";\nimport { ListExpander } from \"./a2/lists\";\n\nexport { invoke as default, describe };\n\nexport type GetWebPageInputs = {\n  url: string;\n};\n\nexport type GetWebPageOutputs = {\n  results: string;\n};\n\nasync function resolveInput(inputContent: LLMContent): Promise<LLMContent> {\n  const template = new Template(inputContent);\n  const substituting = await template.substitute({}, async () => \"\");\n  if (!ok(substituting)) {\n    return toLLMContent(substituting.$error);\n  }\n  return substituting;\n}\n\ntype Inputs =\n  | {\n      context?: LLMContent[];\n      \"p-url\": LLMContent;\n    }\n  | GetWebPageInputs;\n\ntype Outputs =\n  | {\n      context: LLMContent[];\n    }\n  | GetWebPageOutputs;\n\nfunction extractURL(maybeMarkdownLink: string): string {\n  // Sometimes Listification returns URLS in markdown format.\n  const singleRegex: RegExp = /\\[.*?\\]\\(([^)]+)\\)/;\n  const match: RegExpMatchArray | null = maybeMarkdownLink.match(singleRegex);\n\n  if (match && match[1]) {\n    // match[1] is the content of the first capturing group (the URL)\n    const url: string = match[1];\n    return url;\n  }\n  return maybeMarkdownLink;\n}\n\nasync function invoke(inputs: Inputs): Promise<Outcome<Outputs>> {\n  let urlContext: LLMContent[] = [];\n  let mode: \"step\" | \"tool\";\n  if (\"context\" in inputs) {\n    mode = \"step\";\n    if (inputs.context) {\n      urlContext = inputs.context;\n    } else {\n      return err(\"Please provide a URL\");\n    }\n  } else if (\"p-url\" in inputs) {\n    const urlContent = await resolveInput(inputs[\"p-url\"]);\n    if (!ok(urlContent)) {\n      return urlContent;\n    }\n    urlContext = [urlContent];\n    mode = \"step\";\n  } else {\n    urlContext = [toLLMContent(inputs.url)];\n    mode = \"tool\";\n  }\n  console.log(\"urlContext\");\n  console.log(urlContext);\n  const results = await new ListExpander(\n    toLLMContent(defaultLLMContent()),\n    urlContext\n  ).map(async (_, itemContext) => {\n    console.log(\"itemContext\");\n    console.log(itemContext);\n    let urlString = extractURL(toText(itemContext));\n    urlString = (urlString || \"\").trim();\n    if (!urlString) {\n      return err(\"Please provide a URL\");\n    }\n    console.log(\"URL: \", urlString);\n    const getting = await toolGetWebpage({ url: urlString });\n    if (!ok(getting)) {\n      return toLLMContent(getting.$error);\n    }\n    return toLLMContent(getting.results);\n  });\n\n  if (!ok(results)) {\n    return results;\n  }\n  if (mode == \"step\") {\n    return {\n      context: results,\n    };\n  }\n  return { results: toTextConcat(results) };\n}\n\nexport type DescribeInputs = {\n  inputs: Inputs;\n  inputSchema: Schema;\n  asType?: boolean;\n};\nasync function describe({ asType, ...inputs }: DescribeInputs) {\n  const isTool = inputs && Object.keys(inputs).length === 1;\n  if (isTool) {\n    return toolGetWebpageDescribe();\n  }\n  const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n  const query: Schema[\"properties\"] = hasWires\n    ? {}\n    : {\n        \"p-url\": {\n          type: \"object\",\n          title: \"URL\",\n          description: \"Please provide URL of the webpage\",\n          behavior: [\n            \"llm-content\",\n            \"config\",\n            \"hint-preview\",\n            \"hint-single-line\",\n          ],\n          default: defaultLLMContent(),\n        },\n      };\n\n  return {\n    inputSchema: {\n      type: \"object\",\n      properties: {\n        context: {\n          type: \"array\",\n          items: { type: \"object\", behavior: [\"llm-content\"] },\n          title: \"Context in\",\n          behavior: [\"main-port\"],\n        },\n        ...query,\n      },\n    } satisfies Schema,\n    outputSchema: {\n      type: \"object\",\n      properties: {\n        context: {\n          type: \"array\",\n          items: { type: \"object\", behavior: [\"llm-content\"] },\n          title: \"Context out\",\n          behavior: [\"main-port\"],\n        },\n      },\n    } satisfies Schema,\n\n    metadata: {\n      icon: \"language\",\n      tags: [\"quick-access\", \"tool\", \"component\"],\n      order: 4,\n    },\n  };\n}\n",
          "language": "typescript"
        },
        "description": "Given a URL of a webpage, returns its content as Markdown with a list of links and other metadata.",
        "runnable": false
      }
    },
    "search-wikipedia": {
      "code": "/**\n * @fileoverview Given a query, searches Wikipedia.\n */\nimport searchWikipedia, { describe as searchWikipediaDescriber, } from \"./tool-search-wikipedia\";\nimport { Template } from \"./a2/template\";\nimport { ok, err, toText, toLLMContent, defaultLLMContent } from \"./a2/utils\";\nexport { invoke as default, describe };\nasync function resolveInput(inputContent) {\n    const template = new Template(inputContent);\n    const substituting = await template.substitute({}, async () => \"\");\n    if (!ok(substituting)) {\n        return substituting.$error;\n    }\n    return toText(substituting);\n}\nasync function invoke(inputs) {\n    let query;\n    let mode;\n    if (\"context\" in inputs) {\n        mode = \"step\";\n        const last = inputs.context?.at(-1);\n        if (last) {\n            query = toText(last);\n        }\n        else {\n            return err(\"Please provide a query\");\n        }\n    }\n    else if (\"p-query\" in inputs) {\n        query = await resolveInput(inputs[\"p-query\"]);\n        mode = \"step\";\n    }\n    else {\n        query = inputs.query;\n        mode = \"tool\";\n    }\n    query = (query || \"\").trim();\n    if (!query) {\n        return err(\"Please provide a query\");\n    }\n    console.log(\"Query: \" + query);\n    const result = await searchWikipedia({ query });\n    if (!ok(result)) {\n        return result;\n    }\n    if (mode == \"step\") {\n        return {\n            context: [\n                toLLMContent(`Query: ${query}\\n\\n Search Results: \\n\\n\\`\\`\\`json\\n${JSON.stringify(result, null, 2)}\\n\\`\\`\\``),\n            ],\n        };\n    }\n    else {\n        return result;\n    }\n    return { context: [] };\n}\nasync function describe({ asType, ...inputs }) {\n    const isTool = inputs && Object.keys(inputs).length === 1;\n    if (isTool) {\n        return searchWikipediaDescriber();\n    }\n    const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n    const query = hasWires\n        ? {}\n        : {\n            \"p-query\": {\n                type: \"object\",\n                title: \"Query\",\n                description: \"Please provide the query with which to search Wikipedia\",\n                behavior: [\n                    \"llm-content\",\n                    \"config\",\n                    \"hint-preview\",\n                    \"hint-single-line\",\n                ],\n                default: defaultLLMContent(),\n            },\n        };\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context in\",\n                    behavior: [\"main-port\"],\n                },\n                ...query,\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context out\",\n                    behavior: [\"main-port\"],\n                },\n            },\n        },\n        metadata: {\n            icon: \"globe-book\",\n            tags: [\"quick-access\", \"tool\", \"component\"],\n            order: 3,\n        },\n    };\n}\n",
      "metadata": {
        "title": "Search Wikipedia",
        "source": {
          "code": "/**\n * @fileoverview Given a query, searches Wikipedia.\n */\n\nimport searchWikipedia, {\n  describe as searchWikipediaDescriber,\n  type WikipediaInputs,\n  type WikipediaOutputs,\n} from \"./tool-search-wikipedia\";\nimport { Template } from \"./a2/template\";\n\nimport { ok, err, toText, toLLMContent, defaultLLMContent } from \"./a2/utils\";\n\nexport { invoke as default, describe };\n\nasync function resolveInput(inputContent: LLMContent): Promise<string> {\n  const template = new Template(inputContent);\n  const substituting = await template.substitute({}, async () => \"\");\n  if (!ok(substituting)) {\n    return substituting.$error;\n  }\n  return toText(substituting);\n}\n\ntype Inputs =\n  | {\n      context?: LLMContent[];\n      \"p-query\": LLMContent;\n    }\n  | WikipediaInputs;\n\ntype Outputs =\n  | {\n      context: LLMContent[];\n    }\n  | WikipediaOutputs;\n\nasync function invoke(inputs: Inputs): Promise<Outcome<Outputs>> {\n  let query: string;\n  let mode: \"step\" | \"tool\";\n  if (\"context\" in inputs) {\n    mode = \"step\";\n    const last = inputs.context?.at(-1);\n    if (last) {\n      query = toText(last);\n    } else {\n      return err(\"Please provide a query\");\n    }\n  } else if (\"p-query\" in inputs) {\n    query = await resolveInput(inputs[\"p-query\"]);\n    mode = \"step\";\n  } else {\n    query = inputs.query;\n    mode = \"tool\";\n  }\n  query = (query || \"\").trim();\n  if (!query) {\n    return err(\"Please provide a query\");\n  }\n\n  console.log(\"Query: \" + query);\n  const result = await searchWikipedia({ query });\n  if (!ok(result)) {\n    return result;\n  }\n  if (mode == \"step\") {\n    return {\n      context: [\n        toLLMContent(\n          `Query: ${query}\\n\\n Search Results: \\n\\n\\`\\`\\`json\\n${JSON.stringify(result, null, 2)}\\n\\`\\`\\``\n        ),\n      ],\n    };\n  } else {\n    return result;\n  }\n\n  return { context: [] };\n}\n\nexport type DescribeInputs = {\n  inputs: Inputs;\n  inputSchema: Schema;\n  asType?: boolean;\n};\n\nasync function describe({ asType, ...inputs }: DescribeInputs) {\n  const isTool = inputs && Object.keys(inputs).length === 1;\n  if (isTool) {\n    return searchWikipediaDescriber();\n  }\n  const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n  const query: Schema[\"properties\"] = hasWires\n    ? {}\n    : {\n        \"p-query\": {\n          type: \"object\",\n          title: \"Query\",\n          description:\n            \"Please provide the query with which to search Wikipedia\",\n          behavior: [\n            \"llm-content\",\n            \"config\",\n            \"hint-preview\",\n            \"hint-single-line\",\n          ],\n          default: defaultLLMContent(),\n        },\n      };\n\n  return {\n    inputSchema: {\n      type: \"object\",\n      properties: {\n        context: {\n          type: \"array\",\n          items: { type: \"object\", behavior: [\"llm-content\"] },\n          title: \"Context in\",\n          behavior: [\"main-port\"],\n        },\n        ...query,\n      },\n    } satisfies Schema,\n    outputSchema: {\n      type: \"object\",\n      properties: {\n        context: {\n          type: \"array\",\n          items: { type: \"object\", behavior: [\"llm-content\"] },\n          title: \"Context out\",\n          behavior: [\"main-port\"],\n        },\n      },\n    } satisfies Schema,\n    metadata: {\n      icon: \"globe-book\",\n      tags: [\"quick-access\", \"tool\", \"component\"],\n      order: 3,\n    },\n  };\n}\n",
          "language": "typescript"
        },
        "description": "Given a query, searches Wikipedia.",
        "runnable": false
      }
    },
    "get-weather": {
      "code": "/**\n * @fileoverview Searches weather information on Google Search.\n */\nimport { ok, err, toLLMContent, toText, defaultLLMContent } from \"./a2/utils\";\nimport getWeather, { describe as getWeatherDescriber, } from \"./get-weather-tool\";\nimport { Template } from \"./a2/template\";\nexport { invoke as default, describe };\nasync function resolveInput(inputContent) {\n    const template = new Template(inputContent);\n    const substituting = await template.substitute({}, async () => \"\");\n    if (!ok(substituting)) {\n        return substituting.$error;\n    }\n    return toText(substituting);\n}\nasync function invoke(inputs) {\n    let location;\n    let mode;\n    if (\"context\" in inputs) {\n        mode = \"step\";\n        const last = inputs.context?.at(-1);\n        if (last) {\n            location = toText(last);\n        }\n        else {\n            return err(\"Please provide a location\");\n        }\n    }\n    else if (\"p-location\" in inputs) {\n        location = await resolveInput(inputs[\"p-location\"]);\n        mode = \"step\";\n    }\n    else {\n        location = inputs.location;\n        mode = \"tool\";\n    }\n    location = (location || \"\").trim();\n    if (!location) {\n        return err(\"Please provide a location\");\n    }\n    console.log(\"Location: \" + location);\n    const weatherResult = await getWeather({ location });\n    if (!ok(weatherResult)) {\n        return weatherResult;\n    }\n    return {\n        context: [\n            toLLMContent(`Location: ${location}\\n\\n Weather information: ${toText(weatherResult)}`),\n        ],\n    };\n}\nasync function describe({ asType, ...inputs }) {\n    const isTool = inputs && Object.keys(inputs).length === 1;\n    if (isTool) {\n        return getWeatherDescriber();\n    }\n    const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n    const location = hasWires\n        ? {}\n        : {\n            \"p-location\": {\n                type: \"object\",\n                title: \"Location\",\n                description: \"Please provide the location for which to get current weather\",\n                behavior: [\n                    \"llm-content\",\n                    \"config\",\n                    \"hint-preview\",\n                    \"hint-single-line\",\n                ],\n                default: defaultLLMContent(),\n            },\n        };\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context in\",\n                    behavior: [\"main-port\"],\n                },\n                ...location,\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context out\",\n                    behavior: [\"hint-text\", \"main-port\"],\n                },\n            },\n        },\n        metadata: {\n            icon: \"sunny\",\n            tags: [\"quick-access\", \"tool\", \"component\"],\n            order: 5,\n        },\n    };\n}\n",
      "metadata": {
        "title": "Get Weather",
        "source": {
          "code": "/**\n * @fileoverview Searches weather information on Google Search.\n */\n\nimport { ok, err, toLLMContent, toText, defaultLLMContent } from \"./a2/utils\";\nimport getWeather, {\n  describe as getWeatherDescriber,\n  type WeatherInputs,\n} from \"./get-weather-tool\";\nimport { Template } from \"./a2/template\";\n\nexport { invoke as default, describe };\n\n/**\n * Every tool operates in one of three modes:\n * - `tool` -- when invoked as a tool by an LLM\n * - `step` -- when used as a step in a visual editor\n * - `invoke` -- when invoked directly as a module (by another module)\n */\nexport type ToolMode = \"tool\" | \"step\" | \"invoke\";\n\nasync function resolveInput(inputContent: LLMContent): Promise<string> {\n  const template = new Template(inputContent);\n  const substituting = await template.substitute({}, async () => \"\");\n  if (!ok(substituting)) {\n    return substituting.$error;\n  }\n  return toText(substituting);\n}\n\nexport type Inputs =\n  | {\n      context?: LLMContent[];\n      \"p-location\": LLMContent;\n    }\n  | WeatherInputs;\n\nexport type Outputs = {\n  context: LLMContent[];\n};\n\nasync function invoke(inputs: Inputs): Promise<Outcome<Outputs>> {\n  let location;\n  let mode: ToolMode;\n  if (\"context\" in inputs) {\n    mode = \"step\";\n    const last = inputs.context?.at(-1);\n    if (last) {\n      location = toText(last);\n    } else {\n      return err(\"Please provide a location\");\n    }\n  } else if (\"p-location\" in inputs) {\n    location = await resolveInput(inputs[\"p-location\"]);\n    mode = \"step\";\n  } else {\n    location = inputs.location;\n    mode = \"tool\";\n  }\n  location = (location || \"\").trim();\n  if (!location) {\n    return err(\"Please provide a location\");\n  }\n  console.log(\"Location: \" + location);\n  const weatherResult = await getWeather({ location });\n  if (!ok(weatherResult)) {\n    return weatherResult;\n  }\n  return {\n    context: [\n      toLLMContent(\n        `Location: ${location}\\n\\n Weather information: ${toText(weatherResult)}`\n      ),\n    ],\n  };\n}\n\nexport type DescribeInputs = {\n  inputs: Inputs;\n  inputSchema: Schema;\n  asType: boolean;\n};\n\nasync function describe({ asType, ...inputs }: DescribeInputs) {\n  const isTool = inputs && Object.keys(inputs).length === 1;\n  if (isTool) {\n    return getWeatherDescriber();\n  }\n  const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n  const location: Schema[\"properties\"] = hasWires\n    ? {}\n    : {\n        \"p-location\": {\n          type: \"object\",\n          title: \"Location\",\n          description:\n            \"Please provide the location for which to get current weather\",\n          behavior: [\n            \"llm-content\",\n            \"config\",\n            \"hint-preview\",\n            \"hint-single-line\",\n          ],\n          default: defaultLLMContent(),\n        },\n      };\n  return {\n    inputSchema: {\n      type: \"object\",\n      properties: {\n        context: {\n          type: \"array\",\n          items: { type: \"object\", behavior: [\"llm-content\"] },\n          title: \"Context in\",\n          behavior: [\"main-port\"],\n        },\n        ...location,\n      },\n    } satisfies Schema,\n    outputSchema: {\n      type: \"object\",\n      properties: {\n        context: {\n          type: \"array\",\n          items: { type: \"object\", behavior: [\"llm-content\"] },\n          title: \"Context out\",\n          behavior: [\"hint-text\", \"main-port\"],\n        },\n      },\n    } satisfies Schema,\n    metadata: {\n      icon: \"sunny\",\n      tags: [\"quick-access\", \"tool\", \"component\"],\n      order: 5,\n    },\n  };\n}\n",
          "language": "typescript"
        },
        "description": "Searches weather information on Google Search.",
        "runnable": false
      }
    },
    "get-weather-tool": {
      "code": "/**\n * @fileoverview The actual tool that gets the weather.\n */\nimport fetch from \"@fetch\";\nexport { invoke as default, describe };\nimport { ok, err } from \"./a2/utils\";\nimport { executeTool } from \"./a2/step-executor\";\nimport { toLLMContent } from \"./a2/utils\";\nconst USE_METEO = false;\nconst WEATHER_CODES = {\n    // Individual codes\n    \"0\": {\n        description: \"Clear sky\",\n        category: \"clear\",\n    },\n    // Ranges for cloud coverage\n    \"1\": {\n        description: \"Mainly clear\",\n        category: \"partlyCloudy\",\n    },\n    \"2\": {\n        description: \"Partly cloudy\",\n        category: \"partlyCloudy\",\n    },\n    \"3\": {\n        description: \"Overcast\",\n        category: \"cloudy\",\n    },\n    // Fog conditions\n    \"45\": {\n        description: \"Fog\",\n        category: \"fog\",\n    },\n    \"48\": {\n        description: \"Depositing rime fog\",\n        category: \"fog\",\n    },\n    // Drizzle intensities\n    \"51\": {\n        description: \"Light drizzle\",\n        category: \"drizzle\",\n        intensity: \"light\",\n    },\n    \"53\": {\n        description: \"Moderate drizzle\",\n        category: \"drizzle\",\n        intensity: \"moderate\",\n    },\n    \"55\": {\n        description: \"Dense drizzle\",\n        category: \"drizzle\",\n        intensity: \"heavy\",\n    },\n    // Freezing drizzle\n    \"56\": {\n        description: \"Light freezing drizzle\",\n        category: \"freezingDrizzle\",\n        intensity: \"light\",\n    },\n    \"57\": {\n        description: \"Dense freezing drizzle\",\n        category: \"freezingDrizzle\",\n        intensity: \"heavy\",\n    },\n    // Rain intensities\n    \"61\": {\n        description: \"Slight rain\",\n        category: \"rain\",\n        intensity: \"light\",\n    },\n    \"63\": {\n        description: \"Moderate rain\",\n        category: \"rain\",\n        intensity: \"moderate\",\n    },\n    \"65\": {\n        description: \"Heavy rain\",\n        category: \"rain\",\n        intensity: \"heavy\",\n    },\n    // Freezing rain\n    \"66\": {\n        description: \"Light freezing rain\",\n        category: \"freezingRain\",\n        intensity: \"light\",\n    },\n    \"67\": {\n        description: \"Heavy freezing rain\",\n        category: \"freezingRain\",\n        intensity: \"heavy\",\n    },\n    // Snow intensities\n    \"71\": {\n        description: \"Slight snow fall\",\n        category: \"snow\",\n        intensity: \"light\",\n    },\n    \"73\": {\n        description: \"Moderate snow fall\",\n        category: \"snow\",\n        intensity: \"moderate\",\n    },\n    \"75\": {\n        description: \"Heavy snow fall\",\n        category: \"snow\",\n        intensity: \"heavy\",\n    },\n    // Snow grains\n    \"77\": {\n        description: \"Snow grains\",\n        category: \"snowGrains\",\n    },\n    // Rain showers\n    \"80\": {\n        description: \"Slight rain showers\",\n        category: \"rainShowers\",\n        intensity: \"light\",\n    },\n    \"81\": {\n        description: \"Moderate rain showers\",\n        category: \"rainShowers\",\n        intensity: \"moderate\",\n    },\n    \"82\": {\n        description: \"Violent rain showers\",\n        category: \"rainShowers\",\n        intensity: \"violent\",\n    },\n    // Snow showers\n    \"85\": {\n        description: \"Slight snow showers\",\n        category: \"snowShowers\",\n        intensity: \"light\",\n    },\n    \"86\": {\n        description: \"Heavy snow showers\",\n        category: \"snowShowers\",\n        intensity: \"heavy\",\n    },\n    // Thunderstorm\n    \"95\": {\n        description: \"Thunderstorm\",\n        category: \"thunderstorm\",\n        intensity: \"moderate\",\n    },\n    // Thunderstorm with hail\n    \"96\": {\n        description: \"Thunderstorm with slight hail\",\n        category: \"thunderstormWithHail\",\n        intensity: \"light\",\n    },\n    \"99\": {\n        description: \"Thunderstorm with heavy hail\",\n        category: \"thunderstormWithHail\",\n        intensity: \"heavy\",\n    },\n};\nfunction geocodingUrl(location) {\n    return `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(location)}&count=10&language=en&format=json`;\n}\nfunction weatherUrl(latitude, longitude) {\n    // current=temperature_2m,is_day,precipitation,rain,showers,snowfall&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch&timezone=auto&forecast_days=1\n    return `https://api.open-meteo.com/v1/forecast?latitude=${encodeURIComponent(latitude)}&longitude=${encodeURIComponent(longitude)}&current=weather_code,temperature_2m,is_day,precipitation,rain,showers,snowfall&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch&timezone=auto&forecast_days=1`;\n}\nfunction getConditions(weather_code) {\n    const code = `${weather_code}`;\n    const conditions = WEATHER_CODES[code];\n    return conditions;\n}\nasync function invoke({ location, }) {\n    if (!USE_METEO) {\n        const executing = await executeTool(\"get_weather\", {\n            location,\n        });\n        if (!ok(executing))\n            return executing;\n        return toLLMContent(executing);\n    }\n    const geocodingResponse = await fetch({ url: geocodingUrl(location) });\n    if (\"$error\" in geocodingResponse) {\n        return { $error: geocodingResponse.$error };\n    }\n    const geocodingResults = geocodingResponse.response;\n    if (!geocodingResults.results) {\n        return { $error: `No results for location: \"${location}\"` };\n    }\n    const { latitude, longitude } = geocodingResults.results.at(0) || {};\n    if (!latitude || !longitude) {\n        return { $error: `No latitude/longitude for location: \"${location}\"` };\n    }\n    const weatherResponse = await fetch({ url: weatherUrl(latitude, longitude) });\n    if (\"$error\" in weatherResponse) {\n        return { $error: weatherResponse.$error };\n    }\n    const { current } = weatherResponse.response;\n    const precipitation = current.precipitation\n        ? `${current.precipitation} inches`\n        : \"none\";\n    const weather = {\n        location,\n        conditions: getConditions(current.weather_code),\n        time: current.time,\n        is_day: current.is_day == 1,\n        precipitation,\n        temperature: `${current.temperature_2m} F`,\n    };\n    if (current.showers) {\n        weather.showers = true;\n    }\n    if (current.snowfall) {\n        weather.snowfall = true;\n    }\n    if (current.rain) {\n        weather.rain = true;\n    }\n    const result = JSON.stringify(weather, null, 2);\n    return toLLMContent(result);\n}\nasync function describe() {\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                location: {\n                    type: \"string\",\n                    title: \"Location\",\n                    description: \"The name of the city\",\n                },\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                weather: {\n                    type: \"object\",\n                    title: \"Current Weather\",\n                },\n            },\n        },\n    };\n}\n",
      "metadata": {
        "title": "get-weather-tool",
        "source": {
          "code": "/**\n * @fileoverview The actual tool that gets the weather.\n */\nimport fetch from \"@fetch\";\n\nexport { invoke as default, describe };\n\nimport { ok, err } from \"./a2/utils\";\nimport { executeTool } from \"./a2/step-executor\";\nimport { toLLMContent } from \"./a2/utils\";\n\nconst USE_METEO = false;\n\nexport type WeatherInputs = {\n  location: string;\n};\n\nexport type WeatherOutputs = {\n  weather: WeatherOutput;\n};\n\ntype GeocodingResults = {\n  results?: {\n    name: string;\n    latitude: number;\n    longitude: number;\n  }[];\n};\n\ntype WeatherResults = {\n  current: {\n    weather_code: number;\n    time: string;\n    temperature_2m: number;\n    is_day: 0 | 1;\n    precipitation: number;\n    rain: number;\n    showers: number;\n    snowfall: number;\n  };\n};\n\nconst WEATHER_CODES: Record<string, Conditions> = {\n  // Individual codes\n  \"0\": {\n    description: \"Clear sky\",\n    category: \"clear\",\n  },\n\n  // Ranges for cloud coverage\n  \"1\": {\n    description: \"Mainly clear\",\n    category: \"partlyCloudy\",\n  },\n  \"2\": {\n    description: \"Partly cloudy\",\n    category: \"partlyCloudy\",\n  },\n  \"3\": {\n    description: \"Overcast\",\n    category: \"cloudy\",\n  },\n\n  // Fog conditions\n  \"45\": {\n    description: \"Fog\",\n    category: \"fog\",\n  },\n  \"48\": {\n    description: \"Depositing rime fog\",\n    category: \"fog\",\n  },\n\n  // Drizzle intensities\n  \"51\": {\n    description: \"Light drizzle\",\n    category: \"drizzle\",\n    intensity: \"light\",\n  },\n  \"53\": {\n    description: \"Moderate drizzle\",\n    category: \"drizzle\",\n    intensity: \"moderate\",\n  },\n  \"55\": {\n    description: \"Dense drizzle\",\n    category: \"drizzle\",\n    intensity: \"heavy\",\n  },\n\n  // Freezing drizzle\n  \"56\": {\n    description: \"Light freezing drizzle\",\n    category: \"freezingDrizzle\",\n    intensity: \"light\",\n  },\n  \"57\": {\n    description: \"Dense freezing drizzle\",\n    category: \"freezingDrizzle\",\n    intensity: \"heavy\",\n  },\n\n  // Rain intensities\n  \"61\": {\n    description: \"Slight rain\",\n    category: \"rain\",\n    intensity: \"light\",\n  },\n  \"63\": {\n    description: \"Moderate rain\",\n    category: \"rain\",\n    intensity: \"moderate\",\n  },\n  \"65\": {\n    description: \"Heavy rain\",\n    category: \"rain\",\n    intensity: \"heavy\",\n  },\n\n  // Freezing rain\n  \"66\": {\n    description: \"Light freezing rain\",\n    category: \"freezingRain\",\n    intensity: \"light\",\n  },\n  \"67\": {\n    description: \"Heavy freezing rain\",\n    category: \"freezingRain\",\n    intensity: \"heavy\",\n  },\n\n  // Snow intensities\n  \"71\": {\n    description: \"Slight snow fall\",\n    category: \"snow\",\n    intensity: \"light\",\n  },\n  \"73\": {\n    description: \"Moderate snow fall\",\n    category: \"snow\",\n    intensity: \"moderate\",\n  },\n  \"75\": {\n    description: \"Heavy snow fall\",\n    category: \"snow\",\n    intensity: \"heavy\",\n  },\n\n  // Snow grains\n  \"77\": {\n    description: \"Snow grains\",\n    category: \"snowGrains\",\n  },\n\n  // Rain showers\n  \"80\": {\n    description: \"Slight rain showers\",\n    category: \"rainShowers\",\n    intensity: \"light\",\n  },\n  \"81\": {\n    description: \"Moderate rain showers\",\n    category: \"rainShowers\",\n    intensity: \"moderate\",\n  },\n  \"82\": {\n    description: \"Violent rain showers\",\n    category: \"rainShowers\",\n    intensity: \"violent\",\n  },\n\n  // Snow showers\n  \"85\": {\n    description: \"Slight snow showers\",\n    category: \"snowShowers\",\n    intensity: \"light\",\n  },\n  \"86\": {\n    description: \"Heavy snow showers\",\n    category: \"snowShowers\",\n    intensity: \"heavy\",\n  },\n\n  // Thunderstorm\n  \"95\": {\n    description: \"Thunderstorm\",\n    category: \"thunderstorm\",\n    intensity: \"moderate\",\n  },\n\n  // Thunderstorm with hail\n  \"96\": {\n    description: \"Thunderstorm with slight hail\",\n    category: \"thunderstormWithHail\",\n    intensity: \"light\",\n  },\n  \"99\": {\n    description: \"Thunderstorm with heavy hail\",\n    category: \"thunderstormWithHail\",\n    intensity: \"heavy\",\n  },\n};\n\ntype Conditions = {\n  description: string;\n  category: string;\n  intensity?: string;\n};\n\ntype WeatherOutput = {\n  location: string;\n  conditions: Conditions;\n  time: string;\n  temperature: string;\n  is_day: boolean;\n  precipitation: string;\n  snowfall?: boolean;\n  rain?: boolean;\n  showers?: boolean;\n};\n\nfunction geocodingUrl(location: string) {\n  return `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(location)}&count=10&language=en&format=json`;\n}\n\nfunction weatherUrl(latitude: number, longitude: number) {\n  // current=temperature_2m,is_day,precipitation,rain,showers,snowfall&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch&timezone=auto&forecast_days=1\n  return `https://api.open-meteo.com/v1/forecast?latitude=${encodeURIComponent(latitude)}&longitude=${encodeURIComponent(longitude)}&current=weather_code,temperature_2m,is_day,precipitation,rain,showers,snowfall&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch&timezone=auto&forecast_days=1`;\n}\n\nfunction getConditions(weather_code: number): Conditions {\n  const code = `${weather_code}`;\n  const conditions = WEATHER_CODES[code];\n  return conditions;\n}\n\nasync function invoke({\n  location,\n}: WeatherInputs): Promise<Outcome<LLMContent>> {\n  if (!USE_METEO) {\n    const executing = await executeTool<string>(\"get_weather\", {\n      location,\n    });\n    if (!ok(executing)) return executing;\n    return toLLMContent(executing);\n  }\n  const geocodingResponse = await fetch({ url: geocodingUrl(location) });\n  if (\"$error\" in geocodingResponse) {\n    return { $error: geocodingResponse.$error as string };\n  }\n  const geocodingResults = geocodingResponse.response as GeocodingResults;\n  if (!geocodingResults.results) {\n    return { $error: `No results for location: \"${location}\"` };\n  }\n  const { latitude, longitude } = geocodingResults.results.at(0) || {};\n  if (!latitude || !longitude) {\n    return { $error: `No latitude/longitude for location: \"${location}\"` };\n  }\n  const weatherResponse = await fetch({ url: weatherUrl(latitude, longitude) });\n  if (\"$error\" in weatherResponse) {\n    return { $error: weatherResponse.$error as string };\n  }\n  const { current } = weatherResponse.response as WeatherResults;\n\n  const precipitation = current.precipitation\n    ? `${current.precipitation} inches`\n    : \"none\";\n  const weather: WeatherOutput = {\n    location,\n    conditions: getConditions(current.weather_code),\n    time: current.time,\n    is_day: current.is_day == 1,\n    precipitation,\n    temperature: `${current.temperature_2m} F`,\n  };\n  if (current.showers) {\n    weather.showers = true;\n  }\n  if (current.snowfall) {\n    weather.snowfall = true;\n  }\n  if (current.rain) {\n    weather.rain = true;\n  }\n  const result = JSON.stringify(weather, null, 2);\n  return toLLMContent(result);\n}\n\nasync function describe() {\n  return {\n    inputSchema: {\n      type: \"object\",\n      properties: {\n        location: {\n          type: \"string\",\n          title: \"Location\",\n          description: \"The name of the city\",\n        },\n      },\n    } satisfies Schema,\n    outputSchema: {\n      type: \"object\",\n      properties: {\n        weather: {\n          type: \"object\",\n          title: \"Current Weather\",\n        },\n      },\n    } satisfies Schema,\n  };\n}\n",
          "language": "typescript"
        },
        "description": "The actual tool that gets the weather.",
        "runnable": false
      }
    },
    "tool-search-wikipedia": {
      "code": "/**\n * @fileoverview Raw Search Wikipedia tool.\n */\nimport fetch from \"@fetch\";\nexport { invoke as default, describe };\nfunction searchURL(query) {\n    return `https://en.wikipedia.org/w/api.php?action=opensearch&search=${query}&origin=*`;\n}\nfunction pageQueryURL(page) {\n    return `https://en.wikipedia.org/w/api.php?action=query&format=json&prop=revisions%7Cextracts&titles=${page}&redirects=1&formatversion=2&rvlimit=1&explaintext=1&origin=*`;\n}\nasync function invoke({ query, }) {\n    if (!query) {\n        return { $error: \"No search query provided.\" };\n    }\n    const gettingTitles = await fetch({\n        url: searchURL(query),\n        method: \"GET\",\n    });\n    if (\"$error\" in gettingTitles) {\n        return gettingTitles;\n    }\n    const response = gettingTitles.response;\n    const titles = response.at(3)?.map((item) => decodeURIComponent(item.slice(30))) || [];\n    if (!titles.length) {\n        return { $error: `No titles found` };\n    }\n    const extracts = await Promise.all(titles.map(async (title) => {\n        const gettingPage = (await fetch({\n            url: pageQueryURL(title),\n            method: \"GET\",\n        }));\n        if (\"$error\" in gettingPage) {\n            return { $error: `Error getting page: ${title}` };\n        }\n        console.log(\"GETTING PAGE\", gettingPage.response);\n        const extract = gettingPage.response.query.pages.at(0)?.extract;\n        if (!extract) {\n            return { $error: `Error getting extract: ${title}` };\n        }\n        return extract;\n    }));\n    const errors = extracts.filter((item) => typeof item !== \"string\");\n    if (errors.length) {\n        return { $error: errors.join(\"\\n\\n\") };\n    }\n    return {\n        result: extracts,\n    };\n}\nasync function describe() {\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                query: {\n                    type: \"string\",\n                    title: \"Query\",\n                    description: \"The query to use for searching Wikipedia\",\n                },\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                result: {\n                    type: \"object\",\n                    title: \"Result\",\n                    description: \"Wikipedia Search Result\",\n                },\n            },\n        },\n    };\n}\n",
      "metadata": {
        "title": "tool-search-wikipedia",
        "source": {
          "code": "/**\n * @fileoverview Raw Search Wikipedia tool.\n */\n\nimport fetch from \"@fetch\";\n\nexport { invoke as default, describe };\n\nexport type WikipediaInputs = {\n  query: string;\n};\n\nexport type WikipediaOutputs = {\n  result: string[];\n};\n\ntype WikipediaResponse = string[][];\n\ntype WikipediaPageResponse = {\n  response: {\n    query: {\n      pages: {\n        extract: string;\n      }[];\n    };\n  };\n};\n\nfunction searchURL(query: string) {\n  return `https://en.wikipedia.org/w/api.php?action=opensearch&search=${query}&origin=*`;\n}\n\nfunction pageQueryURL(page: string) {\n  return `https://en.wikipedia.org/w/api.php?action=query&format=json&prop=revisions%7Cextracts&titles=${page}&redirects=1&formatversion=2&rvlimit=1&explaintext=1&origin=*`;\n}\n\nasync function invoke({\n  query,\n}: WikipediaInputs): Promise<Outcome<WikipediaOutputs>> {\n  if (!query) {\n    return { $error: \"No search query provided.\" };\n  }\n\n  const gettingTitles = await fetch({\n    url: searchURL(query),\n    method: \"GET\",\n  });\n  if (\"$error\" in gettingTitles) {\n    return gettingTitles as Outcome<WikipediaOutputs>;\n  }\n  const response = gettingTitles.response as WikipediaResponse;\n  const titles =\n    response.at(3)?.map((item) => decodeURIComponent(item.slice(30))) || [];\n  if (!titles.length) {\n    return { $error: `No titles found` };\n  }\n  const extracts = await Promise.all(\n    titles.map(async (title) => {\n      const gettingPage = (await fetch({\n        url: pageQueryURL(title),\n        method: \"GET\",\n      })) as Outcome<WikipediaPageResponse>;\n      if (\"$error\" in gettingPage) {\n        return { $error: `Error getting page: ${title}` };\n      }\n      console.log(\"GETTING PAGE\", gettingPage.response);\n      const extract = gettingPage.response.query.pages.at(0)?.extract;\n      if (!extract) {\n        return { $error: `Error getting extract: ${title}` };\n      }\n      return extract;\n    })\n  );\n  const errors = extracts.filter((item) => typeof item !== \"string\");\n  if (errors.length) {\n    return { $error: errors.join(\"\\n\\n\") };\n  }\n  return {\n    result: extracts as string[],\n  };\n}\n\nasync function describe() {\n  return {\n    inputSchema: {\n      type: \"object\",\n      properties: {\n        query: {\n          type: \"string\",\n          title: \"Query\",\n          description: \"The query to use for searching Wikipedia\",\n        },\n      },\n    } satisfies Schema,\n    outputSchema: {\n      type: \"object\",\n      properties: {\n        result: {\n          type: \"object\",\n          title: \"Result\",\n          description: \"Wikipedia Search Result\",\n        },\n      },\n    } satisfies Schema,\n  };\n}\n",
          "language": "typescript"
        },
        "description": "Raw Search Wikipedia tool.",
        "runnable": false
      }
    },
    "tool-search-web": {
      "code": "/**\n * @fileoverview The internal-only implementation of the Search Web tool.\n */\nimport { ToolManager } from \"./a2/tool-manager\";\nimport { GeminiPrompt } from \"./a2/gemini-prompt\";\nimport { ok, err, toText } from \"./a2/utils\";\nimport { executeTool } from \"./a2/step-executor\";\nimport secrets from \"@secrets\";\nimport fetch from \"@fetch\";\nexport { invoke as default, describe };\nasync function generateSummary(query) {\n    const toolManager = new ToolManager();\n    toolManager.addSearch();\n    const result = await new GeminiPrompt({\n        model: \"gemini-2.0-flash\",\n        body: {\n            contents: [{ parts: [{ text: query }] }],\n            tools: toolManager.list(),\n        },\n    }, toolManager).invoke();\n    if (!ok(result)) {\n        return result;\n    }\n    let results = toText(result.last);\n    const chunks = result.candidate?.groundingMetadata?.groundingChunks?.map((chunk) => {\n        const { title, uri } = chunk.web;\n        return `- [${title}](${uri})`;\n    }) || [];\n    if (chunks.length) {\n        results += `\\n## References:\\n${chunks.join(\"\\n\")}\\n`;\n    }\n    return `\\n## Summary\\n${results}`;\n}\nfunction formatSearchResults(results) {\n    return `## Raw Search Results\n\n${results.items\n        .map((item) => {\n        return `- [${item.title}](${item.link})\n${item.snippet}\n`;\n    })\n        .join(\"\\n\\n\")}\n`;\n}\nfunction formatBackendSearchResults(results) {\n    return `## Search Results\n\n    ${results\n        .map((result) => {\n        return `## Source: ${result.url}\nSource content:\n\n${result.webpage_text_content}\n`;\n    })\n        .join(\"\\n\\n\")}\n`;\n}\nasync function getSearchLinks(query) {\n    const results = await executeTool(\"google_search\", {\n        query,\n    });\n    if (!ok(results))\n        return results;\n    return formatBackendSearchResults(results);\n}\nasync function invoke({ query, }) {\n    const [summary, links] = await Promise.all([\n        generateSummary(query),\n        getSearchLinks(query),\n    ]);\n    if (!ok(summary)) {\n        return summary;\n    }\n    if (!ok(links)) {\n        return links;\n    }\n    return { results: `Query: ${query}\\n${summary}\\n${links}` };\n}\nasync function describe() {\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                query: {\n                    type: \"string\",\n                    title: \"Query\",\n                    description: \"The query to use with which to search the Web\",\n                },\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context out\",\n                },\n            },\n        },\n    };\n}\n",
      "metadata": {
        "title": "tool-search-web",
        "source": {
          "code": "/**\n * @fileoverview The internal-only implementation of the Search Web tool.\n */\n\nimport { ToolManager } from \"./a2/tool-manager\";\nimport { GeminiPrompt } from \"./a2/gemini-prompt\";\nimport { ok, err, toText } from \"./a2/utils\";\nimport { executeTool } from \"./a2/step-executor\";\n\nimport secrets from \"@secrets\";\nimport fetch from \"@fetch\";\n\nexport { invoke as default, describe };\n\nexport type SearchWebInputs = {\n  query: string;\n};\n\nexport type SearchWebOutputs = {\n  results: string;\n};\n\nexport type SearchBackendOutput = {\n  url: string;\n  webpage_text_content: string;\n};\n\nexport type CustomSearchEngineResponse = {\n  queries: {\n    request: {\n      title: string;\n    }[];\n  };\n  items: {\n    title: string;\n    snippet: string;\n    link: string;\n  }[];\n};\n\nasync function generateSummary(query: string): Promise<Outcome<string>> {\n  const toolManager = new ToolManager();\n  toolManager.addSearch();\n  const result = await new GeminiPrompt(\n    {\n      model: \"gemini-2.0-flash\",\n      body: {\n        contents: [{ parts: [{ text: query }] }],\n        tools: toolManager.list(),\n      },\n    },\n    toolManager\n  ).invoke();\n  if (!ok(result)) {\n    return result;\n  }\n  let results = toText(result.last);\n  const chunks =\n    result.candidate?.groundingMetadata?.groundingChunks?.map((chunk) => {\n      const { title, uri } = chunk.web;\n      return `- [${title}](${uri})`;\n    }) || [];\n  if (chunks.length) {\n    results += `\\n## References:\\n${chunks.join(\"\\n\")}\\n`;\n  }\n  return `\\n## Summary\\n${results}`;\n}\n\nfunction formatSearchResults(results: CustomSearchEngineResponse) {\n  return `## Raw Search Results\n\n${results.items\n  .map((item) => {\n    return `- [${item.title}](${item.link})\n${item.snippet}\n`;\n  })\n  .join(\"\\n\\n\")}\n`;\n}\n\nfunction formatBackendSearchResults(results: SearchBackendOutput[]): string {\n  return `## Search Results\n\n    ${results\n      .map((result) => {\n        return `## Source: ${result.url}\nSource content:\n\n${result.webpage_text_content}\n`;\n      })\n      .join(\"\\n\\n\")}\n`;\n}\n\nasync function getSearchLinks(query: string): Promise<Outcome<string>> {\n  const results = await executeTool<SearchBackendOutput[]>(\"google_search\", {\n    query,\n  });\n  if (!ok(results)) return results;\n  return formatBackendSearchResults(results);\n}\n\nasync function invoke({\n  query,\n}: SearchWebInputs): Promise<Outcome<SearchWebOutputs>> {\n  const [summary, links] = await Promise.all([\n    generateSummary(query),\n    getSearchLinks(query),\n  ]);\n  if (!ok(summary)) {\n    return summary;\n  }\n  if (!ok(links)) {\n    return links;\n  }\n  return { results: `Query: ${query}\\n${summary}\\n${links}` };\n}\n\nasync function describe() {\n  return {\n    inputSchema: {\n      type: \"object\",\n      properties: {\n        query: {\n          type: \"string\",\n          title: \"Query\",\n          description: \"The query to use with which to search the Web\",\n        },\n      },\n    } satisfies Schema,\n    outputSchema: {\n      type: \"object\",\n      properties: {\n        context: {\n          type: \"array\",\n          items: { type: \"object\", behavior: [\"llm-content\"] },\n          title: \"Context out\",\n        },\n      },\n    } satisfies Schema,\n  };\n}\n",
          "language": "typescript"
        },
        "description": "The internal-only implementation of the Search Web tool.",
        "runnable": false
      }
    },
    "tool-search-maps": {
      "code": "/**\n * @fileoverview The guts of the Search Maps tool.\n */\nimport { ok, err } from \"./a2/utils\";\nimport { executeTool } from \"./a2/step-executor\";\nexport { invoke as default, describe };\nfunction formatResults(query, results) {\n    // If the result is already in string format, not SearchMap results, return as is.\n    if (typeof results == \"string\") {\n        return `Search Query: ${query}\n## Google Places Search Results\n${results}\n    `;\n    }\n    return `Search Query: ${query}\n\n\n## Google Places Search Results\n\n${results.places\n        .map((place) => {\n        const title = place.websiteUri\n            ? `[${place.displayName.text}](${place.websiteUri})`\n            : place.displayName.text;\n        return `- ${title}\\n\n  ${place.editorialSummary?.text || \"\"} \n  Address: ${place.formattedAddress}\n  User Rating: ${place.rating} (${place.userRatingCount} reviews)\n  `;\n    })\n        .join(\"\\n\\n\")}\n`;\n}\nasync function invoke({ query, }) {\n    const executing = await executeTool(\"map_search\", {\n        query,\n    });\n    if (!ok(executing))\n        return executing;\n    const results = formatResults(query, executing);\n    return { results };\n}\nasync function describe() {\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                query: {\n                    type: \"string\",\n                    title: \"Query\",\n                    description: \"Google Places API search query, typically formulated as [type of place] near [location]\",\n                },\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                results: {\n                    type: \"string\",\n                    title: \"Search Results\",\n                },\n            },\n        },\n    };\n}\n",
      "metadata": {
        "title": "tool-search-maps",
        "source": {
          "code": "/**\n * @fileoverview The guts of the Search Maps tool.\n */\n\nimport { ok, err } from \"./a2/utils\";\nimport { executeTool } from \"./a2/step-executor\";\n\nexport { invoke as default, describe };\n\nexport type SearchMapsInputs = {\n  query: string;\n};\n\nexport type SearchMapsOutputs = {\n  results: string;\n};\n\nexport type SearchMapResults = {\n  places: {\n    id: string;\n    formattedAddress: string;\n    websiteUri: string;\n    rating: number;\n    userRatingCount: number;\n    displayName: {\n      text: string;\n      languageCode: string;\n    };\n    editorialSummary: {\n      text: string;\n      languageCode: string;\n    };\n  }[];\n};\n\nfunction formatResults(query: string, results: string | SearchMapResults) {\n  // If the result is already in string format, not SearchMap results, return as is.\n  if (typeof results == \"string\") {\n    return `Search Query: ${query}\n## Google Places Search Results\n${results}\n    `;\n  }\n  return `Search Query: ${query}\n\n\n## Google Places Search Results\n\n${results.places\n  .map((place) => {\n    const title = place.websiteUri\n      ? `[${place.displayName.text}](${place.websiteUri})`\n      : place.displayName.text;\n    return `- ${title}\\n\n  ${place.editorialSummary?.text || \"\"} \n  Address: ${place.formattedAddress}\n  User Rating: ${place.rating} (${place.userRatingCount} reviews)\n  `;\n  })\n  .join(\"\\n\\n\")}\n`;\n}\n\nasync function invoke({\n  query,\n}: SearchMapsInputs): Promise<Outcome<SearchMapsOutputs>> {\n  const executing = await executeTool<SearchMapResults>(\"map_search\", {\n    query,\n  });\n  if (!ok(executing)) return executing;\n\n  const results = formatResults(query, executing);\n\n  return { results };\n}\n\nasync function describe() {\n  return {\n    inputSchema: {\n      type: \"object\",\n      properties: {\n        query: {\n          type: \"string\",\n          title: \"Query\",\n          description:\n            \"Google Places API search query, typically formulated as [type of place] near [location]\",\n        },\n      },\n    } satisfies Schema,\n    outputSchema: {\n      type: \"object\",\n      properties: {\n        results: {\n          type: \"string\",\n          title: \"Search Results\",\n        },\n      },\n    } satisfies Schema,\n  };\n}\n",
          "language": "typescript"
        },
        "description": "The guts of the Search Maps tool.",
        "runnable": false
      }
    },
    "tool-search-enterprise": {
      "code": "/**\n * @fileoverview The guts of the Search Enterprise tool.\n */\nimport { ok, err } from \"./a2/utils\";\nimport { executeTool } from \"./a2/step-executor\";\nexport { invoke as default, describe };\nasync function invoke({ query, search_engine_resource_name, }) {\n    const executing = await executeTool(\"enterprise_search\", {\n        query,\n        search_engine_resource_name,\n    });\n    if (!ok(executing))\n        return executing;\n    return { results: executing };\n}\nasync function describe() {\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                query: {\n                    type: \"string\",\n                    title: \"Query\",\n                    description: \"The search query\",\n                },\n                search_engine_resource_name: {\n                    type: \"string\",\n                    title: \"Search Engine Resource Name [Optional]\",\n                    description: \"An optional resource name for the search backend to use\",\n                },\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                results: {\n                    type: \"string\",\n                    title: \"Search Results\",\n                },\n            },\n        },\n    };\n}\n",
      "metadata": {
        "title": "tool-search-enterprise",
        "source": {
          "code": "/**\n * @fileoverview The guts of the Search Enterprise tool.\n */\n\nimport { ok, err } from \"./a2/utils\";\nimport { executeTool } from \"./a2/step-executor\";\n\nexport { invoke as default, describe };\n\nexport type SearchInputs = {\n  query: string;\n  search_engine_resource_name: string;\n};\n\nexport type SearchOutputs = {\n  results: string;\n};\n\nasync function invoke({\n  query,\n  search_engine_resource_name,\n}: SearchInputs): Promise<Outcome<SearchOutputs>> {\n  const executing = await executeTool<string>(\"enterprise_search\", {\n    query,\n    search_engine_resource_name,\n  });\n  if (!ok(executing)) return executing;\n\n  return { results: executing };\n}\n\nasync function describe() {\n  return {\n    inputSchema: {\n      type: \"object\",\n      properties: {\n        query: {\n          type: \"string\",\n          title: \"Query\",\n          description: \"The search query\",\n        },\n        search_engine_resource_name: {\n          type: \"string\",\n          title: \"Search Engine Resource Name [Optional]\",\n          description:\n            \"An optional resource name for the search backend to use\",\n        },\n      },\n    } satisfies Schema,\n    outputSchema: {\n      type: \"object\",\n      properties: {\n        results: {\n          type: \"string\",\n          title: \"Search Results\",\n        },\n      },\n    } satisfies Schema,\n  };\n}\n",
          "language": "typescript"
        },
        "description": "The guts of the Search Enterprise tool.",
        "runnable": false
      }
    },
    "tool-get-webpage": {
      "code": "/**\n * @fileoverview The guts of the Get webpage tool.\n */\nimport { ok } from \"./a2/utils\";\nimport { executeTool } from \"./a2/step-executor\";\nexport { invoke as default, describe };\nasync function getContentFromUrl(url) {\n    const executing = await executeTool(\"get_content_from_url\", { url });\n    if (!ok(executing))\n        return executing;\n    console.log(\"GET CONTENT\", executing);\n    const { html_body, markdown } = executing;\n    if (markdown) {\n        return markdown;\n    }\n    else {\n        return `\\`\\`\\`html\\n\\n${html_body}\\n\\n\\`\\`\\``;\n    }\n}\nasync function invoke({ url, }) {\n    const results = await getContentFromUrl(url);\n    if (!ok(results))\n        return results;\n    return { results };\n}\nasync function describe() {\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                url: {\n                    type: \"string\",\n                    title: \"URL\",\n                    description: \"The URL of the webpage whose content will retrieved\",\n                },\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                results: {\n                    type: \"string\",\n                    title: \"Contents of the webpage\",\n                },\n            },\n        },\n    };\n}\n",
      "metadata": {
        "title": "tool-get-webpage",
        "source": {
          "code": "/**\n * @fileoverview The guts of the Get webpage tool.\n */\n\nimport { ok } from \"./a2/utils\";\nimport { executeTool } from \"./a2/step-executor\";\n\nexport { invoke as default, describe };\n\nexport type GetWebPageInputs = {\n  url: string;\n};\n\nexport type GetWebPageOutputs = {\n  results: string;\n};\n\nexport type GetWebPageResults = string;\n\nexport type GetContentFromUrlResponse = {\n  html_body: string;\n  markdown?: string;\n};\n\nasync function getContentFromUrl(url: string): Promise<Outcome<string>> {\n  const executing = await executeTool<GetContentFromUrlResponse>(\n    \"get_content_from_url\",\n    { url }\n  );\n  if (!ok(executing)) return executing;\n  console.log(\"GET CONTENT\", executing);\n  const { html_body, markdown } = executing;\n  if (markdown) {\n    return markdown;\n  } else {\n    return `\\`\\`\\`html\\n\\n${html_body}\\n\\n\\`\\`\\``;\n  }\n}\n\nasync function invoke({\n  url,\n}: GetWebPageInputs): Promise<Outcome<GetWebPageOutputs>> {\n  const results = await getContentFromUrl(url);\n  if (!ok(results)) return results;\n  return { results };\n}\n\nasync function describe() {\n  return {\n    inputSchema: {\n      type: \"object\",\n      properties: {\n        url: {\n          type: \"string\",\n          title: \"URL\",\n          description: \"The URL of the webpage whose content will retrieved\",\n        },\n      },\n    } satisfies Schema,\n    outputSchema: {\n      type: \"object\",\n      properties: {\n        results: {\n          type: \"string\",\n          title: \"Contents of the webpage\",\n        },\n      },\n    } satisfies Schema,\n  };\n}\n",
          "language": "typescript"
        },
        "description": "The guts of the Get webpage tool.",
        "runnable": false
      }
    }
  },
  "exports": [
    "#module:get-weather",
    "#module:search-web",
    "#module:get-webpage",
    "#module:search-maps"
  ]
}