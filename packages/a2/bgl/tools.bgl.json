{
  "title": "Tools",
  "description": "A collection of useful tools.",
  "version": "0.0.1",
  "nodes": [],
  "edges": [],
  "imports": {
    "a2": {
      "url": "./a2.bgl.json"
    }
  },
  "metadata": {
    "comments": [
      {
        "id": "comment-6fc8b597",
        "text": "Intentionally Left Blank",
        "metadata": {
          "visual": {
            "x": 7,
            "y": -575,
            "collapsed": "expanded",
            "outputHeight": 0
          }
        }
      }
    ],
    "visual": {
      "presentation": {
        "themes": {
          "f90eb9c1-e12c-4864-ba74-a15a3b8d77f3": {
            "themeColors": {
              "primaryColor": "#246db5",
              "secondaryColor": "#5cadff",
              "backgroundColor": "#ffffff",
              "textColor": "#1a1a1a",
              "primaryTextColor": "#ffffff"
            },
            "template": "basic",
            "splashScreen": {
              "storedData": {
                "handle": "/images/app/generic-flow.jpg",
                "mimeType": "image/jpeg"
              }
            }
          }
        },
        "theme": "f90eb9c1-e12c-4864-ba74-a15a3b8d77f3"
      }
    },
    "tags": [
      "published",
      "tool",
      "component"
    ]
  },
  "modules": {
    "search-web": {
      "code": "/**\n * @fileoverview Given a query, searches the Web with Google Search.\n */\nimport gemini, {} from \"./a2/gemini\";\nimport { Template } from \"./a2/template\";\nimport { ToolManager } from \"./a2/tool-manager\";\nimport { GeminiPrompt } from \"./a2/gemini-prompt\";\nimport { ok, err, toText, toLLMContent, addUserTurn, defaultLLMContent, } from \"./a2/utils\";\nimport toolSearchWeb, { describe as toolSearchWebDescribe, } from \"./tool-search-web\";\nimport fetch from \"@fetch\";\nexport { invoke as default, describe };\nasync function resolveInput(inputContent) {\n    const template = new Template(inputContent);\n    const substituting = await template.substitute({}, async () => \"\");\n    if (!ok(substituting)) {\n        return substituting.$error;\n    }\n    return toText(substituting);\n}\nasync function invoke(inputs) {\n    let query;\n    let mode;\n    if (\"context\" in inputs) {\n        mode = \"step\";\n        const last = inputs.context?.at(-1);\n        if (last) {\n            query = toText(last);\n        }\n        else {\n            return err(\"Please provide a query\");\n        }\n    }\n    else if (\"p-query\" in inputs) {\n        query = await resolveInput(inputs[\"p-query\"]);\n        mode = \"step\";\n    }\n    else {\n        query = inputs.query;\n        mode = \"tool\";\n    }\n    query = (query || \"\").trim();\n    if (!query) {\n        return err(\"Please provide a query\");\n    }\n    console.log(\"Query: \" + query);\n    const searchResults = await toolSearchWeb({ query });\n    if (!ok(searchResults)) {\n        return searchResults;\n    }\n    if (mode === \"step\") {\n        return { context: [toLLMContent(searchResults.results)] };\n    }\n    return searchResults;\n}\nasync function describe(inputs) {\n    const isTool = inputs && Object.keys(inputs).length === 1;\n    if (isTool) {\n        return toolSearchWebDescribe();\n    }\n    const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n    const query = hasWires\n        ? {}\n        : {\n            \"p-query\": {\n                type: \"object\",\n                title: \"Search query\",\n                description: \"Please provide a search query\",\n                behavior: [\n                    \"llm-content\",\n                    \"config\",\n                    \"hint-preview\",\n                    \"hint-single-line\",\n                ],\n                default: defaultLLMContent(),\n            },\n        };\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: {\n                        type: \"object\",\n                        behavior: [\"llm-content\"],\n                    },\n                    title: \"Context in\",\n                    behavior: [\"main-port\"],\n                },\n                ...query,\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context out\",\n                    behavior: [\"main-port\"],\n                },\n            },\n        },\n        metadata: {\n            icon: \"search\",\n            tags: [\"quick-access\", \"tool\"],\n            order: 1,\n        },\n    };\n}\n",
      "metadata": {
        "title": "Search Web",
        "source": {
          "code": "/**\n * @fileoverview Given a query, searches the Web with Google Search.\n */\n\nimport gemini, { type GeminiInputs } from \"./a2/gemini\";\nimport { Template } from \"./a2/template\";\nimport { ToolManager } from \"./a2/tool-manager\";\nimport { GeminiPrompt } from \"./a2/gemini-prompt\";\nimport {\n  ok,\n  err,\n  toText,\n  toLLMContent,\n  addUserTurn,\n  defaultLLMContent,\n} from \"./a2/utils\";\nimport toolSearchWeb, {\n  type SearchWebOutputs,\n  describe as toolSearchWebDescribe,\n} from \"./tool-search-web\";\n\nimport fetch from \"@fetch\";\n\nexport { invoke as default, describe };\n\ntype Inputs =\n  | {\n      context?: LLMContent[];\n      \"p-query\": LLMContent;\n    }\n  | {\n      query: string;\n    };\n\ntype Outputs =\n  | {\n      context: LLMContent[];\n    }\n  | SearchWebOutputs;\n\nasync function resolveInput(inputContent: LLMContent): Promise<string> {\n  const template = new Template(inputContent);\n  const substituting = await template.substitute({}, async () => \"\");\n  if (!ok(substituting)) {\n    return substituting.$error;\n  }\n  return toText(substituting);\n}\n\nasync function invoke(inputs: Inputs): Promise<Outcome<Outputs>> {\n  let query: string;\n  let mode: \"step\" | \"tool\";\n  if (\"context\" in inputs) {\n    mode = \"step\";\n    const last = inputs.context?.at(-1);\n    if (last) {\n      query = toText(last);\n    } else {\n      return err(\"Please provide a query\");\n    }\n  } else if (\"p-query\" in inputs) {\n    query = await resolveInput(inputs[\"p-query\"]);\n    mode = \"step\";\n  } else {\n    query = inputs.query;\n    mode = \"tool\";\n  }\n  query = (query || \"\").trim();\n  if (!query) {\n    return err(\"Please provide a query\");\n  }\n  console.log(\"Query: \" + query);\n  const searchResults = await toolSearchWeb({ query });\n  if (!ok(searchResults)) {\n    return searchResults;\n  }\n  if (mode === \"step\") {\n    return { context: [toLLMContent(searchResults.results)] };\n  }\n  return searchResults;\n}\n\nexport type DescribeInputs = {\n  inputs: Inputs;\n  inputSchema: Schema;\n};\n\nasync function describe(inputs: DescribeInputs) {\n  const isTool = inputs && Object.keys(inputs).length === 1;\n  if (isTool) {\n    return toolSearchWebDescribe();\n  }\n  const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n  const query: Schema[\"properties\"] = hasWires\n    ? {}\n    : {\n        \"p-query\": {\n          type: \"object\",\n          title: \"Search query\",\n          description: \"Please provide a search query\",\n          behavior: [\n            \"llm-content\",\n            \"config\",\n            \"hint-preview\",\n            \"hint-single-line\",\n          ],\n          default: defaultLLMContent(),\n        },\n      };\n\n  return {\n    inputSchema: {\n      type: \"object\",\n      properties: {\n        context: {\n          type: \"array\",\n          items: {\n            type: \"object\",\n            behavior: [\"llm-content\"],\n          },\n          title: \"Context in\",\n          behavior: [\"main-port\"],\n        },\n        ...query,\n      },\n    } satisfies Schema,\n    outputSchema: {\n      type: \"object\",\n      properties: {\n        context: {\n          type: \"array\",\n          items: { type: \"object\", behavior: [\"llm-content\"] },\n          title: \"Context out\",\n          behavior: [\"main-port\"],\n        },\n      },\n    } satisfies Schema,\n    metadata: {\n      icon: \"search\",\n      tags: [\"quick-access\", \"tool\"],\n      order: 1,\n    },\n  };\n}\n",
          "language": "typescript"
        },
        "description": "Given a query, searches the Web with Google Search.",
        "runnable": false
      }
    },
    "search-maps": {
      "code": "/**\n * @fileoverview Add a description for your module here.\n */\nimport toolSearchMaps, { describe as toolSearchMapsDescribe, } from \"./tool-search-maps\";\nimport { Template } from \"./a2/template\";\nimport { err, ok, toText, toLLMContent, defaultLLMContent } from \"./a2/utils\";\nexport { invoke as default, describe };\nasync function resolveInput(inputContent) {\n    const template = new Template(inputContent);\n    const substituting = await template.substitute({}, async () => \"\");\n    if (!ok(substituting)) {\n        return substituting.$error;\n    }\n    return toText(substituting);\n}\nasync function invoke(inputs) {\n    let query;\n    let mode;\n    if (\"context\" in inputs) {\n        mode = \"step\";\n        const last = inputs.context?.at(-1);\n        if (last) {\n            query = toText(last);\n        }\n        else {\n            return err(\"Please provide a query\");\n        }\n    }\n    else if (\"p-query\" in inputs) {\n        query = await resolveInput(inputs[\"p-query\"]);\n        mode = \"step\";\n    }\n    else {\n        query = inputs.query;\n        mode = \"tool\";\n    }\n    query = (query || \"\").trim();\n    if (!query) {\n        return err(\"Please provide a query\");\n    }\n    console.log(\"Query: \" + query);\n    const searchMapsResults = await toolSearchMaps({ query });\n    if (!ok(searchMapsResults)) {\n        return searchMapsResults;\n    }\n    const results = searchMapsResults.results;\n    if (mode === \"step\") {\n        return {\n            context: [toLLMContent(results)],\n        };\n    }\n    return { results };\n}\nasync function describe(inputs) {\n    const isTool = inputs && Object.keys(inputs).length === 1;\n    if (isTool) {\n        return toolSearchMapsDescribe();\n    }\n    const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n    const query = hasWires\n        ? {}\n        : {\n            \"p-query\": {\n                type: \"object\",\n                title: \"Search query\",\n                description: \"Please provide a search query\",\n                behavior: [\n                    \"llm-content\",\n                    \"config\",\n                    \"hint-preview\",\n                    \"hint-single-line\",\n                ],\n                default: defaultLLMContent(),\n            },\n        };\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context in\",\n                    behavior: [\"main-port\"],\n                },\n                ...query,\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context out\",\n                    behavior: [\"main-port\"],\n                },\n            },\n        },\n        metadata: {\n            icon: \"map-search\",\n            tags: [\"quick-access\", \"tool\"],\n            order: 2,\n        },\n    };\n}\n",
      "metadata": {
        "title": "Search Maps",
        "source": {
          "code": "/**\n * @fileoverview Add a description for your module here.\n */\n\nimport toolSearchMaps, {\n  type SearchMapsOutputs,\n  describe as toolSearchMapsDescribe,\n} from \"./tool-search-maps\";\nimport { Template } from \"./a2/template\";\nimport { err, ok, toText, toLLMContent, defaultLLMContent } from \"./a2/utils\";\nexport { invoke as default, describe };\n\ntype Inputs =\n  | {\n      context?: LLMContent[];\n      \"p-query\": LLMContent;\n    }\n  | {\n      query: string;\n    };\n\ntype Outputs =\n  | {\n      context: LLMContent[];\n    }\n  | {\n      results: string;\n    };\n\nasync function resolveInput(inputContent: LLMContent): Promise<string> {\n  const template = new Template(inputContent);\n  const substituting = await template.substitute({}, async () => \"\");\n  if (!ok(substituting)) {\n    return substituting.$error;\n  }\n  return toText(substituting);\n}\n\nasync function invoke(inputs: Inputs): Promise<Outcome<Outputs>> {\n  let query: string;\n  let mode: \"step\" | \"tool\";\n  if (\"context\" in inputs) {\n    mode = \"step\";\n    const last = inputs.context?.at(-1);\n    if (last) {\n      query = toText(last);\n    } else {\n      return err(\"Please provide a query\");\n    }\n  } else if (\"p-query\" in inputs) {\n    query = await resolveInput(inputs[\"p-query\"]);\n    mode = \"step\";\n  } else {\n    query = inputs.query;\n    mode = \"tool\";\n  }\n  query = (query || \"\").trim();\n  if (!query) {\n    return err(\"Please provide a query\");\n  }\n\n  console.log(\"Query: \" + query);\n  const searchMapsResults = await toolSearchMaps({ query });\n  if (!ok(searchMapsResults)) {\n    return searchMapsResults;\n  }\n  const results = searchMapsResults.results;\n  if (mode === \"step\") {\n    return {\n      context: [toLLMContent(results)],\n    };\n  }\n  return { results };\n}\n\nexport type DescribeInputs = {\n  inputs: Inputs;\n  inputSchema: Schema;\n};\n\nasync function describe(inputs: DescribeInputs) {\n  const isTool = inputs && Object.keys(inputs).length === 1;\n  if (isTool) {\n    return toolSearchMapsDescribe();\n  }\n  const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n  const query: Schema[\"properties\"] = hasWires\n    ? {}\n    : {\n        \"p-query\": {\n          type: \"object\",\n          title: \"Search query\",\n          description: \"Please provide a search query\",\n          behavior: [\n            \"llm-content\",\n            \"config\",\n            \"hint-preview\",\n            \"hint-single-line\",\n          ],\n          default: defaultLLMContent(),\n        },\n      };\n\n  return {\n    inputSchema: {\n      type: \"object\",\n      properties: {\n        context: {\n          type: \"array\",\n          items: { type: \"object\", behavior: [\"llm-content\"] },\n          title: \"Context in\",\n          behavior: [\"main-port\"],\n        },\n        ...query,\n      },\n    } satisfies Schema,\n    outputSchema: {\n      type: \"object\",\n      properties: {\n        context: {\n          type: \"array\",\n          items: { type: \"object\", behavior: [\"llm-content\"] },\n          title: \"Context out\",\n          behavior: [\"main-port\"],\n        },\n      },\n    } satisfies Schema,\n\n    metadata: {\n      icon: \"map-search\",\n      tags: [\"quick-access\", \"tool\"],\n      order: 2,\n    },\n  };\n}\n",
          "language": "typescript"
        },
        "description": "Add a description for your module here.",
        "runnable": false
      }
    },
    "get-webpage": {
      "code": "/**\n * @fileoverview Given a URL of a webpage, returns its content as Markdown with a list of links and other metadata.\n */\nimport toolGetWebpage, { describe as toolGetWebpageDescribe, } from \"./tool-get-webpage\";\nimport { Template } from \"./a2/template\";\nimport { ok, err, toText, toLLMContent, defaultLLMContent } from \"./a2/utils\";\nexport { invoke as default, describe };\nasync function resolveInput(inputContent) {\n    const template = new Template(inputContent);\n    const substituting = await template.substitute({}, async () => \"\");\n    if (!ok(substituting)) {\n        return substituting.$error;\n    }\n    return toText(substituting);\n}\nasync function invoke(inputs) {\n    let url;\n    let mode;\n    if (\"context\" in inputs) {\n        mode = \"step\";\n        const last = inputs.context?.at(-1);\n        if (last) {\n            url = toText(last);\n        }\n        else {\n            return err(\"Please provide a query\");\n        }\n    }\n    else if (\"p-url\" in inputs) {\n        url = await resolveInput(inputs[\"p-url\"]);\n        mode = \"step\";\n    }\n    else {\n        url = inputs.url;\n        mode = \"tool\";\n    }\n    url = (url || \"\").trim();\n    if (!url) {\n        return err(\"Please provide a URL\");\n    }\n    console.log(\"URL: \" + url);\n    const getting = await toolGetWebpage({ url });\n    if (!ok(getting)) {\n        return getting;\n    }\n    if (mode == \"step\") {\n        return {\n            context: [toLLMContent(getting.results)],\n        };\n    }\n    return getting;\n}\nasync function describe(inputs) {\n    const isTool = inputs && Object.keys(inputs).length === 1;\n    if (isTool) {\n        return toolGetWebpageDescribe();\n    }\n    const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n    const query = hasWires\n        ? {}\n        : {\n            \"p-url\": {\n                type: \"object\",\n                title: \"URL\",\n                description: \"Please provide URL of the webpage\",\n                behavior: [\n                    \"llm-content\",\n                    \"config\",\n                    \"hint-preview\",\n                    \"hint-single-line\",\n                ],\n                default: defaultLLMContent(),\n            },\n        };\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context in\",\n                    behavior: [\"main-port\"],\n                },\n                ...query,\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context out\",\n                    behavior: [\"main-port\"],\n                },\n            },\n        },\n        metadata: {\n            icon: \"language\",\n            tags: [\"quick-access\", \"tool\"],\n            order: 4,\n        },\n    };\n}\n",
      "metadata": {
        "title": "Get Webpage",
        "source": {
          "code": "/**\n * @fileoverview Given a URL of a webpage, returns its content as Markdown with a list of links and other metadata.\n */\n\nimport toolGetWebpage, {\n  describe as toolGetWebpageDescribe,\n} from \"./tool-get-webpage\";\nimport { Template } from \"./a2/template\";\nimport { ok, err, toText, toLLMContent, defaultLLMContent } from \"./a2/utils\";\n\nexport { invoke as default, describe };\n\nexport type GetWebPageInputs = {\n  url: string;\n};\n\nexport type GetWebPageOutputs = {\n  results: string;\n};\n\nasync function resolveInput(inputContent: LLMContent): Promise<string> {\n  const template = new Template(inputContent);\n  const substituting = await template.substitute({}, async () => \"\");\n  if (!ok(substituting)) {\n    return substituting.$error;\n  }\n  return toText(substituting);\n}\n\ntype Inputs =\n  | {\n      context?: LLMContent[];\n      \"p-url\": LLMContent;\n    }\n  | GetWebPageInputs;\n\ntype Outputs =\n  | {\n      context: LLMContent[];\n    }\n  | GetWebPageOutputs;\n\nasync function invoke(inputs: Inputs): Promise<Outcome<Outputs>> {\n  let url: string;\n  let mode: \"step\" | \"tool\";\n  if (\"context\" in inputs) {\n    mode = \"step\";\n    const last = inputs.context?.at(-1);\n    if (last) {\n      url = toText(last);\n    } else {\n      return err(\"Please provide a query\");\n    }\n  } else if (\"p-url\" in inputs) {\n    url = await resolveInput(inputs[\"p-url\"]);\n    mode = \"step\";\n  } else {\n    url = inputs.url;\n    mode = \"tool\";\n  }\n  url = (url || \"\").trim();\n  if (!url) {\n    return err(\"Please provide a URL\");\n  }\n  console.log(\"URL: \" + url);\n  const getting = await toolGetWebpage({ url });\n  if (!ok(getting)) {\n    return getting;\n  }\n  if (mode == \"step\") {\n    return {\n      context: [toLLMContent(getting.results)],\n    };\n  }\n  return getting;\n}\n\nexport type DescribeInputs = {\n  inputs: Inputs;\n  inputSchema: Schema;\n};\nasync function describe(inputs: DescribeInputs) {\n  const isTool = inputs && Object.keys(inputs).length === 1;\n  if (isTool) {\n    return toolGetWebpageDescribe();\n  }\n  const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n  const query: Schema[\"properties\"] = hasWires\n    ? {}\n    : {\n        \"p-url\": {\n          type: \"object\",\n          title: \"URL\",\n          description: \"Please provide URL of the webpage\",\n          behavior: [\n            \"llm-content\",\n            \"config\",\n            \"hint-preview\",\n            \"hint-single-line\",\n          ],\n          default: defaultLLMContent(),\n        },\n      };\n\n  return {\n    inputSchema: {\n      type: \"object\",\n      properties: {\n        context: {\n          type: \"array\",\n          items: { type: \"object\", behavior: [\"llm-content\"] },\n          title: \"Context in\",\n          behavior: [\"main-port\"],\n        },\n        ...query,\n      },\n    } satisfies Schema,\n    outputSchema: {\n      type: \"object\",\n      properties: {\n        context: {\n          type: \"array\",\n          items: { type: \"object\", behavior: [\"llm-content\"] },\n          title: \"Context out\",\n          behavior: [\"main-port\"],\n        },\n      },\n    } satisfies Schema,\n\n    metadata: {\n      icon: \"language\",\n      tags: [\"quick-access\", \"tool\"],\n      order: 4,\n    },\n  };\n}\n",
          "language": "typescript"
        },
        "description": "Given a URL of a webpage, returns its content as Markdown with a list of links and other metadata.",
        "runnable": false
      }
    },
    "search-wikipedia": {
      "code": "/**\n * @fileoverview Given a query, searches Wikipedia.\n */\nimport searchWikipedia, { describe as searchWikipediaDescriber, } from \"./tool-search-wikipedia\";\nimport { Template } from \"./a2/template\";\nimport { ok, err, toText, toLLMContent, defaultLLMContent } from \"./a2/utils\";\nexport { invoke as default, describe };\nasync function resolveInput(inputContent) {\n    const template = new Template(inputContent);\n    const substituting = await template.substitute({}, async () => \"\");\n    if (!ok(substituting)) {\n        return substituting.$error;\n    }\n    return toText(substituting);\n}\nasync function invoke(inputs) {\n    let query;\n    let mode;\n    if (\"context\" in inputs) {\n        mode = \"step\";\n        const last = inputs.context?.at(-1);\n        if (last) {\n            query = toText(last);\n        }\n        else {\n            return err(\"Please provide a query\");\n        }\n    }\n    else if (\"p-query\" in inputs) {\n        query = await resolveInput(inputs[\"p-query\"]);\n        mode = \"step\";\n    }\n    else {\n        query = inputs.query;\n        mode = \"tool\";\n    }\n    query = (query || \"\").trim();\n    if (!query) {\n        return err(\"Please provide a query\");\n    }\n    console.log(\"Query: \" + query);\n    const result = await searchWikipedia({ query });\n    if (!ok(result)) {\n        return result;\n    }\n    if (mode == \"step\") {\n        return {\n            context: [\n                toLLMContent(`Query: ${query}\\n\\n Search Results: \\n\\n\\`\\`\\`json\\n${JSON.stringify(result, null, 2)}\\n\\`\\`\\``),\n            ],\n        };\n    }\n    else {\n        return result;\n    }\n    return { context: [] };\n}\nasync function describe(inputs) {\n    const isTool = inputs && Object.keys(inputs).length === 1;\n    if (isTool) {\n        return searchWikipediaDescriber();\n    }\n    const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n    const query = hasWires\n        ? {}\n        : {\n            \"p-query\": {\n                type: \"object\",\n                title: \"Query\",\n                description: \"Please provide the query with which to search Wikipedia\",\n                behavior: [\n                    \"llm-content\",\n                    \"config\",\n                    \"hint-preview\",\n                    \"hint-single-line\",\n                ],\n                default: defaultLLMContent(),\n            },\n        };\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context in\",\n                    behavior: [\"main-port\"],\n                },\n                ...query,\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context out\",\n                    behavior: [\"main-port\"],\n                },\n            },\n        },\n        metadata: {\n            icon: \"globe-book\",\n            tags: [\"quick-access\", \"tool\"],\n            order: 3,\n        },\n    };\n}\n",
      "metadata": {
        "title": "Search Wikipedia",
        "source": {
          "code": "/**\n * @fileoverview Given a query, searches Wikipedia.\n */\n\nimport searchWikipedia, {\n  describe as searchWikipediaDescriber,\n  type WikipediaInputs,\n  type WikipediaOutputs,\n} from \"./tool-search-wikipedia\";\nimport { Template } from \"./a2/template\";\n\nimport { ok, err, toText, toLLMContent, defaultLLMContent } from \"./a2/utils\";\n\nexport { invoke as default, describe };\n\nasync function resolveInput(inputContent: LLMContent): Promise<string> {\n  const template = new Template(inputContent);\n  const substituting = await template.substitute({}, async () => \"\");\n  if (!ok(substituting)) {\n    return substituting.$error;\n  }\n  return toText(substituting);\n}\n\ntype Inputs =\n  | {\n      context?: LLMContent[];\n      \"p-query\": LLMContent;\n    }\n  | WikipediaInputs;\n\ntype Outputs =\n  | {\n      context: LLMContent[];\n    }\n  | WikipediaOutputs;\n\nasync function invoke(inputs: Inputs): Promise<Outcome<Outputs>> {\n  let query: string;\n  let mode: \"step\" | \"tool\";\n  if (\"context\" in inputs) {\n    mode = \"step\";\n    const last = inputs.context?.at(-1);\n    if (last) {\n      query = toText(last);\n    } else {\n      return err(\"Please provide a query\");\n    }\n  } else if (\"p-query\" in inputs) {\n    query = await resolveInput(inputs[\"p-query\"]);\n    mode = \"step\";\n  } else {\n    query = inputs.query;\n    mode = \"tool\";\n  }\n  query = (query || \"\").trim();\n  if (!query) {\n    return err(\"Please provide a query\");\n  }\n\n  console.log(\"Query: \" + query);\n  const result = await searchWikipedia({ query });\n  if (!ok(result)) {\n    return result;\n  }\n  if (mode == \"step\") {\n    return {\n      context: [\n        toLLMContent(\n          `Query: ${query}\\n\\n Search Results: \\n\\n\\`\\`\\`json\\n${JSON.stringify(result, null, 2)}\\n\\`\\`\\``\n        ),\n      ],\n    };\n  } else {\n    return result;\n  }\n\n  return { context: [] };\n}\n\nexport type DescribeInputs = {\n  inputs: Inputs;\n  inputSchema: Schema;\n};\n\nasync function describe(inputs: DescribeInputs) {\n  const isTool = inputs && Object.keys(inputs).length === 1;\n  if (isTool) {\n    return searchWikipediaDescriber();\n  }\n  const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n  const query: Schema[\"properties\"] = hasWires\n    ? {}\n    : {\n        \"p-query\": {\n          type: \"object\",\n          title: \"Query\",\n          description:\n            \"Please provide the query with which to search Wikipedia\",\n          behavior: [\n            \"llm-content\",\n            \"config\",\n            \"hint-preview\",\n            \"hint-single-line\",\n          ],\n          default: defaultLLMContent(),\n        },\n      };\n\n  return {\n    inputSchema: {\n      type: \"object\",\n      properties: {\n        context: {\n          type: \"array\",\n          items: { type: \"object\", behavior: [\"llm-content\"] },\n          title: \"Context in\",\n          behavior: [\"main-port\"],\n        },\n        ...query,\n      },\n    } satisfies Schema,\n    outputSchema: {\n      type: \"object\",\n      properties: {\n        context: {\n          type: \"array\",\n          items: { type: \"object\", behavior: [\"llm-content\"] },\n          title: \"Context out\",\n          behavior: [\"main-port\"],\n        },\n      },\n    } satisfies Schema,\n    metadata: {\n      icon: \"globe-book\",\n      tags: [\"quick-access\", \"tool\"],\n      order: 3,\n    },\n  };\n}\n",
          "language": "typescript"
        },
        "description": "Given a query, searches Wikipedia.",
        "runnable": false
      }
    },
    "get-weather": {
      "code": "/**\n * @fileoverview Add a description for your module here.\n */\nimport { ok, err, toLLMContent, toText, addUserTurn, defaultLLMContent, } from \"./a2/utils\";\nimport getWeather, { describe as getWeatherDescriber, } from \"./get-weather-tool\";\nimport { Template } from \"./a2/template\";\nexport { invoke as default, describe };\nasync function resolveInput(inputContent) {\n    const template = new Template(inputContent);\n    const substituting = await template.substitute({}, async () => \"\");\n    if (!ok(substituting)) {\n        return substituting.$error;\n    }\n    return toText(substituting);\n}\nasync function invoke(inputs) {\n    let location;\n    let mode;\n    if (\"context\" in inputs) {\n        mode = \"step\";\n        const last = inputs.context?.at(-1);\n        if (last) {\n            location = toText(last);\n        }\n        else {\n            return err(\"Please provide a location\");\n        }\n    }\n    else if (\"p-location\" in inputs) {\n        location = await resolveInput(inputs[\"p-location\"]);\n        mode = \"step\";\n    }\n    else {\n        location = inputs.location;\n        mode = \"tool\";\n    }\n    location = (location || \"\").trim();\n    if (!location) {\n        return err(\"Please provide a location\");\n    }\n    console.log(\"Location: \" + location);\n    const result = await getWeather({ location });\n    if (!ok(result)) {\n        return result;\n    }\n    if (mode == \"step\") {\n        return {\n            context: [\n                toLLMContent(`Location: ${location}\\n\\n Weather information: \\n\\n\\`\\`\\`json\\n${JSON.stringify(result, null, 2)}\\n\\`\\`\\``),\n            ],\n        };\n    }\n    else {\n        return result;\n    }\n}\nasync function describe(inputs) {\n    const isTool = inputs && Object.keys(inputs).length === 1;\n    if (isTool) {\n        return getWeatherDescriber();\n    }\n    const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n    const location = hasWires\n        ? {}\n        : {\n            \"p-location\": {\n                type: \"object\",\n                title: \"Location\",\n                description: \"Please provide the location for which to get current weather\",\n                behavior: [\n                    \"llm-content\",\n                    \"config\",\n                    \"hint-preview\",\n                    \"hint-single-line\",\n                ],\n                default: defaultLLMContent(),\n            },\n        };\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context in\",\n                    behavior: [\"main-port\"],\n                },\n                ...location,\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context out\",\n                    behavior: [\"hint-text\", \"main-port\"],\n                },\n            },\n        },\n        metadata: {\n            icon: \"sunny\",\n            tags: [\"quick-access\", \"tool\"],\n            order: 5,\n        },\n    };\n}\n",
      "metadata": {
        "title": "Get Weather",
        "source": {
          "code": "/**\n * @fileoverview Add a description for your module here.\n */\n\nimport {\n  ok,\n  err,\n  toLLMContent,\n  toText,\n  addUserTurn,\n  defaultLLMContent,\n} from \"./a2/utils\";\nimport getWeather, {\n  describe as getWeatherDescriber,\n  type WeatherInputs,\n  type WeatherOutputs,\n} from \"./get-weather-tool\";\nimport { Template } from \"./a2/template\";\n\nexport { invoke as default, describe };\n\n/**\n * Every tool operates in one of three modes:\n * - `tool` -- when invoked as a tool by an LLM\n * - `step` -- when used as a step in a visual editor\n * - `invoke` -- when invoked directly as a module (by another module)\n */\nexport type ToolMode = \"tool\" | \"step\" | \"invoke\";\n\nasync function resolveInput(inputContent: LLMContent): Promise<string> {\n  const template = new Template(inputContent);\n  const substituting = await template.substitute({}, async () => \"\");\n  if (!ok(substituting)) {\n    return substituting.$error;\n  }\n  return toText(substituting);\n}\n\nexport type Inputs =\n  | {\n      context?: LLMContent[];\n      \"p-location\": LLMContent;\n    }\n  | WeatherInputs;\n\nexport type Outputs =\n  | WeatherOutputs\n  | {\n      context: LLMContent[];\n    };\n\nasync function invoke(inputs: Inputs): Promise<Outcome<Outputs>> {\n  let location;\n  let mode: ToolMode;\n  if (\"context\" in inputs) {\n    mode = \"step\";\n    const last = inputs.context?.at(-1);\n    if (last) {\n      location = toText(last);\n    } else {\n      return err(\"Please provide a location\");\n    }\n  } else if (\"p-location\" in inputs) {\n    location = await resolveInput(inputs[\"p-location\"]);\n    mode = \"step\";\n  } else {\n    location = inputs.location;\n    mode = \"tool\";\n  }\n  location = (location || \"\").trim();\n  if (!location) {\n    return err(\"Please provide a location\");\n  }\n  console.log(\"Location: \" + location);\n  const result = await getWeather({ location });\n  if (!ok(result)) {\n    return result;\n  }\n  if (mode == \"step\") {\n    return {\n      context: [\n        toLLMContent(\n          `Location: ${location}\\n\\n Weather information: \\n\\n\\`\\`\\`json\\n${JSON.stringify(result, null, 2)}\\n\\`\\`\\``\n        ),\n      ],\n    };\n  } else {\n    return result;\n  }\n}\n\nexport type DescribeInputs = {\n  inputs: Inputs;\n  inputSchema: Schema;\n};\n\nasync function describe(inputs: DescribeInputs) {\n  const isTool = inputs && Object.keys(inputs).length === 1;\n  if (isTool) {\n    return getWeatherDescriber();\n  }\n  const hasWires = \"context\" in (inputs.inputSchema.properties || {});\n  const location: Schema[\"properties\"] = hasWires\n    ? {}\n    : {\n        \"p-location\": {\n          type: \"object\",\n          title: \"Location\",\n          description:\n            \"Please provide the location for which to get current weather\",\n          behavior: [\n            \"llm-content\",\n            \"config\",\n            \"hint-preview\",\n            \"hint-single-line\",\n          ],\n          default: defaultLLMContent(),\n        },\n      };\n  return {\n    inputSchema: {\n      type: \"object\",\n      properties: {\n        context: {\n          type: \"array\",\n          items: { type: \"object\", behavior: [\"llm-content\"] },\n          title: \"Context in\",\n          behavior: [\"main-port\"],\n        },\n        ...location,\n      },\n    } satisfies Schema,\n    outputSchema: {\n      type: \"object\",\n      properties: {\n        context: {\n          type: \"array\",\n          items: { type: \"object\", behavior: [\"llm-content\"] },\n          title: \"Context out\",\n          behavior: [\"hint-text\", \"main-port\"],\n        },\n      },\n    } satisfies Schema,\n    metadata: {\n      icon: \"sunny\",\n      tags: [\"quick-access\", \"tool\"],\n      order: 5,\n    },\n  };\n}\n",
          "language": "typescript"
        },
        "description": "Add a description for your module here.",
        "runnable": false
      }
    },
    "get-weather-tool": {
      "code": "/**\n * @fileoverview The actual tool that gets the weather.\n */\nimport fetch from \"@fetch\";\nexport { invoke as default, describe };\nconst WEATHER_CODES = {\n    // Individual codes\n    \"0\": {\n        description: \"Clear sky\",\n        category: \"clear\",\n    },\n    // Ranges for cloud coverage\n    \"1\": {\n        description: \"Mainly clear\",\n        category: \"partlyCloudy\",\n    },\n    \"2\": {\n        description: \"Partly cloudy\",\n        category: \"partlyCloudy\",\n    },\n    \"3\": {\n        description: \"Overcast\",\n        category: \"cloudy\",\n    },\n    // Fog conditions\n    \"45\": {\n        description: \"Fog\",\n        category: \"fog\",\n    },\n    \"48\": {\n        description: \"Depositing rime fog\",\n        category: \"fog\",\n    },\n    // Drizzle intensities\n    \"51\": {\n        description: \"Light drizzle\",\n        category: \"drizzle\",\n        intensity: \"light\",\n    },\n    \"53\": {\n        description: \"Moderate drizzle\",\n        category: \"drizzle\",\n        intensity: \"moderate\",\n    },\n    \"55\": {\n        description: \"Dense drizzle\",\n        category: \"drizzle\",\n        intensity: \"heavy\",\n    },\n    // Freezing drizzle\n    \"56\": {\n        description: \"Light freezing drizzle\",\n        category: \"freezingDrizzle\",\n        intensity: \"light\",\n    },\n    \"57\": {\n        description: \"Dense freezing drizzle\",\n        category: \"freezingDrizzle\",\n        intensity: \"heavy\",\n    },\n    // Rain intensities\n    \"61\": {\n        description: \"Slight rain\",\n        category: \"rain\",\n        intensity: \"light\",\n    },\n    \"63\": {\n        description: \"Moderate rain\",\n        category: \"rain\",\n        intensity: \"moderate\",\n    },\n    \"65\": {\n        description: \"Heavy rain\",\n        category: \"rain\",\n        intensity: \"heavy\",\n    },\n    // Freezing rain\n    \"66\": {\n        description: \"Light freezing rain\",\n        category: \"freezingRain\",\n        intensity: \"light\",\n    },\n    \"67\": {\n        description: \"Heavy freezing rain\",\n        category: \"freezingRain\",\n        intensity: \"heavy\",\n    },\n    // Snow intensities\n    \"71\": {\n        description: \"Slight snow fall\",\n        category: \"snow\",\n        intensity: \"light\",\n    },\n    \"73\": {\n        description: \"Moderate snow fall\",\n        category: \"snow\",\n        intensity: \"moderate\",\n    },\n    \"75\": {\n        description: \"Heavy snow fall\",\n        category: \"snow\",\n        intensity: \"heavy\",\n    },\n    // Snow grains\n    \"77\": {\n        description: \"Snow grains\",\n        category: \"snowGrains\",\n    },\n    // Rain showers\n    \"80\": {\n        description: \"Slight rain showers\",\n        category: \"rainShowers\",\n        intensity: \"light\",\n    },\n    \"81\": {\n        description: \"Moderate rain showers\",\n        category: \"rainShowers\",\n        intensity: \"moderate\",\n    },\n    \"82\": {\n        description: \"Violent rain showers\",\n        category: \"rainShowers\",\n        intensity: \"violent\",\n    },\n    // Snow showers\n    \"85\": {\n        description: \"Slight snow showers\",\n        category: \"snowShowers\",\n        intensity: \"light\",\n    },\n    \"86\": {\n        description: \"Heavy snow showers\",\n        category: \"snowShowers\",\n        intensity: \"heavy\",\n    },\n    // Thunderstorm\n    \"95\": {\n        description: \"Thunderstorm\",\n        category: \"thunderstorm\",\n        intensity: \"moderate\",\n    },\n    // Thunderstorm with hail\n    \"96\": {\n        description: \"Thunderstorm with slight hail\",\n        category: \"thunderstormWithHail\",\n        intensity: \"light\",\n    },\n    \"99\": {\n        description: \"Thunderstorm with heavy hail\",\n        category: \"thunderstormWithHail\",\n        intensity: \"heavy\",\n    },\n};\nfunction geocodingUrl(location) {\n    return `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(location)}&count=10&language=en&format=json`;\n}\nfunction weatherUrl(latitude, longitude) {\n    // current=temperature_2m,is_day,precipitation,rain,showers,snowfall&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch&timezone=auto&forecast_days=1\n    return `https://api.open-meteo.com/v1/forecast?latitude=${encodeURIComponent(latitude)}&longitude=${encodeURIComponent(longitude)}&current=weather_code,temperature_2m,is_day,precipitation,rain,showers,snowfall&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch&timezone=auto&forecast_days=1`;\n}\nfunction getConditions(weather_code) {\n    const code = `${weather_code}`;\n    const conditions = WEATHER_CODES[code];\n    return conditions;\n}\nasync function invoke({ location, }) {\n    const geocodingResponse = await fetch({ url: geocodingUrl(location) });\n    if (\"$error\" in geocodingResponse) {\n        return { $error: geocodingResponse.$error };\n    }\n    const geocodingResults = geocodingResponse.response;\n    if (!geocodingResults.results) {\n        return { $error: `No results for location: \"${location}\"` };\n    }\n    const { latitude, longitude } = geocodingResults.results.at(0) || {};\n    if (!latitude || !longitude) {\n        return { $error: `No latitude/longitude for location: \"${location}\"` };\n    }\n    const weatherResponse = await fetch({ url: weatherUrl(latitude, longitude) });\n    if (\"$error\" in weatherResponse) {\n        return { $error: weatherResponse.$error };\n    }\n    const { current } = weatherResponse.response;\n    const precipitation = current.precipitation\n        ? `${current.precipitation} inches`\n        : \"none\";\n    const weather = {\n        location,\n        conditions: getConditions(current.weather_code),\n        time: current.time,\n        is_day: current.is_day == 1,\n        precipitation,\n        temperature: `${current.temperature_2m} F`,\n    };\n    if (current.showers) {\n        weather.showers = true;\n    }\n    if (current.snowfall) {\n        weather.snowfall = true;\n    }\n    if (current.rain) {\n        weather.rain = true;\n    }\n    return { weather };\n}\nasync function describe() {\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                location: {\n                    type: \"string\",\n                    title: \"Location\",\n                    description: \"The name of the city\",\n                },\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                weather: {\n                    type: \"object\",\n                    title: \"Current Weather\",\n                },\n            },\n        },\n    };\n}\n",
      "metadata": {
        "title": "get-weather-tool",
        "source": {
          "code": "/**\n * @fileoverview The actual tool that gets the weather.\n */\nimport fetch from \"@fetch\";\n\nexport { invoke as default, describe };\n\nexport type WeatherInputs = {\n  location: string;\n};\n\nexport type WeatherOutputs = {\n  weather: WeatherOutput;\n};\n\ntype GeocodingResults = {\n  results?: {\n    name: string;\n    latitude: number;\n    longitude: number;\n  }[];\n};\n\ntype WeatherResults = {\n  current: {\n    weather_code: number;\n    time: string;\n    temperature_2m: number;\n    is_day: 0 | 1;\n    precipitation: number;\n    rain: number;\n    showers: number;\n    snowfall: number;\n  };\n};\n\nconst WEATHER_CODES: Record<string, Conditions> = {\n  // Individual codes\n  \"0\": {\n    description: \"Clear sky\",\n    category: \"clear\",\n  },\n\n  // Ranges for cloud coverage\n  \"1\": {\n    description: \"Mainly clear\",\n    category: \"partlyCloudy\",\n  },\n  \"2\": {\n    description: \"Partly cloudy\",\n    category: \"partlyCloudy\",\n  },\n  \"3\": {\n    description: \"Overcast\",\n    category: \"cloudy\",\n  },\n\n  // Fog conditions\n  \"45\": {\n    description: \"Fog\",\n    category: \"fog\",\n  },\n  \"48\": {\n    description: \"Depositing rime fog\",\n    category: \"fog\",\n  },\n\n  // Drizzle intensities\n  \"51\": {\n    description: \"Light drizzle\",\n    category: \"drizzle\",\n    intensity: \"light\",\n  },\n  \"53\": {\n    description: \"Moderate drizzle\",\n    category: \"drizzle\",\n    intensity: \"moderate\",\n  },\n  \"55\": {\n    description: \"Dense drizzle\",\n    category: \"drizzle\",\n    intensity: \"heavy\",\n  },\n\n  // Freezing drizzle\n  \"56\": {\n    description: \"Light freezing drizzle\",\n    category: \"freezingDrizzle\",\n    intensity: \"light\",\n  },\n  \"57\": {\n    description: \"Dense freezing drizzle\",\n    category: \"freezingDrizzle\",\n    intensity: \"heavy\",\n  },\n\n  // Rain intensities\n  \"61\": {\n    description: \"Slight rain\",\n    category: \"rain\",\n    intensity: \"light\",\n  },\n  \"63\": {\n    description: \"Moderate rain\",\n    category: \"rain\",\n    intensity: \"moderate\",\n  },\n  \"65\": {\n    description: \"Heavy rain\",\n    category: \"rain\",\n    intensity: \"heavy\",\n  },\n\n  // Freezing rain\n  \"66\": {\n    description: \"Light freezing rain\",\n    category: \"freezingRain\",\n    intensity: \"light\",\n  },\n  \"67\": {\n    description: \"Heavy freezing rain\",\n    category: \"freezingRain\",\n    intensity: \"heavy\",\n  },\n\n  // Snow intensities\n  \"71\": {\n    description: \"Slight snow fall\",\n    category: \"snow\",\n    intensity: \"light\",\n  },\n  \"73\": {\n    description: \"Moderate snow fall\",\n    category: \"snow\",\n    intensity: \"moderate\",\n  },\n  \"75\": {\n    description: \"Heavy snow fall\",\n    category: \"snow\",\n    intensity: \"heavy\",\n  },\n\n  // Snow grains\n  \"77\": {\n    description: \"Snow grains\",\n    category: \"snowGrains\",\n  },\n\n  // Rain showers\n  \"80\": {\n    description: \"Slight rain showers\",\n    category: \"rainShowers\",\n    intensity: \"light\",\n  },\n  \"81\": {\n    description: \"Moderate rain showers\",\n    category: \"rainShowers\",\n    intensity: \"moderate\",\n  },\n  \"82\": {\n    description: \"Violent rain showers\",\n    category: \"rainShowers\",\n    intensity: \"violent\",\n  },\n\n  // Snow showers\n  \"85\": {\n    description: \"Slight snow showers\",\n    category: \"snowShowers\",\n    intensity: \"light\",\n  },\n  \"86\": {\n    description: \"Heavy snow showers\",\n    category: \"snowShowers\",\n    intensity: \"heavy\",\n  },\n\n  // Thunderstorm\n  \"95\": {\n    description: \"Thunderstorm\",\n    category: \"thunderstorm\",\n    intensity: \"moderate\",\n  },\n\n  // Thunderstorm with hail\n  \"96\": {\n    description: \"Thunderstorm with slight hail\",\n    category: \"thunderstormWithHail\",\n    intensity: \"light\",\n  },\n  \"99\": {\n    description: \"Thunderstorm with heavy hail\",\n    category: \"thunderstormWithHail\",\n    intensity: \"heavy\",\n  },\n};\n\ntype Conditions = {\n  description: string;\n  category: string;\n  intensity?: string;\n};\n\ntype WeatherOutput = {\n  location: string;\n  conditions: Conditions;\n  time: string;\n  temperature: string;\n  is_day: boolean;\n  precipitation: string;\n  snowfall?: boolean;\n  rain?: boolean;\n  showers?: boolean;\n};\n\nfunction geocodingUrl(location: string) {\n  return `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(location)}&count=10&language=en&format=json`;\n}\n\nfunction weatherUrl(latitude: number, longitude: number) {\n  // current=temperature_2m,is_day,precipitation,rain,showers,snowfall&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch&timezone=auto&forecast_days=1\n  return `https://api.open-meteo.com/v1/forecast?latitude=${encodeURIComponent(latitude)}&longitude=${encodeURIComponent(longitude)}&current=weather_code,temperature_2m,is_day,precipitation,rain,showers,snowfall&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch&timezone=auto&forecast_days=1`;\n}\n\nfunction getConditions(weather_code: number): Conditions {\n  const code = `${weather_code}`;\n  const conditions = WEATHER_CODES[code];\n  return conditions;\n}\n\nasync function invoke({\n  location,\n}: WeatherInputs): Promise<Outcome<WeatherOutputs>> {\n  const geocodingResponse = await fetch({ url: geocodingUrl(location) });\n  if (\"$error\" in geocodingResponse) {\n    return { $error: geocodingResponse.$error as string };\n  }\n  const geocodingResults = geocodingResponse.response as GeocodingResults;\n  if (!geocodingResults.results) {\n    return { $error: `No results for location: \"${location}\"` };\n  }\n  const { latitude, longitude } = geocodingResults.results.at(0) || {};\n  if (!latitude || !longitude) {\n    return { $error: `No latitude/longitude for location: \"${location}\"` };\n  }\n  const weatherResponse = await fetch({ url: weatherUrl(latitude, longitude) });\n  if (\"$error\" in weatherResponse) {\n    return { $error: weatherResponse.$error as string };\n  }\n  const { current } = weatherResponse.response as WeatherResults;\n\n  const precipitation = current.precipitation\n    ? `${current.precipitation} inches`\n    : \"none\";\n  const weather: WeatherOutput = {\n    location,\n    conditions: getConditions(current.weather_code),\n    time: current.time,\n    is_day: current.is_day == 1,\n    precipitation,\n    temperature: `${current.temperature_2m} F`,\n  };\n  if (current.showers) {\n    weather.showers = true;\n  }\n  if (current.snowfall) {\n    weather.snowfall = true;\n  }\n  if (current.rain) {\n    weather.rain = true;\n  }\n  return { weather };\n}\n\nasync function describe() {\n  return {\n    inputSchema: {\n      type: \"object\",\n      properties: {\n        location: {\n          type: \"string\",\n          title: \"Location\",\n          description: \"The name of the city\",\n        },\n      },\n    } satisfies Schema,\n    outputSchema: {\n      type: \"object\",\n      properties: {\n        weather: {\n          type: \"object\",\n          title: \"Current Weather\",\n        },\n      },\n    } satisfies Schema,\n  };\n}\n",
          "language": "typescript"
        },
        "description": "The actual tool that gets the weather.",
        "runnable": false
      }
    },
    "tool-search-wikipedia": {
      "code": "/**\n * @fileoverview Raw Search Wikipedia tool.\n */\nimport fetch from \"@fetch\";\nexport { invoke as default, describe };\nfunction searchURL(query) {\n    return `https://en.wikipedia.org/w/api.php?action=opensearch&search=${query}&origin=*`;\n}\nfunction pageQueryURL(page) {\n    return `https://en.wikipedia.org/w/api.php?action=query&format=json&prop=revisions%7Cextracts&titles=${page}&redirects=1&formatversion=2&rvlimit=1&explaintext=1&origin=*`;\n}\nasync function invoke({ query, }) {\n    if (!query) {\n        return { $error: \"No search query provided.\" };\n    }\n    const gettingTitles = await fetch({\n        url: searchURL(query),\n        method: \"GET\",\n    });\n    if (\"$error\" in gettingTitles) {\n        return gettingTitles;\n    }\n    const response = gettingTitles.response;\n    const titles = response.at(3)?.map((item) => decodeURIComponent(item.slice(30))) || [];\n    if (!titles.length) {\n        return { $error: `No titles found` };\n    }\n    const extracts = await Promise.all(titles.map(async (title) => {\n        const gettingPage = (await fetch({\n            url: pageQueryURL(title),\n            method: \"GET\",\n        }));\n        if (\"$error\" in gettingPage) {\n            return { $error: `Error getting page: ${title}` };\n        }\n        console.log(\"GETTING PAGE\", gettingPage.response);\n        const extract = gettingPage.response.query.pages.at(0)?.extract;\n        if (!extract) {\n            return { $error: `Error getting extract: ${title}` };\n        }\n        return extract;\n    }));\n    const errors = extracts.filter((item) => typeof item !== \"string\");\n    if (errors.length) {\n        return { $error: errors.join(\"\\n\\n\") };\n    }\n    return {\n        result: extracts,\n    };\n}\nasync function describe() {\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                query: {\n                    type: \"string\",\n                    title: \"Query\",\n                    description: \"The query to use for searching Wikipedia\",\n                },\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                result: {\n                    type: \"object\",\n                    title: \"Result\",\n                    description: \"Wikipedia Search Result\",\n                },\n            },\n        },\n    };\n}\n",
      "metadata": {
        "title": "tool-search-wikipedia",
        "source": {
          "code": "/**\n * @fileoverview Raw Search Wikipedia tool.\n */\n\nimport fetch from \"@fetch\";\n\nexport { invoke as default, describe };\n\nexport type WikipediaInputs = {\n  query: string;\n};\n\nexport type WikipediaOutputs = {\n  result: string[];\n};\n\ntype WikipediaResponse = string[][];\n\ntype WikipediaPageResponse = {\n  response: {\n    query: {\n      pages: {\n        extract: string;\n      }[];\n    };\n  };\n};\n\nfunction searchURL(query: string) {\n  return `https://en.wikipedia.org/w/api.php?action=opensearch&search=${query}&origin=*`;\n}\n\nfunction pageQueryURL(page: string) {\n  return `https://en.wikipedia.org/w/api.php?action=query&format=json&prop=revisions%7Cextracts&titles=${page}&redirects=1&formatversion=2&rvlimit=1&explaintext=1&origin=*`;\n}\n\nasync function invoke({\n  query,\n}: WikipediaInputs): Promise<Outcome<WikipediaOutputs>> {\n  if (!query) {\n    return { $error: \"No search query provided.\" };\n  }\n\n  const gettingTitles = await fetch({\n    url: searchURL(query),\n    method: \"GET\",\n  });\n  if (\"$error\" in gettingTitles) {\n    return gettingTitles as Outcome<WikipediaOutputs>;\n  }\n  const response = gettingTitles.response as WikipediaResponse;\n  const titles =\n    response.at(3)?.map((item) => decodeURIComponent(item.slice(30))) || [];\n  if (!titles.length) {\n    return { $error: `No titles found` };\n  }\n  const extracts = await Promise.all(\n    titles.map(async (title) => {\n      const gettingPage = (await fetch({\n        url: pageQueryURL(title),\n        method: \"GET\",\n      })) as Outcome<WikipediaPageResponse>;\n      if (\"$error\" in gettingPage) {\n        return { $error: `Error getting page: ${title}` };\n      }\n      console.log(\"GETTING PAGE\", gettingPage.response);\n      const extract = gettingPage.response.query.pages.at(0)?.extract;\n      if (!extract) {\n        return { $error: `Error getting extract: ${title}` };\n      }\n      return extract;\n    })\n  );\n  const errors = extracts.filter((item) => typeof item !== \"string\");\n  if (errors.length) {\n    return { $error: errors.join(\"\\n\\n\") };\n  }\n  return {\n    result: extracts as string[],\n  };\n}\n\nasync function describe() {\n  return {\n    inputSchema: {\n      type: \"object\",\n      properties: {\n        query: {\n          type: \"string\",\n          title: \"Query\",\n          description: \"The query to use for searching Wikipedia\",\n        },\n      },\n    } satisfies Schema,\n    outputSchema: {\n      type: \"object\",\n      properties: {\n        result: {\n          type: \"object\",\n          title: \"Result\",\n          description: \"Wikipedia Search Result\",\n        },\n      },\n    } satisfies Schema,\n  };\n}\n",
          "language": "typescript"
        },
        "description": "Raw Search Wikipedia tool.",
        "runnable": false
      }
    },
    "tool-search-web": {
      "code": "/**\n * @fileoverview The internal-only implementation of the Search Web tool.\n */\nimport { ToolManager } from \"./a2/tool-manager\";\nimport { GeminiPrompt } from \"./a2/gemini-prompt\";\nimport { ok, toText } from \"./a2/utils\";\nimport secrets from \"@secrets\";\nimport fetch from \"@fetch\";\nexport { invoke as default, describe };\nasync function generateSummary(query) {\n    const toolManager = new ToolManager();\n    toolManager.addSearch();\n    const result = await new GeminiPrompt({\n        model: \"gemini-2.0-flash\",\n        body: {\n            contents: [{ parts: [{ text: query }] }],\n            tools: toolManager.list(),\n        },\n    }, toolManager).invoke();\n    if (!ok(result)) {\n        return result;\n    }\n    let results = toText(result.last);\n    const chunks = result.candidate?.groundingMetadata?.groundingChunks?.map((chunk) => {\n        const { title, uri } = chunk.web;\n        return `- [${title}](${uri})`;\n    }) || [];\n    if (chunks.length) {\n        results += `\\n## References:\\n${chunks.join(\"\\n\")}\\n`;\n    }\n    return `\\n## Summary\\n${results}`;\n}\nfunction formatSearchResults(results) {\n    return `## Raw Search Results\n\n${results.items\n        .map((item) => {\n        return `- [${item.title}](${item.link})\n${item.snippet}\n`;\n    })\n        .join(\"\\n\\n\")}\n`;\n}\nasync function getSearchLinks(query) {\n    const keys = await secrets({ keys: [\"CSE_ID\", \"SEARCH_API_KEY\"] });\n    if (!ok(keys)) {\n        return keys;\n    }\n    const url = `https://customsearch.googleapis.com/customsearch/v1?cx=${keys.CSE_ID}&q=${query}&key=${keys.SEARCH_API_KEY}`;\n    const fetching = await fetch({ url });\n    if (!ok(fetching)) {\n        return fetching;\n    }\n    const searchResults = fetching.response;\n    return formatSearchResults(searchResults);\n}\nasync function invoke({ query, }) {\n    const [summary, links] = await Promise.all([\n        generateSummary(query),\n        getSearchLinks(query),\n    ]);\n    if (!ok(summary)) {\n        return summary;\n    }\n    if (!ok(links)) {\n        return links;\n    }\n    return { results: `Query: ${query}\\n${summary}\\n${links}` };\n}\nasync function describe() {\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                query: {\n                    type: \"string\",\n                    title: \"Query\",\n                    description: \"The query to use with which to search the Web\",\n                },\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context out\",\n                },\n            },\n        },\n    };\n}\n",
      "metadata": {
        "title": "tool-search-web",
        "source": {
          "code": "/**\n * @fileoverview The internal-only implementation of the Search Web tool.\n */\n\nimport { ToolManager } from \"./a2/tool-manager\";\nimport { GeminiPrompt } from \"./a2/gemini-prompt\";\nimport { ok, toText } from \"./a2/utils\";\n\nimport secrets from \"@secrets\";\nimport fetch from \"@fetch\";\n\nexport { invoke as default, describe };\n\nexport type SearchWebInputs = {\n  query: string;\n};\n\nexport type SearchWebOutputs = {\n  results: string;\n};\n\nexport type CustomSearchEngineResponse = {\n  queries: {\n    request: {\n      title: string;\n    }[];\n  };\n  items: {\n    title: string;\n    snippet: string;\n    link: string;\n  }[];\n};\n\nasync function generateSummary(query: string): Promise<Outcome<string>> {\n  const toolManager = new ToolManager();\n  toolManager.addSearch();\n  const result = await new GeminiPrompt(\n    {\n      model: \"gemini-2.0-flash\",\n      body: {\n        contents: [{ parts: [{ text: query }] }],\n        tools: toolManager.list(),\n      },\n    },\n    toolManager\n  ).invoke();\n  if (!ok(result)) {\n    return result;\n  }\n  let results = toText(result.last);\n  const chunks =\n    result.candidate?.groundingMetadata?.groundingChunks?.map((chunk) => {\n      const { title, uri } = chunk.web;\n      return `- [${title}](${uri})`;\n    }) || [];\n  if (chunks.length) {\n    results += `\\n## References:\\n${chunks.join(\"\\n\")}\\n`;\n  }\n  return `\\n## Summary\\n${results}`;\n}\n\nfunction formatSearchResults(results: CustomSearchEngineResponse) {\n  return `## Raw Search Results\n\n${results.items\n  .map((item) => {\n    return `- [${item.title}](${item.link})\n${item.snippet}\n`;\n  })\n  .join(\"\\n\\n\")}\n`;\n}\n\nasync function getSearchLinks(query: string): Promise<Outcome<string>> {\n  const keys = await secrets({ keys: [\"CSE_ID\", \"SEARCH_API_KEY\"] });\n  if (!ok(keys)) {\n    return keys;\n  }\n  const url = `https://customsearch.googleapis.com/customsearch/v1?cx=${keys.CSE_ID}&q=${query}&key=${keys.SEARCH_API_KEY}`;\n  const fetching = await fetch({ url });\n  if (!ok(fetching)) {\n    return fetching;\n  }\n  const searchResults = fetching.response as CustomSearchEngineResponse;\n\n  return formatSearchResults(searchResults);\n}\n\nasync function invoke({\n  query,\n}: SearchWebInputs): Promise<Outcome<SearchWebOutputs>> {\n  const [summary, links] = await Promise.all([\n    generateSummary(query),\n    getSearchLinks(query),\n  ]);\n  if (!ok(summary)) {\n    return summary;\n  }\n  if (!ok(links)) {\n    return links;\n  }\n  return { results: `Query: ${query}\\n${summary}\\n${links}` };\n}\n\nasync function describe() {\n  return {\n    inputSchema: {\n      type: \"object\",\n      properties: {\n        query: {\n          type: \"string\",\n          title: \"Query\",\n          description: \"The query to use with which to search the Web\",\n        },\n      },\n    } satisfies Schema,\n    outputSchema: {\n      type: \"object\",\n      properties: {\n        context: {\n          type: \"array\",\n          items: { type: \"object\", behavior: [\"llm-content\"] },\n          title: \"Context out\",\n        },\n      },\n    } satisfies Schema,\n  };\n}\n",
          "language": "typescript"
        },
        "description": "The internal-only implementation of the Search Web tool.",
        "runnable": false
      }
    },
    "tool-search-maps": {
      "code": "/**\n * @fileoverview The guts of the Search Maps tool.\n */\nimport secrets from \"@secrets\";\nimport fetch from \"@fetch\";\nimport { ok } from \"./a2/utils\";\nexport { invoke as default, describe };\nfunction formatResults(query, results) {\n    return `Search Query: ${query}\n\n\n## Google Places Search Results\n\n${results.places\n        .map((place) => {\n        const title = place.websiteUri\n            ? `[${place.displayName.text}](${place.websiteUri})`\n            : place.displayName.text;\n        return `- ${title}\\n\n  ${place.editorialSummary?.text || \"\"} \n  Address: ${place.formattedAddress}\n  User Rating: ${place.rating} (${place.userRatingCount} reviews)\n  `;\n    })\n        .join(\"\\n\\n\")}\n`;\n}\nasync function invoke({ query, }) {\n    const key = await secrets({ keys: [\"GOOGLE_MAPS_API_KEY\"] });\n    if (!ok(key)) {\n        return key;\n    }\n    const fetching = await fetch({\n        url: \"https://places.googleapis.com/v1/places:searchText\",\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\",\n            \"X-Goog-Api-Key\": `${key.GOOGLE_MAPS_API_KEY}`,\n            \"X-Goog-FieldMask\": \"places.id,places.displayName,places.formattedAddress,places.websiteUri,places.rating,places.userRatingCount,places.editorialSummary\",\n        },\n        body: {\n            textQuery: query,\n        },\n    });\n    if (!ok(fetching)) {\n        return fetching;\n    }\n    return {\n        results: formatResults(query, fetching.response),\n    };\n}\nasync function describe() {\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                query: {\n                    type: \"string\",\n                    title: \"Query\",\n                    description: \"Google Places API search query, typically formulated as [type of place] near [location]\",\n                },\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                results: {\n                    type: \"string\",\n                    title: \"Search Results\",\n                },\n            },\n        },\n    };\n}\n",
      "metadata": {
        "title": "tool-search-maps",
        "source": {
          "code": "/**\n * @fileoverview The guts of the Search Maps tool.\n */\n\nimport secrets from \"@secrets\";\nimport fetch from \"@fetch\";\n\nimport { ok } from \"./a2/utils\";\n\nexport { invoke as default, describe };\n\nexport type SearchMapsInputs = {\n  query: string;\n};\n\nexport type SearchMapsOutputs = {\n  results: string;\n};\n\nexport type SearchMapResults = {\n  places: {\n    id: string;\n    formattedAddress: string;\n    websiteUri: string;\n    rating: number;\n    userRatingCount: number;\n    displayName: {\n      text: string;\n      languageCode: string;\n    };\n    editorialSummary: {\n      text: string;\n      languageCode: string;\n    };\n  }[];\n};\n\nfunction formatResults(query: string, results: SearchMapResults) {\n  return `Search Query: ${query}\n\n\n## Google Places Search Results\n\n${results.places\n  .map((place) => {\n    const title = place.websiteUri\n      ? `[${place.displayName.text}](${place.websiteUri})`\n      : place.displayName.text;\n    return `- ${title}\\n\n  ${place.editorialSummary?.text || \"\"} \n  Address: ${place.formattedAddress}\n  User Rating: ${place.rating} (${place.userRatingCount} reviews)\n  `;\n  })\n  .join(\"\\n\\n\")}\n`;\n}\n\nasync function invoke({\n  query,\n}: SearchMapsInputs): Promise<Outcome<SearchMapsOutputs>> {\n  const key = await secrets({ keys: [\"GOOGLE_MAPS_API_KEY\"] });\n  if (!ok(key)) {\n    return key;\n  }\n  const fetching = await fetch({\n    url: \"https://places.googleapis.com/v1/places:searchText\",\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      \"X-Goog-Api-Key\": `${key.GOOGLE_MAPS_API_KEY}`,\n      \"X-Goog-FieldMask\":\n        \"places.id,places.displayName,places.formattedAddress,places.websiteUri,places.rating,places.userRatingCount,places.editorialSummary\",\n    },\n    body: {\n      textQuery: query,\n    },\n  });\n  if (!ok(fetching)) {\n    return fetching;\n  }\n  return {\n    results: formatResults(query, fetching.response as SearchMapResults),\n  };\n}\n\nasync function describe() {\n  return {\n    inputSchema: {\n      type: \"object\",\n      properties: {\n        query: {\n          type: \"string\",\n          title: \"Query\",\n          description:\n            \"Google Places API search query, typically formulated as [type of place] near [location]\",\n        },\n      },\n    } satisfies Schema,\n    outputSchema: {\n      type: \"object\",\n      properties: {\n        results: {\n          type: \"string\",\n          title: \"Search Results\",\n        },\n      },\n    } satisfies Schema,\n  };\n}\n",
          "language": "typescript"
        },
        "description": "The guts of the Search Maps tool.",
        "runnable": false
      }
    },
    "tool-get-webpage": {
      "code": "/**\n * @fileoverview The guts of the Get webpage tool.\n */\nimport fetch from \"@fetch\";\nimport { ok } from \"./a2/utils\";\nexport { invoke as default, describe };\nasync function invoke({ url, }) {\n    const fetching = await fetch({\n        url: `https://paulkinlan-markdownify_webpage.web.val.run/?url=${encodeURIComponent(url)}`,\n    });\n    if (!ok(fetching)) {\n        return fetching;\n    }\n    const results = fetching.response;\n    return { results };\n}\nasync function describe() {\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                url: {\n                    type: \"string\",\n                    title: \"URL\",\n                    description: \"The URL of the webpage whose content will retrieved\",\n                },\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                results: {\n                    type: \"string\",\n                    title: \"Contents of the webpage\",\n                },\n            },\n        },\n    };\n}\n",
      "metadata": {
        "title": "tool-get-webpage",
        "source": {
          "code": "/**\n * @fileoverview The guts of the Get webpage tool.\n */\n\nimport fetch from \"@fetch\";\nimport { ok } from \"./a2/utils\";\n\nexport { invoke as default, describe };\n\nexport type GetWebPageInputs = {\n  url: string;\n};\n\nexport type GetWebPageOutputs = {\n  results: string;\n};\n\nexport type GetWebPageResults = string;\n\nasync function invoke({\n  url,\n}: GetWebPageInputs): Promise<Outcome<GetWebPageOutputs>> {\n  const fetching = await fetch({\n    url: `https://paulkinlan-markdownify_webpage.web.val.run/?url=${encodeURIComponent(url)}`,\n  });\n  if (!ok(fetching)) {\n    return fetching;\n  }\n  const results = fetching.response as GetWebPageResults;\n  return { results };\n}\n\nasync function describe() {\n  return {\n    inputSchema: {\n      type: \"object\",\n      properties: {\n        url: {\n          type: \"string\",\n          title: \"URL\",\n          description: \"The URL of the webpage whose content will retrieved\",\n        },\n      },\n    } satisfies Schema,\n    outputSchema: {\n      type: \"object\",\n      properties: {\n        results: {\n          type: \"string\",\n          title: \"Contents of the webpage\",\n        },\n      },\n    } satisfies Schema,\n  };\n}\n",
          "language": "typescript"
        },
        "description": "The guts of the Get webpage tool.",
        "runnable": false
      }
    }
  },
  "exports": [
    "#module:get-weather",
    "#module:search-web",
    "#module:search-wikipedia",
    "#module:get-webpage",
    "#module:search-maps"
  ]
}