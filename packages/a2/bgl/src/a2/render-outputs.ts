/**
 * @fileoverview Renders multiple outputs into single display.
 */

import { ConnectorManager } from "./connector-manager";
import { callGenWebpage } from "./html-generator";
import { flattenContext } from "./lists";
import { readFlags } from "./settings";
import { Template } from "./template";
import { err, llm, mergeContent, ok, toLLMContent, toText } from "./utils";

import read from "@read";

export { invoke as default, describe };

const MANUAL_MODE = "Manual layout";
const FLASH_MODE = "Webpage with auto-layout by 2.5 Flash";
const PRO_MODE = "Webpage with auto-layout by 2.5 Pro";

type RenderType =
  | "Manual"
  | "HTML"
  | "GoogleDoc"
  | "GoogleSlides"
  | "GoogleSheets"
  | "Code";

type Mode = {
  id: string;
  renderType: RenderType;
  title: string;
  description: string;
  icon: string;
};

type Model = {
  id: string;
  title: string;
  description: string;
  modelName: string;
};

const MODELS: Model[] = [
  {
    id: "gemini-flash",
    title: "Gemini 2.5 Flash",
    description: "Best for coding simple, static displays",
    modelName: "gemini-2.5-flash",
  },
  {
    id: "gemini-flash-lite",
    title: "Gemini 2.5 Flash Lite",
    description: "Best for simple speedy displays",
    modelName: "gemini-2.5-flash-lite",
  },
  {
    id: "gemini-pro",
    title: "Gemini 2.5 Pro",
    description: "Best for coding complex or interactive displays",
    modelName: "gemini-2.5-pro",
  },
];

const MODES: Mode[] = [
  {
    id: MANUAL_MODE,
    renderType: "Manual",
    icon: "responsive_layout",
    title: "Manual layout",
    description: "Content is displayed exactly as typed",
  },
  {
    id: "Auto",
    renderType: "HTML",
    icon: "web",
    title: "Webpage with auto-layout",
    description: "Layout automatically generated by Gemini",
  },
  {
    id: "google-doc",
    renderType: "GoogleDoc",
    title: "Save to Google Docs",
    icon: "docs",
    description: "Save content to a Google Document",
  },
  {
    id: "google-slides",
    renderType: "GoogleSlides",
    title: "Save to Google Slides",
    icon: "drive_presentation",
    description: "Save content as a Google Drive Presentation",
  },
  {
    id: "google-sheets",
    renderType: "GoogleSheets",
    title: "Save to Google Sheets",
    icon: "sheets",
    description: "Save content as a Google Drive Spreadsheet",
  },
  {
    id: "code",
    renderType: "Code",
    title: "Save as code",
    icon: "code",
    description: "Generate and save code to your folder",
  },
] as const;

const renderModeMap = new Map(MODES.map((mode) => [mode.id, mode]));

function getMode(modeId: string | undefined): Mode {
  return renderModeMap.get(modeId || "Manual") || MODES[0];
}

const modelMap = new Map(MODELS.map((model) => [model.id, model]));

function getModel(modelType: string | undefined): Model {
  return modelMap.get(modelType || "gemini-flash") || MODELS[0];
}

function defaultSystemInstruction(): LLMContent {
  return llm`You are a skilled web developer specializing in creating intuitive and visually appealing HTML web pages based on user instructions and data. Your task is to generate a valid HTML webpage that will be rendered in an iframe. The generated code must be valid and functional HTML with JavaScript and CSS embedded inline within <script> and <style> tags respectively. Return only the code, and open the HTML codeblock with the literal string '\`\`\`html'. Render content as a clean, well-structured webpage, paying careful attention to user instructions. Use a responsive or mobile-friendly layout whenever possible and minimize unnecessary padding or margins.`.asContent();
}

type InvokeInputs = {
  text?: LLMContent;
  "p-render-mode": string;
  "b-system-instruction"?: LLMContent;
  "b-render-model-name": string;
  "b-google-doc-title"?: string;
};

type InvokeOutputs = {
  context: LLMContent[];
};

type DescribeInputs = {
  inputs: {
    text?: LLMContent;
    "p-render-mode": string;
  };
};

type GraphMetadata = {
  title?: string;
  description?: string;
  version?: string;
  url?: string;
  icon?: string;
  visual?: {
    presentation?: Presentation;
  };
  userModified?: boolean;
  tags?: string[];
  comments: Comment[];
};

type Comment = {
  id: string;
  text: string;
  metadata: {
    title: string;
    visual: {
      x: number;
      y: number;
      collapsed: "expanded";
      outputHeight: number;
    };
  };
};

type Presentation = {
  themes?: Record<string, Theme>;
  theme?: string;
};

type Theme = {
  themeColors?: ThemeColors;
  palette?: PaletteColors;
  template?: string;
  splashScreen?: StoredDataCapabilityPart;
};

type ThemeColors = {
  primaryColor?: string;
  secondaryColor?: string;
  backgroundColor?: string;
  textColor?: string;
  primaryTextColor?: string;
};

type Color = {
  25?: string;
  50?: string;
  80?: string;
  90?: string;
  95?: string;
  98?: string;
};

type PaletteColors = {
  error?: Color;
  neutral?: Color;
  neutralVariant?: Color;
  primary?: Color;
  secondary?: Color;
  tertiary?: Color;
};

function defaultThemeColors(): ThemeColors {
  return {
    primaryColor: "#246db5",
    secondaryColor: "#5cadff",
    backgroundColor: "#ffffff",
    textColor: "#1a1a1a",
    primaryTextColor: "#ffffff",
  };
}

async function getThemeColors(): Promise<ThemeColors> {
  const readingMetadata = await read({ path: "/env/metadata" });
  if (!ok(readingMetadata)) return defaultThemeColors();
  const metadata = (readingMetadata.data?.at(0)?.parts?.at(0) as JSONPart)
    ?.json as GraphMetadata;
  if (!metadata) return defaultThemeColors();
  const currentThemeId = metadata?.visual?.presentation?.theme;
  if (!currentThemeId) return defaultThemeColors();
  const themeColors =
    metadata?.visual?.presentation?.themes?.[currentThemeId]?.themeColors;
  if (!themeColors) return defaultThemeColors();
  return { ...defaultThemeColors(), ...themeColors };
}

async function getPaletteColors(): Promise<PaletteColors | undefined> {
  const readingMetadata = await read({ path: "/env/metadata" });
  if (!ok(readingMetadata)) return;
  const metadata = (readingMetadata.data?.at(0)?.parts?.at(0) as JSONPart)
    ?.json as GraphMetadata;
  if (!metadata) return;
  const currentThemeId = metadata?.visual?.presentation?.theme;
  if (!currentThemeId) return;
  const palette =
    metadata?.visual?.presentation?.themes?.[currentThemeId]?.palette;
  if (!palette) return {};
  return { ...palette };
}

function themeColorsPrompt(colors: ThemeColors): string {
  return `Unless otherwise specified, use the following theme colors:

- primary color: ${colors.primaryColor}
- secondary color: ${colors.secondaryColor}
- background color: ${colors.backgroundColor}
- text color: ${colors.textColor}
- primary text color: ${colors.primaryTextColor}

`;
}

function getPalettePrompt(colors: PaletteColors): string {
  return `Unless otherwise specified, use the following theme colors:
  
  - primary color, dark: ${colors.primary?.[25]}
  - primary color, light: ${colors.primary?.[98]}
  - secondary color, dark: ${colors.secondary?.[25]}
  - secondary color, light: ${colors.secondary?.[95]}
  - tertiary color, dark: ${colors.tertiary?.[25]}
  - tertiary color, light: ${colors.tertiary?.[80]}
  - background color: ${colors.secondary?.[90]}
  - error color: ${colors.error?.[50]}
  - neutral, dark: ${colors.neutral?.[25]}
  - neutral, light: ${colors.neutral?.[98]}
  `;
}

async function saveToGoogleDrive(
  content: LLMContent,
  mimeType: string,
  title: string | undefined
): Promise<Outcome<void>> {
  const manager = new ConnectorManager({
    url: "embed://a2/google-drive.bgl.json",
    configuration: { file: { mimeType } },
  });
  const saving = await manager.save([content], { title });
  if (!ok(saving)) return saving;
}

async function saveAsCode(content: LLMContent): Promise<Outcome<void>> {
  const manager = new ConnectorManager({
    url: "embed://a2/file-system.bgl.json",
    configuration: {},
  });
  const saving = await manager.save([content], {});
  if (!ok(saving)) return saving;
}

async function invoke({
  text,
  "p-render-mode": renderMode,
  "b-system-instruction": systemInstruction,
  "b-render-model-name": modelType,
  "b-google-doc-title": googleDocTitle,
  ...params
}: InvokeInputs): Promise<Outcome<InvokeOutputs>> {
  let { modelName } = getModel(modelType);
  const { renderType } = getMode(renderMode);

  if (!text) {
    text = toLLMContent("");
  }
  if (!systemInstruction) {
    systemInstruction = defaultSystemInstruction();
  }
  let systemText = toText(systemInstruction);
  const template = new Template(text);
  const substituting = await template.substitute(params, async () => "");
  if (!ok(substituting)) {
    return substituting;
  }

  const context = mergeContent(
    flattenContext([substituting], true, "\n\n"),
    "user"
  );
  // If the step uses one of the deprecated modes that encodes model, trust this.
  if (renderMode == FLASH_MODE) {
    modelName = "gemini-2.5-flash";
  } else if (renderMode == PRO_MODE) {
    modelName = "gemini-2.5-pro";
  }
  console.log("Rendering with mode: ", renderType);
  console.log("Rendering with model: ", modelName);
  let out = context;
  switch (renderType) {
    case "Manual":
      return { context: [out] };
    case "HTML": {
      const palette = await getPaletteColors();
      if (palette?.primary) {
        systemText += getPalettePrompt(palette);
      } else {
        const themeColors = await getThemeColors();
        systemText += themeColorsPrompt(themeColors);
      }
      console.log("SI :", systemText);
      const webPage = await callGenWebpage(
        systemText,
        [context],
        renderType,
        modelName
      );
      if (!ok(webPage)) {
        console.error("Failed to generate html output", webPage.$error);
        return webPage;
      } else {
        out = await webPage;
        console.log(out);
      }
      if (!ok(out)) return err(out);
      return { context: [out] };
    }
    case "GoogleDoc": {
      const saving = await saveToGoogleDrive(
        out,
        "application/vnd.google-apps.document",
        googleDocTitle
      );
      if (!ok(saving)) return saving;
      return { context: [out] };
    }
    case "GoogleSlides": {
      const saving = await saveToGoogleDrive(
        out,
        "application/vnd.google-apps.presentation",
        googleDocTitle
      );
      if (!ok(saving)) return saving;
      return { context: [out] };
    }
    case "GoogleSheets": {
      const saving = await saveToGoogleDrive(
        out,
        "application/vnd.google-apps.spreadsheet",
        googleDocTitle
      );
      if (!ok(saving)) return saving;
      return { context: [out] };
    }
    case "Code": {
      const generating = await callGenWebpage(
        systemText,
        [context],
        "HTML",
        modelName
      );
      if (!ok(generating)) return generating;
      const saving = await saveAsCode(generating);
      if (!ok(saving)) return saving;
      return { context: [out] };
    }
  }
  return { context: [out] };
}

function advancedSettings(renderType: RenderType): Record<string, Schema> {
  switch (renderType) {
    case "HTML":
      return {
        "b-system-instruction": {
          type: "object",
          behavior: ["llm-content", "config", "hint-advanced"],
          title: "System Instruction",
          description: "The system instruction used for auto-layout",
        },
        "b-render-model-name": {
          type: "string",
          enum: MODELS,
          behavior: ["llm-content", "config", "hint-advanced"],
          title: "Model",
          description: "The model to use for auto-generating display code",
        },
      };
    case "GoogleDoc": {
      return {
        "b-google-doc-title": {
          type: "string",
          behavior: ["config", "hint-advanced"],
          title: "Google Doc Title",
          description:
            "The title of the Google Drive Document that content will be saved to",
        },
      };
    }
    case "GoogleSlides": {
      return {
        "b-google-doc-title": {
          type: "string",
          behavior: ["config", "hint-advanced"],
          title: "Google Presentation Title",
          description:
            "The title of a Google Drive Presentation that content will be saved to",
        },
      };
    }
    case "GoogleSheets": {
      return {
        "b-google-doc-title": {
          type: "string",
          behavior: ["config", "hint-advanced"],
          title: "Google Spreadsheet Title",
          description:
            "The title of a Google Drive Spreadsheet that content will be saved to",
        },
      };
    }
    case "Code":
      return {
        "b-system-instruction": {
          type: "object",
          behavior: ["llm-content", "config", "hint-advanced"],
          title: "System Instruction",
          description: "The system instruction used for generating code",
        },
        "b-render-model-name": {
          type: "string",
          enum: MODELS,
          behavior: ["llm-content", "config", "hint-advanced"],
          title: "Model",
          description: "The model to use for generating code",
        },
      };
  }
  return {};
}

async function describe({
  inputs: { text, "p-render-mode": renderMode },
}: DescribeInputs) {
  let showSaveAsCode = false;
  const flags = await readFlags();
  if (ok(flags)) {
    showSaveAsCode = flags["saveAsCode"];
  }
  let modes = MODES;
  if (!showSaveAsCode) {
    modes = MODES.filter(({ id }) => id !== "code");
  }
  const template = new Template(text);
  const { renderType } = getMode(renderMode);
  return {
    inputSchema: {
      type: "object",
      properties: {
        text: {
          type: "object",
          behavior: ["llm-content", "hint-preview", "config", "at-wireable"],
          title: "Outputs to render",
          description:
            "Type the @ character to select the outputs to combine. Optionally include style and layout guidlines if using Rendering mode of Markdown or HTML.",
        },
        "p-render-mode": {
          type: "string",
          enum: modes,
          title: "Display format",
          behavior: ["config", "hint-preview", "reactive", "hint-controller"],
          default: MANUAL_MODE,
          description: "Choose how to combine and display the outputs",
        },
        ...advancedSettings(renderType),
        ...template.schemas(),
      },
      behavior: ["at-wireable"],
      ...template.requireds(),
    } satisfies Schema,
    outputSchema: {
      type: "object",
      properties: {
        context: {
          type: "array",
          items: {
            type: "object",
            behavior: ["llm-content"],
          },
          title: "Context out",
          behavior: ["main-port", "hint-multimodal"],
        },
      },
    } satisfies Schema,
    title: "Output",
    metadata: {
      icon: "output",
      tags: ["quick-access", "core", "output"],
      order: 100,
    },
  };
}
