/**
 * @fileoverview Renders multiple outputs into single display.
 */

import { Template } from "./template";
import {
  ok,
  err,
  llm,
  toText,
  isEmpty,
  mergeContent,
  toLLMContent,
} from "./utils";
import { callGenWebpage } from "./html-generator";
import { fanOutContext, flattenContext } from "./lists";

import read from "@read";

export { invoke as default, describe };

const MANUAL_MODE = "Manual layout";
const FLASH_MODE = "Webpage with auto-layout by 2.5 Flash";
const PRO_MODE = "Webpage with auto-layout by 2.5 Pro";

type Mode = {
  id: string;
  renderType: string;
  title: string;
  description: string;
};

type Model = {
  id: string;
  title: string;
  description: string;
  modelName: string;
};

const MODELS: Model[] = [
  {
    id: "gemini-flash",
    title: "Gemini 2.5 Flash",
    description: "Best for coding simple, static displays",
    modelName: "gemini-2.5-flash-preview-04-17",
  },
  {
    id: "gemini-pro",
    title: "Gemini 2.5 Pro",
    description: "Best for coding complex or interactive displays",
    modelName: "gemini-2.5-pro-preview-05-06",
  },
];

const MODES: Mode[] = [
  {
    id: MANUAL_MODE,
    renderType: "Manual",
    title: "Manual layout",
    description: "Content is displayed exactly as typed",
  },
  {
    id: "Auto",
    renderType: "HTML",
    title: "Webpage with auto-layout",
    description: "Layout automatically generated by Gemini",
  },
];

const renderModeMap = new Map(MODES.map((mode) => [mode.id, mode]));

function getMode(modeId: string | undefined): Mode {
  return renderModeMap.get(modeId || "Manual") || MODES[0];
}

const modelMap = new Map(MODELS.map((model) => [model.id, model]));

function getModel(modelType: string | undefined): Model {
  return modelMap.get(modelType || "gemini-flash") || MODELS[0];
}

function defaultSystemInstruction(): LLMContent {
  return llm`You are a skilled web developer specializing in creating intuitive and visually appealing HTML web pages based on user instructions and data. Your task is to generate a valid HTML webpage that will be rendered in an iframe. The generated code must be valid and functional HTML with JavaScript and CSS embedded inline within <script> and <style> tags respectively. Return only the code, and open the HTML codeblock with the literal string '\`\`\`html'. Render content as a clean, well-structured webpage, paying careful attention to user instructions. Use a responsive or mobile-friendly layout whenever possible and minimize unnecessary padding or margins.`.asContent();
}

type InvokeInputs = {
  text?: LLMContent;
  "p-render-mode": string;
  "b-system-instruction"?: LLMContent;
  "b-render-model-name": string;
};

type DescribeInputs = {
  inputs: {
    text?: LLMContent;
    "p-render-mode": string;
  };
};

type GraphMetadata = {
  title?: string;
  description?: string;
  version?: string;
  url?: string;
  icon?: string;
  visual?: {
    presentation?: Presentation;
  };
  userModified?: boolean;
  tags?: string[];
  comments: Comment[];
};

type Comment = {
  id: string;
  text: string;
  metadata: {
    title: string;
    visual: {
      x: number;
      y: number;
      collapsed: "expanded";
      outputHeight: number;
    };
  };
};

type Presentation = {
  themes?: Record<string, Theme>;
  theme?: string;
};

type Theme = {
  themeColors?: ThemeColors;
  template?: string;
  splashScreen?: StoredDataCapabilityPart;
};

type ThemeColors = {
  primaryColor?: string;
  secondaryColor?: string;
  backgroundColor?: string;
  textColor?: string;
  primaryTextColor?: string;
};

function defaultThemeColors(): ThemeColors {
  return {
    primaryColor: "#246db5",
    secondaryColor: "#5cadff",
    backgroundColor: "#ffffff",
    textColor: "#1a1a1a",
    primaryTextColor: "#ffffff",
  };
}

async function getThemeColors(): Promise<ThemeColors> {
  const readingMetadata = await read({ path: "/env/metadata" });
  if (!ok(readingMetadata)) return defaultThemeColors();
  const metadata = (readingMetadata.data?.at(0)?.parts?.at(0) as JSONPart)
    ?.json as GraphMetadata;
  if (!metadata) return defaultThemeColors();
  const currentThemeId = metadata?.visual?.presentation?.theme;
  if (!currentThemeId) return defaultThemeColors();
  const themeColors =
    metadata?.visual?.presentation?.themes?.[currentThemeId]?.themeColors;
  if (!themeColors) return defaultThemeColors();
  return { ...defaultThemeColors(), ...themeColors };
}

function themeColorsPrompt(colors: ThemeColors): string {
  return `Unless otherwise specified, use the following theme colors:

- primary color: ${colors.primaryColor}
- secondary color: ${colors.secondaryColor}
- background color: ${colors.backgroundColor}
- text color: ${colors.textColor}
- primary text color: ${colors.primaryTextColor}

`;
}

async function invoke({
  text,
  "p-render-mode": renderMode,
  "b-system-instruction": systemInstruction,
  "b-render-model-name": modelType,
  ...params
}: InvokeInputs) {
  let { modelName } = getModel(modelType);
  const { renderType } = getMode(renderMode);

  if (!text) {
    text = toLLMContent("");
  }
  if (!systemInstruction) {
    systemInstruction = defaultSystemInstruction();
  }
  let systemText = toText(systemInstruction);
  const template = new Template(text);
  const substituting = await template.substitute(params, async () => "");
  if (!ok(substituting)) {
    return substituting;
  }

  const context = mergeContent(
    flattenContext([substituting], true, "\n\n"),
    "user"
  );
  // If the step uses one of the deprecated modes that encodes model, trust this.
  if (renderMode == FLASH_MODE) {
    modelName = "gemini-2.5-flash-preview-04-17";
  } else if (renderMode == PRO_MODE) {
    modelName = "gemini-2.5-pro-preview-05-06";
  }
  console.log("Rendering with mode: ", renderType);
  console.log("Rendering with model: ", modelName);
  let out = context;
  if (renderType != "Manual") {
    systemText += themeColorsPrompt(await getThemeColors());
    const webPage = await callGenWebpage(
      systemText,
      [context],
      renderType,
      modelName
    );
    if (!ok(webPage)) {
      console.error("Failed to generated html output");
      return webPage;
    } else {
      out = await webPage;
      console.log(out);
    }
  }
  if (!ok(out)) return err(out);
  return { context: out };
}

function advancedSettings(renderMode: string): Record<string, unknown> {
  if (renderMode === MANUAL_MODE) {
    return {};
  }
  return {
    "b-system-instruction": {
      type: "object",
      behavior: ["llm-content", "config", "hint-advanced"],
      title: "System Instruction",
      description: "The system instruction used for auto-layout",
    },
    "b-render-model-name": {
      type: "string",
      enum: MODELS,
      behavior: ["llm-content", "config", "hint-advanced"],
      title: "Model",
      description: "The model to use for auto-generating display code",
    },
  };
}

async function describe({
  inputs: { text, "p-render-mode": renderMode },
}: DescribeInputs) {
  const template = new Template(text);
  return {
    inputSchema: {
      type: "object",
      properties: {
        text: {
          type: "object",
          behavior: ["llm-content", "hint-preview", "config", "at-wireable"],
          title: "Outputs to render",
          description:
            "Type the @ character to select the outputs to combine. Optionally include style and layout guidlines if using Rendering mode of Markdown or HTML.",
        },
        "p-render-mode": {
          type: "string",
          enum: MODES,
          title: "Display format",
          behavior: ["config", "hint-preview", "reactive", "hint-controller"],
          default: MANUAL_MODE,
          description: "Choose how to combine and display the outputs",
        },
        ...advancedSettings(renderMode),
        ...template.schemas(),
      },
      behavior: ["at-wireable"],
      ...template.requireds(),
    } satisfies Schema,
    outputSchema: {
      type: "object",
      properties: {
        context: {
          type: "array",
          items: {
            type: "object",
            behavior: ["llm-content"],
          },
          title: "Context out",
          behavior: ["main-port", "hint-multimodal"],
        },
      },
    } satisfies Schema,
    title: "Display Output",
    metadata: {
      icon: "display",
      tags: ["quick-access", "core", "output"],
      order: 100,
    },
  };
}
