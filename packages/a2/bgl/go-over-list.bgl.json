{
  "title": "A2 Go Over a List",
  "description": "",
  "version": "0.0.1",
  "nodes": [],
  "edges": [],
  "metadata": {
    "comments": [
      {
        "id": "comment-cc94afe8",
        "text": "Intentionally Left Blank",
        "metadata": {
          "title": "Comment",
          "visual": {
            "x": 531,
            "y": 374,
            "collapsed": "expanded",
            "outputHeight": 0
          }
        }
      }
    ],
    "visual": {},
    "tags": []
  },
  "modules": {
    "main": {
      "code": "/**\n * @fileoverview Turn anything into a list, make a plan for that list, and go over it\n */\nimport { Template } from \"./a2/template\";\nimport { ToolManager } from \"./a2/tool-manager\";\nimport { GeminiPrompt } from \"./a2/gemini-prompt\";\nimport {} from \"./a2/gemini\";\nimport {} from \"./a2/common\";\nimport { ok, err, toLLMContent, llm } from \"./a2/utils\";\nexport { invoke as default, describe };\nfunction planSchema() {\n    return {\n        type: \"object\",\n        properties: {\n            todo: {\n                type: \"array\",\n                items: {\n                    type: \"object\",\n                    properties: { task: { type: \"string\" } },\n                },\n            },\n        },\n    };\n}\nfunction plannerPrompt(plan) {\n    const contents = [plan];\n    const systemInstruction = llm `\nYou are a planner. \nYou are to create a precise plan for a given objective. This plan will be executed by others \nand your responsibility is to produce a plan that fulfills the objective.\n\nYour output must be a valid JSON of the following format:\n\n\\`\\`\\`json\n{\n  \"todo\": [{\n    \"task\": \"string, The task description. Use action-oriented language, starting with a verb that fits the task.\"\n  }]\n}\n\\`\\`\\`\n`.asContent();\n    return new GeminiPrompt({\n        body: {\n            contents,\n            systemInstruction,\n            generationConfig: {\n                responseSchema: planSchema(),\n                responseMimeType: \"application/json\",\n            },\n        },\n    });\n}\nasync function executePlan(plan, toolManager) {\n    const errors = [];\n    const results = await Promise.all(plan.todo.map(async (item) => {\n        const executing = await new GeminiPrompt({\n            body: {\n                contents: [toLLMContent(item.task)],\n                tools: toolManager.list(),\n            },\n        }, toolManager).invoke();\n        if (!ok(executing)) {\n            errors.push(executing.$error);\n            return;\n        }\n        return executing.last;\n    }));\n    if (errors.length > 0) {\n        return err(errors.join(\"\\n\\n\"));\n    }\n    return results;\n}\nasync function invoke({ context, plan, ...params }) {\n    const toolManager = new ToolManager();\n    const template = new Template(plan);\n    const substituting = await template.substitute(params, async ({ path: url }) => toolManager.addTool(url));\n    if (!ok(substituting))\n        return substituting;\n    const planning = await plannerPrompt(plan).invoke();\n    if (!ok(planning))\n        return planning;\n    const planPart = planning.last.parts.at(0);\n    if (!planPart || !(\"json\" in planPart)) {\n        // TODO: Error recovery.\n        return err(`Gemini generated invalid plan`);\n    }\n    const iterating = await executePlan(planPart.json, toolManager);\n    if (!ok(iterating))\n        return iterating;\n    const oneContent = {\n        role: \"model\",\n        parts: iterating.flatMap((item) => {\n            return item.parts;\n        }),\n    };\n    return { context: [oneContent] };\n}\nasync function describe({ inputs: { plan } }) {\n    const template = new Template(plan);\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context in\",\n                    behavior: [\"main-port\"],\n                },\n                plan: {\n                    type: \"object\",\n                    behavior: [\"llm-content\", \"config\", \"hint-preview\"],\n                    title: \"Instruction\",\n                    description: \"Describe what will be turned into a list and then gone over\",\n                },\n                ...template.schemas(),\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                context: {\n                    type: \"array\",\n                    items: { type: \"object\", behavior: [\"llm-content\"] },\n                    title: \"Context out\",\n                },\n            },\n            behavior: [\"at-wireable\"],\n            ...template.requireds(),\n            additionalProperties: false,\n        },\n        title: \"Go over a list\",\n        description: \"Turn anything into a list, make a plan for that list, and go over it\",\n        metadata: {\n            icon: \"laps\",\n            tags: [\"quick-access\", \"generative\", \"experimental\"],\n            order: 102,\n        },\n    };\n}\n",
      "metadata": {
        "title": "main",
        "source": {
          "code": "/**\n * @fileoverview Turn anything into a list, make a plan for that list, and go over it\n */\nimport { Template } from \"./a2/template\";\nimport { ToolManager } from \"./a2/tool-manager\";\nimport { GeminiPrompt } from \"./a2/gemini-prompt\";\nimport { type GeminiSchema, type Tool } from \"./a2/gemini\";\nimport { type Params } from \"./a2/common\";\nimport { ok, err, toLLMContent, llm } from \"./a2/utils\";\n\nexport { invoke as default, describe };\n\ntype Inputs = {\n  context: LLMContent[];\n  plan: LLMContent;\n} & Params;\n\ntype Outputs = {\n  context: LLMContent[];\n};\n\ntype Plan = {\n  todo: {\n    task: string;\n  }[];\n};\n\nfunction planSchema(): GeminiSchema {\n  return {\n    type: \"object\",\n    properties: {\n      todo: {\n        type: \"array\",\n        items: {\n          type: \"object\",\n          properties: { task: { type: \"string\" } },\n        },\n      },\n    },\n  };\n}\n\nfunction plannerPrompt(plan: LLMContent): GeminiPrompt {\n  const contents = [plan];\n  const systemInstruction = llm`\nYou are a planner. \nYou are to create a precise plan for a given objective. This plan will be executed by others \nand your responsibility is to produce a plan that fulfills the objective.\n\nYour output must be a valid JSON of the following format:\n\n\\`\\`\\`json\n{\n  \"todo\": [{\n    \"task\": \"string, The task description. Use action-oriented language, starting with a verb that fits the task.\"\n  }]\n}\n\\`\\`\\`\n`.asContent();\n  return new GeminiPrompt({\n    body: {\n      contents,\n      systemInstruction,\n      generationConfig: {\n        responseSchema: planSchema(),\n        responseMimeType: \"application/json\",\n      },\n    },\n  });\n}\n\nasync function executePlan(\n  plan: Plan,\n  toolManager: ToolManager\n): Promise<Outcome<LLMContent[]>> {\n  const errors: string[] = [];\n  const results = await Promise.all(\n    plan.todo.map(async (item) => {\n      const executing = await new GeminiPrompt(\n        {\n          body: {\n            contents: [toLLMContent(item.task)],\n            tools: toolManager.list(),\n          },\n        },\n        toolManager\n      ).invoke();\n      if (!ok(executing)) {\n        errors.push(executing.$error);\n        return;\n      }\n      return executing.last;\n    })\n  );\n  if (errors.length > 0) {\n    return err(errors.join(\"\\n\\n\"));\n  }\n  return results as LLMContent[];\n}\n\nasync function invoke({\n  context,\n  plan,\n  ...params\n}: Inputs): Promise<Outcome<Outputs>> {\n  const toolManager = new ToolManager();\n  const template = new Template(plan);\n  const substituting = await template.substitute(\n    params,\n    async ({ path: url }) => toolManager.addTool(url)\n  );\n  if (!ok(substituting)) return substituting;\n\n  const planning = await plannerPrompt(plan).invoke();\n  if (!ok(planning)) return planning;\n\n  const planPart = planning.last.parts.at(0);\n  if (!planPart || !(\"json\" in planPart)) {\n    // TODO: Error recovery.\n    return err(`Gemini generated invalid plan`);\n  }\n  const iterating = await executePlan(planPart.json as Plan, toolManager);\n  if (!ok(iterating)) return iterating;\n  const oneContent = {\n    role: \"model\",\n    parts: iterating.flatMap((item) => {\n      return item.parts;\n    }),\n  };\n  return { context: [oneContent] };\n}\n\ntype DescribeInputs = {\n  inputs: {\n    plan: LLMContent;\n  };\n};\n\nasync function describe({ inputs: { plan } }: DescribeInputs) {\n  const template = new Template(plan);\n  return {\n    inputSchema: {\n      type: \"object\",\n      properties: {\n        context: {\n          type: \"array\",\n          items: { type: \"object\", behavior: [\"llm-content\"] },\n          title: \"Context in\",\n          behavior: [\"main-port\"],\n        },\n        plan: {\n          type: \"object\",\n          behavior: [\"llm-content\", \"config\", \"hint-preview\"],\n          title: \"Instruction\",\n          description:\n            \"Describe what will be turned into a list and then gone over\",\n        },\n        ...template.schemas(),\n      },\n    } satisfies Schema,\n    outputSchema: {\n      type: \"object\",\n      properties: {\n        context: {\n          type: \"array\",\n          items: { type: \"object\", behavior: [\"llm-content\"] },\n          title: \"Context out\",\n        },\n      },\n      behavior: [\"at-wireable\"],\n      ...template.requireds(),\n      additionalProperties: false,\n    } satisfies Schema,\n    title: \"Go over a list\",\n    description:\n      \"Turn anything into a list, make a plan for that list, and go over it\",\n    metadata: {\n      icon: \"laps\",\n      tags: [\"quick-access\", \"generative\", \"experimental\"],\n      order: 102,\n    },\n  };\n}\n",
          "language": "typescript"
        },
        "description": "Turn anything into a list, make a plan for that list, and go over it",
        "runnable": true
      }
    }
  },
  "imports": {
    "a2": {
      "url": "./a2.bgl.json"
    }
  },
  "exports": [
    "#module:main"
  ]
}