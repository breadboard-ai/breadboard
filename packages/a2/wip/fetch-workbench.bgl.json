{
  "title": "Fetch Workbench",
  "description": "",
  "version": "0.0.1",
  "nodes": [
    {
      "id": "input",
      "type": "input",
      "metadata": {
        "title": "Input"
      }
    },
    {
      "id": "run-module",
      "type": "runModule",
      "configuration": {
        "$module": "main"
      },
      "metadata": {
        "title": "Fetch Workbench"
      }
    },
    {
      "id": "output",
      "type": "output",
      "metadata": {
        "title": "Output"
      }
    }
  ],
  "edges": [
    {
      "from": "input",
      "to": "run-module",
      "out": "*",
      "in": ""
    },
    {
      "from": "run-module",
      "to": "output",
      "out": "*",
      "in": ""
    }
  ],
  "main": "main",
  "metadata": {
    "visual": {
      "presentation": {
        "themes": {
          "39239b49-62d0-4182-b919-924c4db67941": {
            "themeColors": {
              "primaryColor": "#246db5",
              "secondaryColor": "#5cadff",
              "backgroundColor": "#ffffff",
              "textColor": "#1a1a1a",
              "primaryTextColor": "#ffffff"
            },
            "template": "basic",
            "splashScreen": {
              "storedData": {
                "handle": "/images/app/generic-flow.jpg",
                "mimeType": "image/jpeg"
              }
            }
          }
        },
        "theme": "39239b49-62d0-4182-b919-924c4db67941"
      }
    },
    "userModified": true,
    "tags": [],
    "parameters": {}
  },
  "modules": {
    "main": {
      "code": "/**\n * @fileoverview Add a description for your module here.\n */\nimport fetch from \"@fetch\";\nimport read from \"@read\";\nimport write from \"@write\";\nimport query from \"@query\";\nimport output from \"@output\";\nimport { ok, err } from \"./a2/utils\";\nimport { report } from \"./a2/output\";\nexport { invoke as default, describe };\nfunction json(result) {\n    if (!ok(result))\n        return result;\n    const j = result.data?.at(-1)?.parts.at(0)?.json;\n    if (!j) {\n        return err(`Invalid result structure`);\n    }\n    return j;\n}\nfunction sse(result) {\n    const e = json(result);\n    if (!ok(e))\n        return e;\n    return e.data;\n}\nfunction rpc(result) {\n    const e = sse(result);\n    if (!ok(e))\n        return e;\n    return e.result;\n}\nclass McpClient {\n    connectorId;\n    url;\n    #id = 0;\n    #messageEndpoint = null;\n    constructor(connectorId, url) {\n        this.connectorId = connectorId;\n        this.url = url;\n    }\n    #path() {\n        return `/session/mcp/${this.connectorId}/stream`;\n    }\n    #sessionIdPath() {\n        return `/session/mcp/${this.connectorId}/id`;\n    }\n    #newId() {\n        return ++this.#id;\n    }\n    async connect() {\n        if (this.#messageEndpoint) {\n            return err(`Already connected to \"${this.#messageEndpoint}\"`);\n        }\n        const file = this.#path();\n        const url = this.url;\n        const savedSession = json(await read({ path: this.#sessionIdPath() }));\n        if (ok(savedSession)) {\n            console.log(\"EXISTING SESSION\", savedSession);\n            this.#messageEndpoint = savedSession.endpoint;\n            return;\n        }\n        // Establish connection.\n        const connecting = await fetch({ url, file, stream: \"sse\" });\n        if (!ok(connecting))\n            return connecting;\n        // This is the connection path.\n        const path = connecting.response;\n        // Read the endpoint event\n        const connection = sse(await read({ path }));\n        if (!ok(connection))\n            return connection;\n        // do some crude URL munging.\n        const hostname = url.split(\"/\").slice(0, -1).join(\"/\");\n        const messageEndpoint = `${hostname}${connection}`;\n        const id = this.#newId();\n        // send initialize request\n        const initializing = await fetch({\n            url: messageEndpoint,\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify({\n                jsonrpc: \"2.0\",\n                id,\n                method: \"initialize\",\n                params: {\n                    protocolVersion: \"2024-11-05\",\n                    clientInfo: {\n                        name: \"Breadboard\",\n                        version: \"1.0.0\",\n                    },\n                    capabilities: {\n                        tools: {},\n                    },\n                },\n            }),\n        });\n        if (!ok(initializing))\n            return initializing;\n        const initializeResponse = rpc(await read({ path }));\n        if (!ok(initializeResponse))\n            return initializeResponse;\n        const confirmInitialization = await fetch({\n            url: messageEndpoint,\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify({\n                jsonrpc: \"2.0\",\n                method: \"notifications/initialized\",\n            }),\n        });\n        if (!ok(confirmInitialization))\n            return confirmInitialization;\n        this.#messageEndpoint = messageEndpoint;\n        // Save message endpoint\n        const savingMessageEndpoint = await write({\n            path: this.#sessionIdPath(),\n            data: [\n                {\n                    parts: [{ json: { endpoint: messageEndpoint } }],\n                },\n            ],\n        });\n        if (!ok(savingMessageEndpoint))\n            return savingMessageEndpoint;\n    }\n    async listTools() {\n        if (!this.#messageEndpoint) {\n            return err(`The client wasn't initialized. Call \"connect\" first.`);\n        }\n        const url = this.#messageEndpoint;\n        const id = this.#newId();\n        const path = this.#path();\n        // get list of tools\n        const askToListTools = await fetch({\n            url,\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify({\n                jsonrpc: \"2.0\",\n                id,\n                method: \"tools/list\",\n            }),\n        });\n        if (!ok(askToListTools))\n            return askToListTools;\n        const toolList = rpc(await read({ path }));\n        if (!ok(toolList))\n            return toolList;\n        return toolList.tools;\n    }\n    async callTool(name, args) {\n        if (!this.#messageEndpoint) {\n            return err(`The client wasn't initialized. Call \"connect\" first.`);\n        }\n        const url = this.#messageEndpoint;\n        const id = this.#newId();\n        const path = this.#path();\n        // Call tool\n        const askToCallTool = await fetch({\n            url,\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify({\n                jsonrpc: \"2.0\",\n                id,\n                method: \"tools/call\",\n                params: { name, arguments: args },\n            }),\n        });\n        const readCallToolResults = rpc(await read({ path }));\n        if (!ok(readCallToolResults))\n            return readCallToolResults;\n        return readCallToolResults.content;\n    }\n    async disconnect() {\n        const path = this.#path();\n        // Close the stream.\n        const deleting = await write({ path, delete: true });\n        if (!ok(deleting))\n            return deleting;\n    }\n}\nasync function mcp(url) {\n    const client = new McpClient(\"connectorid\", url);\n    const connecting = await client.connect();\n    if (!ok(connecting))\n        return connecting;\n    const tools = await client.listTools();\n    if (!ok(tools))\n        return tools;\n    await report({\n        actor: \"MCP Client\",\n        category: \"response\",\n        name: \"List of Tools\",\n        details: { parts: [{ json: tools }] },\n    });\n    const callingTool = await client.callTool(\"browser_navigate\", {\n        url: \"https://google.com\",\n    });\n    if (!ok(callingTool))\n        return callingTool;\n    await report({\n        actor: \"MCP Client\",\n        category: \"response\",\n        name: \"Calling Tool\",\n        details: { parts: [{ json: callingTool }] },\n    });\n    // const disconnecting = await client.disconnect();\n    // if (!ok(disconnecting)) return disconnecting;\n}\nasync function invoke({ endpoint }) {\n    const result = await mcp(endpoint);\n    if (!ok(result))\n        return result;\n    return { result: \"foo\" };\n    // const response = await fetch({\n    //   url: endpoint,\n    //   file: \"/run/saved\",\n    //   stream: \"sse\",\n    // });\n    // if (!ok(response)) return response;\n    // for (;;) {\n    //   const reading = await read({ path: response.response as FileSystemPath });\n    //   console.log(\"READING\", reading);\n    //   if (!ok(reading)) return reading;\n    //   if (\"done\" in reading && reading.done) {\n    //     return { result: \"done\" };\n    //   }\n    //   await report({\n    //     actor: \"Fetch\",\n    //     category: \"Streaming\",\n    //     name: \"Streaming OMG\",\n    //     details: reading.data?.at(-1) || \"none\",\n    //   });\n    // }\n    // return { result: \"done\" };\n}\nasync function describe() {\n    return {\n        inputSchema: {\n            type: \"object\",\n            properties: {\n                endpoint: {\n                    type: \"string\",\n                    title: \"Endpoint URL\",\n                    default: \"http://127.0.0.1:6277/sse?transportType=sse&url=http%3A%2F%2Flocalhost%3A3001%2Fsse\",\n                },\n            },\n        },\n        outputSchema: {\n            type: \"object\",\n            properties: {\n                result: {\n                    type: \"object\",\n                    title: \"Result\",\n                },\n            },\n        },\n    };\n}\n",
      "metadata": {
        "title": "main",
        "source": {
          "code": "/**\n * @fileoverview Add a description for your module here.\n */\n\nimport fetch from \"@fetch\";\nimport read from \"@read\";\nimport write from \"@write\";\nimport query from \"@query\";\nimport output from \"@output\";\n\nimport { ok, err } from \"./a2/utils\";\nimport { report } from \"./a2/output\";\n\nexport { invoke as default, describe };\n\ntype Inputs = {\n  endpoint: string;\n};\n\ntype Outputs = {\n  result: unknown;\n};\n\nexport type InitializeResponse = {\n  capabilities: {\n    resources?: {};\n    tools?: {};\n    prompts?: {};\n  };\n  protocolVersion: string;\n  serverInfo: {\n    name: string;\n    version: string;\n  };\n};\n\nexport type ListToolsTool = {\n  name: string;\n  // Schema is Breadboard-specific, but this should work well enough\n  inputSchema: Schema;\n};\n\nexport type ListToolsResponse = {\n  tools: ListToolsTool[];\n};\n\nexport type CallToolContentText = {\n  type: \"text\";\n  text: string;\n};\n\nexport type CallToolContentImage = {\n  type: \"image\";\n  data: string;\n  mimeType: string;\n};\n\nexport type CallToolContent = CallToolContentText | CallToolContentImage;\n\nexport type CallToolResponse = {\n  content: CallToolContent[];\n};\n\nexport type MCPResponse =\n  | InitializeResponse\n  | ListToolsResponse\n  | CallToolResponse;\n\nexport type JsonRpcResponse<M extends MCPResponse> = {\n  id: number;\n  jsonrpc: \"2.0\";\n  result: M;\n};\n\nexport type ServerSentEvent<T extends JsonSerializable = JsonSerializable> = {\n  data: T;\n  event: string;\n  id: string | null;\n  retry: string | null;\n};\n\nexport type SavedMessageEndpoint = {\n  endpoint: string;\n};\n\nfunction json<T>(result: FileSystemReadResult) {\n  if (!ok(result)) return result;\n  const j = (result.data?.at(-1)?.parts.at(0) as JSONPart)?.json;\n  if (!j) {\n    return err(`Invalid result structure`);\n  }\n  return j as T;\n}\n\nfunction sse<T extends JsonSerializable>(result: FileSystemReadResult) {\n  const e = json<ServerSentEvent<T>>(result);\n  if (!ok(e)) return e;\n  return e.data;\n}\n\nfunction rpc<M extends MCPResponse>(result: FileSystemReadResult) {\n  const e = sse<JsonRpcResponse<M>>(result);\n  if (!ok(e)) return e;\n  return e.result;\n}\n\nclass McpClient {\n  #id: number = 0;\n  #messageEndpoint: string | null = null;\n\n  constructor(\n    public readonly connectorId: string,\n    public readonly url: string\n  ) {}\n\n  #path(): FileSystemReadWritePath {\n    return `/session/mcp/${this.connectorId}/stream`;\n  }\n\n  #sessionIdPath(): FileSystemReadWritePath {\n    return `/session/mcp/${this.connectorId}/id`;\n  }\n\n  #newId() {\n    return ++this.#id;\n  }\n\n  async connect(): Promise<Outcome<void>> {\n    if (this.#messageEndpoint) {\n      return err(`Already connected to \"${this.#messageEndpoint}\"`);\n    }\n    const file = this.#path();\n    const url = this.url;\n\n    const savedSession = json<SavedMessageEndpoint>(\n      await read({ path: this.#sessionIdPath() })\n    );\n    if (ok(savedSession)) {\n      console.log(\"EXISTING SESSION\", savedSession);\n      this.#messageEndpoint = savedSession.endpoint;\n      return;\n    }\n\n    // Establish connection.\n    const connecting = await fetch({ url, file, stream: \"sse\" });\n    if (!ok(connecting)) return connecting;\n    // This is the connection path.\n    const path = connecting.response as FileSystemReadWritePath;\n\n    // Read the endpoint event\n    const connection = sse(await read({ path }));\n    if (!ok(connection)) return connection;\n\n    // do some crude URL munging.\n    const hostname = url.split(\"/\").slice(0, -1).join(\"/\");\n    const messageEndpoint = `${hostname}${connection}`;\n\n    const id = this.#newId();\n\n    // send initialize request\n    const initializing = await fetch({\n      url: messageEndpoint,\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n\n      body: JSON.stringify({\n        jsonrpc: \"2.0\",\n        id,\n        method: \"initialize\",\n        params: {\n          protocolVersion: \"2024-11-05\",\n          clientInfo: {\n            name: \"Breadboard\",\n            version: \"1.0.0\",\n          },\n          capabilities: {\n            tools: {},\n          },\n        },\n      }),\n    });\n    if (!ok(initializing)) return initializing;\n\n    const initializeResponse = rpc<InitializeResponse>(await read({ path }));\n    if (!ok(initializeResponse)) return initializeResponse;\n\n    const confirmInitialization = await fetch({\n      url: messageEndpoint,\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n\n      body: JSON.stringify({\n        jsonrpc: \"2.0\",\n        method: \"notifications/initialized\",\n      }),\n    });\n    if (!ok(confirmInitialization)) return confirmInitialization;\n\n    this.#messageEndpoint = messageEndpoint;\n    // Save message endpoint\n    const savingMessageEndpoint = await write({\n      path: this.#sessionIdPath(),\n      data: [\n        {\n          parts: [{ json: { endpoint: messageEndpoint } }],\n        },\n      ],\n    });\n    if (!ok(savingMessageEndpoint)) return savingMessageEndpoint;\n  }\n\n  async listTools(): Promise<Outcome<ListToolsTool[]>> {\n    if (!this.#messageEndpoint) {\n      return err(`The client wasn't initialized. Call \"connect\" first.`);\n    }\n    const url = this.#messageEndpoint;\n    const id = this.#newId();\n    const path = this.#path();\n    // get list of tools\n    const askToListTools = await fetch({\n      url,\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n\n      body: JSON.stringify({\n        jsonrpc: \"2.0\",\n        id,\n        method: \"tools/list\",\n      }),\n    });\n    if (!ok(askToListTools)) return askToListTools;\n\n    const toolList = rpc<ListToolsResponse>(await read({ path }));\n    if (!ok(toolList)) return toolList;\n    return toolList.tools;\n  }\n\n  async callTool(\n    name: string,\n    args: Record<string, JsonSerializable>\n  ): Promise<Outcome<CallToolContent[]>> {\n    if (!this.#messageEndpoint) {\n      return err(`The client wasn't initialized. Call \"connect\" first.`);\n    }\n\n    const url = this.#messageEndpoint;\n    const id = this.#newId();\n    const path = this.#path();\n\n    // Call tool\n    const askToCallTool = await fetch({\n      url,\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n\n      body: JSON.stringify({\n        jsonrpc: \"2.0\",\n        id,\n        method: \"tools/call\",\n        params: { name, arguments: args },\n      }),\n    });\n    const readCallToolResults = rpc<CallToolResponse>(await read({ path }));\n    if (!ok(readCallToolResults)) return readCallToolResults;\n    return readCallToolResults.content;\n  }\n\n  async disconnect(): Promise<Outcome<void>> {\n    const path = this.#path();\n\n    // Close the stream.\n    const deleting = await write({ path, delete: true });\n    if (!ok(deleting)) return deleting;\n  }\n}\n\nasync function mcp(url: string) {\n  const client = new McpClient(\"connectorid\", url);\n  const connecting = await client.connect();\n  if (!ok(connecting)) return connecting;\n\n  const tools = await client.listTools();\n  if (!ok(tools)) return tools;\n  await report({\n    actor: \"MCP Client\",\n    category: \"response\",\n    name: \"List of Tools\",\n    details: { parts: [{ json: tools }] },\n  });\n\n  const callingTool = await client.callTool(\"browser_navigate\", {\n    url: \"https://google.com\",\n  });\n  if (!ok(callingTool)) return callingTool;\n  await report({\n    actor: \"MCP Client\",\n    category: \"response\",\n    name: \"Calling Tool\",\n    details: { parts: [{ json: callingTool }] },\n  });\n\n  // const disconnecting = await client.disconnect();\n  // if (!ok(disconnecting)) return disconnecting;\n}\n\nasync function invoke({ endpoint }: Inputs): Promise<Outcome<Outputs>> {\n  const result = await mcp(endpoint);\n  if (!ok(result)) return result;\n  return { result: \"foo\" };\n  // const response = await fetch({\n  //   url: endpoint,\n  //   file: \"/run/saved\",\n  //   stream: \"sse\",\n  // });\n  // if (!ok(response)) return response;\n  // for (;;) {\n  //   const reading = await read({ path: response.response as FileSystemPath });\n  //   console.log(\"READING\", reading);\n  //   if (!ok(reading)) return reading;\n  //   if (\"done\" in reading && reading.done) {\n  //     return { result: \"done\" };\n  //   }\n  //   await report({\n  //     actor: \"Fetch\",\n  //     category: \"Streaming\",\n  //     name: \"Streaming OMG\",\n  //     details: reading.data?.at(-1) || \"none\",\n  //   });\n  // }\n  // return { result: \"done\" };\n}\n\nasync function describe() {\n  return {\n    inputSchema: {\n      type: \"object\",\n      properties: {\n        endpoint: {\n          type: \"string\",\n          title: \"Endpoint URL\",\n          default:\n            \"http://127.0.0.1:6277/sse?transportType=sse&url=http%3A%2F%2Flocalhost%3A3001%2Fsse\",\n        },\n      },\n    } satisfies Schema,\n    outputSchema: {\n      type: \"object\",\n      properties: {\n        result: {\n          type: \"object\",\n          title: \"Result\",\n        },\n      },\n    } satisfies Schema,\n  };\n}\n",
          "language": "typescript"
        },
        "description": "Add a description for your module here.",
        "runnable": true
      }
    }
  },
  "imports": {
    "a2": {
      "url": "./a2.bgl.json"
    }
  }
}