/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import * as esbuild from "esbuild";
import type { JSONSchema7 } from "json-schema";
import { basename, relative } from "node:path";
import * as prettier from "prettier";
import * as tjs from "typescript-json-schema";
import type { Config } from "./config.js";

export async function generate(config: Config, inputPath: string) {
  const [code, schemas] = await Promise.all([
    bundleCode(inputPath),
    extractSchemas(inputPath, config.tsconfigPath),
  ]);
  const generated = generateSource(code, schemas, inputPath, config.outputDir);
  let formatted: string;
  try {
    formatted = await prettier.format(generated, { parser: "typescript" });
  } catch (e) {
    throw new AggregateError(
      [e],
      `Error from prettier while formatting ${inputPath}`
    );
  }
  return formatted;
}

async function bundleCode(inputPath: string): Promise<string> {
  const config: esbuild.BuildOptions = {
    entryPoints: [inputPath],
    format: "esm",
    bundle: true,
    write: false,
    legalComments: "inline",
  };
  let bundle;
  try {
    bundle = await esbuild.build(config);
  } catch (e) {
    throw new AggregateError(
      [e],
      `Error from esbuild with config ${JSON.stringify(config)}`
    );
  }
  for (const warning of bundle.warnings) {
    console.warn(
      `Warning from esbuild while bundling ${inputPath}: ` +
        `${JSON.stringify(warning)}`
    );
  }
  if (bundle.errors.length > 0) {
    throw new Error(
      `Error bundling file ${inputPath}: ${JSON.stringify(bundle.errors)}`
    );
  }
  if (bundle.outputFiles === undefined || bundle.outputFiles.length !== 1) {
    throw new Error(
      `Error bundling file ${inputPath}: ` +
        `Expected 1 output file, got ${bundle.outputFiles?.length ?? 0}.`
    );
  }
  return bundle.outputFiles[0]!.text;
}

interface Schemas {
  inputSchema: JSONSchema7;
  outputSchema: JSONSchema7;
}

export async function extractSchemas(
  inputPath: string,
  tsconfigPath: string
): Promise<Schemas> {
  const tjsProgram = tjs.programFromConfig(tsconfigPath, [inputPath]);
  const tjsConfig: tjs.PartialArgs = {
    required: true,
    skipLibCheck: true,
  };
  let tjsGenerator;
  try {
    tjsGenerator = tjs.buildGenerator(tjsProgram, tjsConfig);
  } catch (e) {
    throw new AggregateError(
      [e],
      `Error from typescript-json-schema with config ${JSON.stringify(tjsConfig)}`
    );
  }
  if (tjsGenerator === null) {
    throw new Error("Generator is null");
  }
  const inputSchema = tjsGenerator.getSchemaForSymbol("Inputs") as
    | JSONSchema7
    | undefined;
  const outputSchema = tjsGenerator.getSchemaForSymbol("Outputs") as
    | JSONSchema7
    | undefined;
  if (inputSchema === undefined || outputSchema === undefined) {
    throw new Error("Expected exported types called Inputs and Outputs");
  }
  // We don't need `$schema: "http://json-schema.org/draft-07/schema#"`
  delete inputSchema["$schema"];
  delete outputSchema["$schema"];
  return { inputSchema, outputSchema };
}

function generateSource(
  bundledCode: string,
  { inputSchema, outputSchema }: Schemas,
  inputPath: string,
  outputDir: string
): string {
  const sourceImportSpecifier = relative(outputDir, inputPath).replace(
    /\.ts$/,
    ".js"
  );
  const functionName = kebabToCamel(basename(inputPath).replace(/\.ts/, ""));
  return `
    import {makeRunJavascriptComponent} from "./support.js";
    import type {Inputs, Outputs} from "${sourceImportSpecifier}";

    /**
     * This function was generated by @breadboard-ai/build-code from
     * ${relative(process.cwd(), inputPath)}
     */
    export const ${functionName} = makeRunJavascriptComponent<Inputs, Outputs>({
      code: \`${escapeForTemplateLiteral(bundledCode)}\`,
      inputSchema: ${JSON.stringify(inputSchema)},
      outputSchema: ${JSON.stringify(outputSchema)},
    });
  `;
}

function kebabToCamel(kebab: string): string {
  return kebab
    .toLowerCase()
    .replace(/[-_][a-z]/g, (group) => group.slice(-1).toUpperCase());
}

function escapeForTemplateLiteral(str: string): string {
  return str.replace(/`/g, "\\`").replace(/\${/g, "\\${");
}
