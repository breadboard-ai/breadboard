/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import * as esbuild from "esbuild";
import type { JSONSchema7 } from "json-schema";
import { basename, relative } from "node:path";
import * as prettier from "prettier";
import * as tsj from "ts-json-schema-generator";
import type { Config } from "./config.js";

export async function generate(config: Config, inputPath: string) {
  const generated = generateSource(
    await bundleCode(inputPath),
    extractSchemas(inputPath, config.tsconfigPath),
    inputPath,
    config.outputDir
  );
  let formatted: string;
  try {
    formatted = await prettier.format(generated, { parser: "typescript" });
  } catch (e) {
    throw new AggregateError(
      [e],
      `Error from prettier while formatting ${inputPath}`
    );
  }
  return formatted;
}

async function bundleCode(inputPath: string): Promise<string> {
  const config: esbuild.BuildOptions = {
    entryPoints: [inputPath],
    format: "esm",
    bundle: true,
    write: false,
    legalComments: "inline",
  };
  let bundle;
  try {
    bundle = await esbuild.build(config);
  } catch (e) {
    throw new AggregateError(
      [e],
      `Error from esbuild with config ${JSON.stringify(config)}`
    );
  }
  for (const warning of bundle.warnings) {
    console.warn(
      `Warning from esbuild while bundling ${inputPath}: ` +
        `${JSON.stringify(warning)}`
    );
  }
  if (bundle.errors.length > 0) {
    throw new Error(
      `Error bundling file ${inputPath}: ${JSON.stringify(bundle.errors)}`
    );
  }
  if (bundle.outputFiles === undefined || bundle.outputFiles.length !== 1) {
    throw new Error(
      `Error bundling file ${inputPath}: ` +
        `Expected 1 output file, got ${bundle.outputFiles?.length ?? 0}.`
    );
  }
  return bundle.outputFiles[0]!.text;
}

interface Schemas {
  inputSchema: JSONSchema7;
  outputSchema: JSONSchema7;
}

function extractSchemas(inputPath: string, tsconfigPath: string): Schemas {
  const config: tsj.Config = {
    path: inputPath,
    tsconfig: tsconfigPath,
    type: "*",
    skipTypeCheck: true,
  };
  let schema: JSONSchema7;
  try {
    schema = tsj.createGenerator(config).createSchema("*");
  } catch (e) {
    if (e instanceof tsj.BuildError) {
      console.error(e.diagnostic);
    }
    throw new AggregateError(
      [e],
      `Error from ts-json-schema-generator with config ${JSON.stringify(config)}`
    );
  }
  const inputSchema = schema.definitions?.["Inputs"];
  const outputSchema = schema.definitions?.["Outputs"];
  if (inputSchema === undefined || outputSchema === undefined) {
    throw new Error("Expected exported types called Inputs and Outputs");
  }
  if (typeof inputSchema !== "object" || typeof outputSchema !== "object") {
    throw new Error(
      `Internal error: unexpected types of inputSchema/outputSchema ` +
        `(${typeof inputSchema}/${typeof outputSchema})`
    );
  }
  return { inputSchema, outputSchema };
}

function generateSource(
  bundledCode: string,
  { inputSchema, outputSchema }: Schemas,
  inputPath: string,
  outputDir: string
): string {
  const sourceImportSpecifier = relative(outputDir, inputPath).replace(
    /\.ts$/,
    ".js"
  );
  const functionName = kebabToCamel(basename(inputPath).replace(/\.ts/, ""));
  return `
    import {makeRunJavascriptComponent} from "./support.js";
    import type {Inputs, Outputs} from "${sourceImportSpecifier}";

    /**
     * This function was generated by @breadboard-ai/build-code from
     * ${relative(process.cwd(), inputPath)}
     */
    export const ${functionName} = makeRunJavascriptComponent<Inputs, Outputs>({
      code: \`${escapeForTemplateLiteral(bundledCode)}\`,
      inputSchema: ${JSON.stringify(inputSchema)},
      outputSchema: ${JSON.stringify(outputSchema)},
    });
  `;
}

function kebabToCamel(kebab: string): string {
  return kebab
    .toLowerCase()
    .replace(/[-_][a-z]/g, (group) => group.slice(-1).toUpperCase());
}

function escapeForTemplateLiteral(str: string): string {
  return str.replace(/`/g, "\\`").replace(/\${/g, "\\${");
}
