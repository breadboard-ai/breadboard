/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import * as esbuild from "esbuild";
import type { JSONSchema7 } from "json-schema";
import { basename, relative } from "node:path";
import * as prettier from "prettier";
import * as tsj from "ts-json-schema-generator";
import type { Config } from "./config.js";

export async function generate(config: Config, inputPath: string) {
  const generated = generateSource(
    await bundleCode(inputPath),
    extractSchemas(inputPath, config.tsconfigPath),
    inputPath,
    config.outputDir
  );
  const formatted = await prettier.format(generated, { parser: "typescript" });
  return formatted;
}

async function bundleCode(inputPath: string): Promise<string> {
  const bundle = await esbuild.build({
    entryPoints: [inputPath],
    format: "esm",
    bundle: true,
    write: false,
    legalComments: "inline",
  });
  if (bundle.errors.length > 0) {
    throw new Error(`Error bundling file ${inputPath}: ${bundle.errors}`);
  }
  if (bundle.outputFiles.length !== 1) {
    throw new Error(
      `Error bundling file ${inputPath}: ` +
        `Expected 1 output file, got ${bundle.outputFiles.length}.`
    );
  }
  return bundle.outputFiles[0]!.text;
}

interface Schemas {
  inputSchema: JSONSchema7;
  outputSchema: JSONSchema7;
}

function extractSchemas(inputPath: string, tsconfigPath: string): Schemas {
  const generator = tsj.createGenerator({
    path: inputPath,
    tsconfig: tsconfigPath,
    type: "*",
  });
  const schema = generator.createSchema("*");
  const inputSchema = schema.definitions?.["Inputs"];
  const outputSchema = schema.definitions?.["Outputs"];
  if (inputSchema === undefined || outputSchema === undefined) {
    throw new Error("Expected exported types called Inputs and Outputs");
  }
  if (typeof inputSchema !== "object" || typeof outputSchema !== "object") {
    throw new Error(
      `Internal error: unexpected types of inputSchema/outputSchema ` +
        `(${typeof inputSchema}/${typeof outputSchema})`
    );
  }
  return { inputSchema, outputSchema };
}

function generateSource(
  bundledCode: string,
  { inputSchema, outputSchema }: Schemas,
  inputPath: string,
  outputDir: string
): string {
  const sourceImportSpecifier = relative(outputDir, inputPath).replace(
    /\.ts$/,
    ".js"
  );
  const functionName = kebabToCamel(basename(inputPath).replace(/\.ts/, ""));
  return `
    import {makeRunJavascriptComponent} from "@breadboard-ai/build-code";
    import type {Inputs, Outputs} from "${sourceImportSpecifier}";

    /**
     * This function was generated by @breadboard-ai/build-code from
     * ${relative(process.cwd(), inputPath)}
     */
    export const ${functionName} = makeRunJavascriptComponent<Inputs, Outputs>({
      code: \`${escapeForTemplateLiteral(bundledCode)}\`,
      inputSchema: ${JSON.stringify(inputSchema)},
      outputSchema: ${JSON.stringify(outputSchema)},
    });
  `;
}

function kebabToCamel(kebab: string): string {
  return kebab
    .toLowerCase()
    .replace(/[-_][a-z]/g, (group) => group.slice(-1).toUpperCase());
}

function escapeForTemplateLiteral(str: string): string {
  return str.replace(/`/g, "\\`").replace(/\${/g, "\\${");
}
