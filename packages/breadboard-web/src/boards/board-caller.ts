/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {
  Board,
  GraphMetadata,
  Schema,
  V,
  base,
  recipe,
} from "@google-labs/breadboard";
import Core, { core } from "@google-labs/core-kit";
import Starter, { starter } from "@google-labs/llm-starter";

const metadata = {
  title: "Board Caller",
  description:
    "Takes a tool-calling-capable generator and a list of board URLs, and helps generator call these boards as tools",
  version: "0.0.6",
} satisfies GraphMetadata;

const outputSchema = {
  type: "object",
  properties: {
    result: {
      type: "object",
      title: "Result",
      description: "The result generated by the tool",
    },
    name: {
      type: "string",
      title: "Tool Name",
      description: "The name of the tool that generated the text",
    },
    context: {
      type: "array",
      title: "Context",
      description: "The conversation context",
    },
  },
} satisfies Schema;

const parametersSchema = {
  type: "object",
  properties: {
    text: {
      type: "string",
      title: "Text",
      description: "The text to use with tool calling",
      examples: ["What is the square root of e?"],
    },
    context: {
      type: "array",
      title: "Context",
      description: "An array of messages to use as conversation context",
      items: {
        type: "object",
      },
      default: "[]",
    },
    generator: {
      type: "string",
      title: "Generator",
      description: "The URL of the generator to call",
      examples: ["gemini-generator.json"],
    },
    boards: {
      type: "array",
      title: "Tools",
      description: "URLs of boards to use as tools",
      items: {
        type: "string",
      },
      examples: [
        '[ "https://raw.githubusercontent.com/breadboard-ai/breadboard/main/packages/breadboard-web/public/graphs/math.json", "https://raw.githubusercontent.com/breadboard-ai/breadboard/main/packages/breadboard-web/public/graphs/search-summarize.json" ]',
      ],
    },
  },
  required: ["text", "boards"],
} satisfies Schema;

// const board = new Board(metadata);

// const starter = board.addKit(Starter);
// const core = board.addKit(Core);

export default await recipe(async () => {
  const parameters = base.input({
    $id: "parameters",
    schema: parametersSchema,
  });

  /**
   * Formats a list of boards as function declarations that can be supplied
   * to a generator.
   */
  const formatFunctionDeclarations = recipe(async () => {
    const input = base.input({ $id: "boards" });
    const turnBoardsToFunctions = core.map({
      board: recipe(async () => {
        const input = base.input({});
        // for each URL, invoke board-as-function.
        const boardToFunction = core.invoke({
          $id: "boardToFunction",
          path: "/graphs/board-as-function.json",
          boardURL: input.item,
        });
        return base.output({
          function: boardToFunction,
          boardURL: input.item,
        });
      }),
      list: input.boards as V<string[]>,
      //   input
      //     .wire(
      //       "item->boardURL",
      //       core
      //         .invoke({
      //           $id: "boardToFunction",
      //           path: "/graphs/board-as-function.json",
      //         })
      //         .wire("function->", output)
      //     )
      //     .wire("item->boardURL", output);
      // }),
    });

    return starter
      .jsonata({
        $id: "formatResults",
        expression: `{
        "tools": [function],
        "urlMap": $merge([{ function.name: boardURL }])
      }`,
        raw: true,
        json: turnBoardsToFunctions.list as unknown as V<string>,
      })
      .to(base.output({}));

    // input.wire(
    //   "boards->list",
    //   turnBoardsToFunctions.wire(
    //     "list->json",
    //     formatResults.wire("*->", output)
    //   )
    // );
  })({
    $id: "formatFunctionDeclarations",
    boards: parameters,
  });

  const generate = core.invoke({
    $id: "generate",
    useStreaming: false,
    text: parameters.text as V<string>,
    path: parameters.generator as V<string>,
    context: parameters.context as V<string[]>,
    tools: formatFunctionDeclarations,
  });

  const getBoardArgs = starter.jsonata({
    $id: "getBoardArgs",
    expression: `$merge([{
      "path": $lookup(urlMap, toolCalls[0].name)
    },
    toolCalls[0].args,
    { "generator": generator }
  ])`,
    raw: true,
    urlMap: formatFunctionDeclarations,
    toolCalls: generate,
    generator: parameters,
  });

  const callBoardAsTool = core.invoke({
    $id: "callBoardAsTool",
    ...getBoardArgs,
  });

  const hoistOutputs = starter.jsonata({
    $id: "hoistOutputs",
    expression: `$ ~> | ** | {}, "schema" |`,
    ...callBoardAsTool,
  });
  // .wire("result->", formatOutput.wire("*->", output));

  const formatOutput = starter.jsonata({
    $id: "formatOutput",
    expression: `{ "result": result, "name": toolCalls[0].name, "context": context }`,
    raw: true,
    result: hoistOutputs,
    ...generate,
  });

  const output = base.output({
    $id: "output",
    schema: outputSchema,
    ...formatOutput,
  });

  return output;

  // parameters
  //   .wire("text->", generate)
  //   .wire("context->", generate)
  //   .wire(
  //     "boards->",
  //     formatFunctionDeclarations
  //       .wire("tools->", generate)
  //       .wire("urlMap->", getBoardArgs)
  //   )
  //   .wire(
  //     "generator->path",
  //     generate
  //       .wire(
  //         "toolCalls->",
  //         getBoardArgs
  //           .wire(
  //             "*->",
  //             core.invoke({ $id: "callBoardAsTool" }).wire(
  //               "*->",
  //               starter
  //                 .jsonata({
  //                   $id: "hoistOutputs",
  //                   expression: `$ ~> | ** | {}, "schema" |`,
  //                 })
  //                 .wire("result->", formatOutput.wire("*->", output))
  //             )
  //           )
  //           .wire("<-generator", parameters)
  //       )
  //       .wire("context->", formatOutput)
  //   );
}).serialize(metadata);

// export default board;
