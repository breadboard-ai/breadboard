/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {
  GraphInlineMetadata,
  Schema,
  V,
  base,
  board,
} from "@google-labs/breadboard";
import { core } from "@google-labs/core-kit";
import { json } from "@google-labs/json-kit";

const metadata = {
  title: "Board Caller",
  description:
    "Takes a tool-calling-capable generator and a list of board URLs, and helps generator call these boards as tools",
  version: "0.0.6",
} satisfies GraphInlineMetadata;

const outputSchema = {
  type: "object",
  properties: {
    result: {
      type: "object",
      title: "Result",
      description: "The result generated by the tool",
    },
    name: {
      type: "string",
      title: "Tool Name",
      description: "The name of the tool that generated the text",
    },
    context: {
      type: "array",
      title: "Context",
      description: "The conversation context",
    },
  },
} satisfies Schema;

const parametersSchema = {
  type: "object",
  properties: {
    text: {
      type: "string",
      title: "Text",
      description: "The text to use with tool calling",
      examples: ["What is the square root of e?"],
    },
    context: {
      type: "array",
      title: "Context",
      description: "An array of messages to use as conversation context",
      items: {
        type: "object",
      },
      default: "[]",
    },
    generator: {
      type: "string",
      title: "Generator",
      description: "The URL of the generator to call",
      examples: ["gemini-generator.json"],
    },
    boards: {
      type: "array",
      title: "Tools",
      description: "URLs of boards to use as tools",
      items: {
        type: "string",
      },
      examples: [
        '[ "https://raw.githubusercontent.com/breadboard-ai/breadboard/main/packages/breadboard-web/public/graphs/math.json", "https://raw.githubusercontent.com/breadboard-ai/breadboard/main/packages/breadboard-web/public/graphs/search-summarize.json" ]',
      ],
    },
  },
  required: ["text", "boards"],
} satisfies Schema;

export default await board(() => {
  const parameters = base.input({
    $id: "parameters",
    schema: parametersSchema,
  });

  /**
   * Formats a list of boards as function declarations that can be supplied
   * to a generator.
   */
  const formatFunctionDeclarations = board(({ boards }) => {
    const turnBoardsToFunctions = core.map({
      board: board(({ item }) => {
        // for each URL, invoke board-as-function.
        const boardToFunction = core.invoke({
          $id: "boardToFunction",
          $board: "board-as-function.json",
          boardURL: item,
        });
        return {
          function: boardToFunction,
          boardURL: item,
        };
      }),
      list: boards as V<string[]>,
    });

    return json
      .jsonata({
        $id: "formatResults",
        expression: `{
          "tools": [list.function],
          "urlMap": $merge([list.{ function.name: boardURL }])
        }`,
        raw: true,
        list: turnBoardsToFunctions,
      })
      .to(base.output({}));
  })({
    $id: "formatFunctionDeclarations",
    boards: parameters,
  });

  const generate = core.invoke({
    $id: "generate",
    useStreaming: false,
    ...parameters,
    $board: parameters.generator as V<string>,
    tools: formatFunctionDeclarations,
  });

  const getBoardArgs = json.jsonata({
    $id: "getBoardArgs",
    expression: `$merge([{
        "$board": $lookup(urlMap, toolCalls[0].name)
      },
      toolCalls[0].args,
      { "generator": generator }
    ])`,
    raw: true,
    urlMap: formatFunctionDeclarations,
    toolCalls: generate,
    generator: parameters,
  });

  const callBoardAsTool = core.invoke({
    $id: "callBoardAsTool",
    ...getBoardArgs,
  });

  const hoistOutputs = json.jsonata({
    $id: "hoistOutputs",
    expression: `$ ~> | ** | {}, "schema" |`,
    ...callBoardAsTool,
  });

  const formatOutput = json.jsonata({
    $id: "formatOutput",
    expression: `{
      "result": result,
      "name": toolCalls[0].name,
      "context": context
    }`,
    raw: true,
    result: hoistOutputs,
    ...generate,
  });

  const output = base.output({
    $id: "output",
    schema: outputSchema,
    ...formatOutput,
  });

  return output;
}).serialize(metadata);
