/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import { err, type Outcome } from "@google-labs/breadboard";

// PORTED FROM
// packages/board-server/src/server/blobs/utils/gemini-file-api.ts
// TODO: Deduplicate (probably in favor of this one)

export type FileAPIMetadata = {
  fileUri?: string;
  expirationTime?: string;
};

export type FileApiState =
  // The default value. This value is used if the state is omitted.
  | "STATE_UNSPECIFIED"
  // File is being processed and cannot be used for inference yet.
  | "PROCESSING"
  // File is processed and available for inference.
  | "ACTIVE"
  // File failed processing.
  | "FAILED";

export type FileApiSource =
  // Used if source is not specified.
  | "SOURCE_UNSPECIFIED"
  // Indicates the file is uploaded by the user.
  | "UPLOADED"
  // Indicates the file is generated by Google.
  | "GENERATED";

export type FileApiError = {
  code: number;
  message: string;
  details: Record<string, string>;
};

export type FileApiFile = {
  name: string;
  displayName: string;
  mimeType: string;
  sizeBytes: string;
  createTime: string;
  updateTime: string;
  expirationTime: string;
  sha256hash: string;
  uri: string;
  downloadUri?: string;
  state: FileApiState;
  source: FileApiSource;
  error?: FileApiError;
};

export type FileApiResponse = {
  file: FileApiFile;
};

export { GeminiFileApi };

const CHUNK_GRANULARITY = 8 * 1024 * 1024;

const WAITING_TIME_MS = 5 * 1024;

const API_URL = "https://generativelanguage.googleapis.com";

class GeminiFileApi {
  constructor(public readonly accessToken: string) {}

  #createInitialRequest(
    length: string | number,
    mimeType: string,
    displayName: string
  ): Request {
    return new Request(`${API_URL}/upload/v1beta/files`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${this.accessToken}`,
        "X-Goog-Upload-Protocol": "resumable",
        "X-Goog-Upload-Command": "start",
        "X-Goog-Upload-Header-Content-Length": `${length}`,
        "X-Goog-Upload-Header-Content-Type": mimeType,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        file: {
          display_name: displayName,
        },
      }),
    });
  }

  #createUploadRequest(
    body: ArrayBuffer,
    uploadUrl: string,
    length: number,
    offset: number,
    finalize: boolean
  ): Request {
    const command: string[] = ["upload"];
    if (finalize) command.push("finalize");
    return new Request(uploadUrl, {
      method: "POST",
      headers: {
        "Content-Length": `${length}`,
        "X-Goog-Upload-Offset": `${offset}`,
        "X-Goog-Upload-Command": command.join(", "),
      },
      body,
    });
  }

  #createGetFileRequest(fileUri: string): Request {
    return new Request(`${fileUri}`, {
      headers: {
        Authorization: `Bearer ${this.accessToken}`,
      },
    });
  }

  async #waitTillProcessed(
    response: FileApiResponse
  ): Promise<Outcome<FileAPIMetadata>> {
    const { uri } = response.file;
    for (;;) {
      await sleep(WAITING_TIME_MS);
      try {
        const checkingStatus = await fetch(this.#createGetFileRequest(uri));
        if (!checkingStatus.ok) {
          return err(await checkingStatus.text());
        }
        const result = (await checkingStatus.json()) as FileApiFile;
        const { state } = result;
        if (state === "ACTIVE") {
          const { uri: fileUri, expirationTime } = result;
          return { fileUri, expirationTime };
        } else if (state === "FAILED") {
          return err(`File API failed to process file "${uri}"`);
        }
      } catch (e) {
        return err((e as Error).message);
      }
    }
  }

  async upload(
    response: Response,
    displayName: string,
    mimeType = "application/pdf"
  ): Promise<Outcome<FileAPIMetadata>> {
    try {
      // Unfortunately, needs to read it all into memory
      // to get the final size.
      const blob = await response.blob();
      const length = blob.size;

      const initializing = await fetch(
        this.#createInitialRequest(length, mimeType, displayName)
      );
      if (!initializing.ok) {
        return err(await initializing.text());
      }

      const uploadUrl = initializing.headers.get("x-goog-upload-url");

      if (!uploadUrl) {
        return err(`Unable to get upload URL for file "${displayName}"`);
      }

      let offset = 0;

      for await (const array of readInChunks(blob)) {
        const finalize = array.byteLength < CHUNK_GRANULARITY;
        const length = array.byteLength;
        const uploading = await fetch(
          this.#createUploadRequest(array, uploadUrl, length, offset, finalize)
        );
        if (!uploading.ok) {
          return err(await uploading.text());
        }
        if (finalize) {
          const result = (await uploading.json()) as FileApiResponse;
          const { file } = result;
          if (file.state === "FAILED") {
            return err(file.error?.message || "File API upload failed");
          }
          if (file.state === "PROCESSING") {
            return this.#waitTillProcessed(result);
          }
          return {
            fileUri: file.uri,
            expirationTime: file.expirationTime,
          };
        }
        offset += length;
      }

      return {};
    } catch (e) {
      return err((e as Error).message);
    }
  }
}

async function* readInChunks(blob: Blob) {
  let offset = 0;
  const size = blob.size;
  while (offset < size) {
    const currentChunkSize = Math.min(CHUNK_GRANULARITY, size - offset);
    const chunk = blob.slice(offset, offset + currentChunkSize);
    const reader = new FileReader();
    yield new Promise<ArrayBuffer>((resolve, reject) => {
      reader.onload = (event) => {
        if (event.target && event.target.result instanceof ArrayBuffer) {
          resolve(event.target.result);
        } else {
          reject(new Error(`Failed to read chunk as ArrayBuffer`));
        }
      };
      reader.onerror = (event) => {
        reject(new Error(`Error reading chunk: ${event.target?.error}`));
      };
      reader.readAsArrayBuffer(chunk);
    });
    offset += currentChunkSize;
  }
}

async function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
